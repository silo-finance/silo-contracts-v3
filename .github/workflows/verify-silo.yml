name: Verify Silo Config

env:
    RPC_MAINNET: ${{ secrets.RPC_MAINNET }}
    RPC_ARBITRUM_ONE: ${{ secrets.RPC_ARBITRUM }}
    RPC_OPTIMISM: ${{ secrets.RPC_OPTIMISM }}
    RPC_ANVIL: ${{ secrets.RPC_ANVIL }}
    RPC_SONIC: ${{ secrets.RPC_SONIC }}
    RPC_AVALANCHE: ${{ secrets.RPC_AVALANCHE }}
    PRIVATE_KEY: ${{ secrets.ANVIL_PRIVATE_KEY }}
    VERIFIER_URL_SONIC: ${{ secrets.VERIFIER_URL_SONIC }}
    VERIFIER_API_KEY_SONIC: ${{ secrets.VERIFIER_API_KEY_SONIC }}
    AGGREGATOR: "1INCH" # because it is available on all blockchains

on:
  pull_request:
    # Trigger only when the deployments file is changed
    paths:
      - 'silo-core/deploy/silo/_siloDeployments.json'

jobs:
  count-config-changes:
    runs-on: ubuntu-latest
    outputs:
      config_count: ${{ steps.count.outputs.config_count }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Count Silo configs in diff
        id: count
        run: |
          FILE=silo-core/deploy/silo/_siloDeployments.json
          BASE_REF="${{ github.base_ref }}"
          N=$(git diff "origin/$BASE_REF" -- "$FILE" 2>/dev/null | grep '^+' | grep -E '"[^"]+":\s*"0x[0-9a-fA-F]{40}"' | wc -l)
          echo "config_count=$N" >> $GITHUB_OUTPUT
          echo "Silo config count: $N (workflow runs only when exactly 1)"

  verify:
    runs-on: ubuntu-latest
    needs: count-config-changes
    # Run only when exactly one Silo config was added (skip when 0 or 2+)
    if: needs.count-config-changes.outputs.config_count == '1'

    permissions:
      pull-requests: write  # Required to post a comment on the PR

    steps:
      - uses: actions/checkout@v3
      
      # Cache all git submodules (large gitmodules/* tree and .git/modules) to speed up CI.
      # Keyed only by .gitmodules so cache can be reused across commits; git will fetch deltas if submodule refs change.
      -   name: Cache git submodules
          uses: actions/cache@v4
          with:
              path: |
                  gitmodules
                  .git/modules
              key: gitmodules-v1-${{ hashFiles('.gitmodules') }}
              restore-keys: |
                  gitmodules-v1-

      -   name: Init git submodules (uses cached clones when available)
          run: |
              git submodule sync --recursive
              git submodule update --init --recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          version: v1.2.3

      - name: Build silo foundry utils
        working-directory: ./gitmodules/silo-foundry-utils
        run: |
          cargo build --release
          cp target/release/silo-foundry-utils ../../silo-foundry-utils
          ../../silo-foundry-utils --version

      # Extract CONFIG address and CHAIN (RPC key) from the changed JSON file
      - name: Extract CONFIG and CHAIN
        id: extract
        run: |
          FILE=silo-core/deploy/silo/_siloDeployments.json
          BASE_REF=${{ github.base_ref }}

          # Get the last added config entry (a line that starts with "+" and contains an address)
          DIFF_LINE=$(git diff origin/$BASE_REF -- $FILE | grep '^+' | grep -E '"[^"]+":\s*"0x[0-9a-fA-F]{40}"' | tail -n1)

          # Extract config key and address
          CONFIG_NAME=$(echo "$DIFF_LINE" | grep -oP '"[^"]+"' | head -1 | tr -d '"')
          CONFIG=$(echo "$DIFF_LINE" | grep -oP '0x[0-9a-fA-F]{40}')

          # Extract chain (level 1 key)
          CHAIN=$(jq -r --arg address "$CONFIG" '
            to_entries[] |
            select(.value | type == "object") |
            select(.value | to_entries[] | .value == $address) |
            .key' "$FILE")

          # Construct the RPC environment variable name, e.g., RPC_MAINNET
          RPC_VAR="RPC_${CHAIN^^}"
          RPC_URL=$(eval echo \$$RPC_VAR)

          # Fail if RPC URL is missing
          if [[ -z "$RPC_URL" ]]; then
            echo "::error title=Missing RPC::RPC URL for chain '$CHAIN' not found in env var '$RPC_VAR'"
            exit 1
          fi

          # Set outputs for use in next steps
          echo "CONFIG=$CONFIG"
          echo "CONFIG=$CONFIG" >> $GITHUB_OUTPUT
          echo "CHAIN=$CHAIN"
          echo "CHAIN=$CHAIN" >> $GITHUB_OUTPUT
          echo "RPC_URL=$RPC_URL"
          echo "RPC_URL=$RPC_URL" >> $GITHUB_OUTPUT
          echo "CONFIG_NAME=$CONFIG_NAME" >> $GITHUB_OUTPUT

      - name: Extract optional price arguments from PR body
        id: price
        run: |
          # Fetch the current PR body using GitHub API
          CURRENT_BODY=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.number }}" \
            | jq -r '.body')
          
          # Replace \r with newlines to handle copy-paste from Windows
          CLEANED_BODY=$(echo "$CURRENT_BODY" | sed 's/\r/\n/g')
      
          # Extract prices using pattern match
          PRICE_0=$(echo "$CLEANED_BODY" | grep -i 'EXTERNAL_PRICE_0' | head -n1 | sed 's/ //g' | cut -d= -f2)
          PRICE_1=$(echo "$CLEANED_BODY" | grep -i 'EXTERNAL_PRICE_1' | head -n1 | sed 's/ //g' | cut -d= -f2)
          
          # Check if prices are missing and fail with error
          if [[ -z "$PRICE_0" ]]; then
            echo "::error title=Missing Price::EXTERNAL_PRICE_0 not found in PR body. Please add EXTERNAL_PRICE_0=<value> to the PR description."
            exit 1
          fi
          
          if [[ -z "$PRICE_1" ]]; then
            echo "::error title=Missing Price::EXTERNAL_PRICE_1 not found in PR body. Please add EXTERNAL_PRICE_1=<value> to the PR description."
            exit 1
          fi
          
          echo "$PRICE_0"
          echo "$PRICE_1"
          echo "EXTERNAL_PRICE_0=$PRICE_0" >> $GITHUB_OUTPUT
          echo "EXTERNAL_PRICE_1=$PRICE_1" >> $GITHUB_OUTPUT

      # Run the forge script with extracted parameters
      - name: Run verify script
        id: verify
        run: |
          echo "Running verify script for ${{ steps.extract.outputs.CONFIG_NAME }} (${{ steps.extract.outputs.CONFIG }}) on ${{ steps.extract.outputs.CHAIN }}"
          
          VERIFIER_API_KEY_SONIC=placeholder VERIFIER_URL_SONIC=https://api.sonicscan.org/api \
          FOUNDRY_PROFILE=core CONFIG=${{ steps.extract.outputs.CONFIG }} \
          EXTERNAL_PRICE_0=${{ steps.price.outputs.EXTERNAL_PRICE_0 }} EXTERNAL_PRICE_1=${{ steps.price.outputs.EXTERNAL_PRICE_1 }} \
          forge script silo-core/deploy/silo/VerifySilo.s.sol \
            --ffi --rpc-url "${{ steps.extract.outputs.RPC_URL }}" \
            -vvvv \
            > output.log 2>&1 || true

          echo '```' > result.txt
          echo "Time: $(date -u '+%Y-%m-%d %H:%M:%S') UTC" >> result.txt
          echo "Commit: ${{ github.sha }}" >> result.txt
          echo "EXTERNAL_PRICE_0=${{ steps.price.outputs.EXTERNAL_PRICE_0 }}" >> result.txt
          echo "EXTERNAL_PRICE_1=${{ steps.price.outputs.EXTERNAL_PRICE_1 }}" >> result.txt

          # extract everything from `== Logs ==` to the end
          awk '/== Logs ==/ { print_flag = 1 } print_flag' output.log >> result.txt
          echo '```' >> result.txt

      # Post result as a sticky comment on the PR
      - name: Comment result on PR
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: verify-silo
          path: result.txt

      - name: Run LIVE MARKET QA
        id: live-market-qa
        run: |
          echo "Running LIVE MARKET QA for ${{ steps.extract.outputs.CONFIG_NAME }} (${{ steps.extract.outputs.CONFIG }}) on ${{ steps.extract.outputs.CHAIN }}"
          
          # Run tests and capture exit code
          set +e  # Don't exit on error
          FOUNDRY_PROFILE=core_test CONFIG=${{ steps.extract.outputs.CONFIG }} \
          EXTERNAL_PRICE_0=${{ steps.price.outputs.EXTERNAL_PRICE_0 }} EXTERNAL_PRICE_1=${{ steps.price.outputs.EXTERNAL_PRICE_1 }} \
          RPC_URL=${{ steps.extract.outputs.RPC_URL }} \
          forge test --mc "NewMarketTest" --ffi -vv \
          > live_market_qa.log 2>&1
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Create result file
          echo '```' > live_market_qa_result.txt
          echo "LIVE MARKET QA Results" >> live_market_qa_result.txt
          echo "Time: $(date -u '+%Y-%m-%d %H:%M:%S') UTC" >> live_market_qa_result.txt
          echo "Commit: ${{ github.sha }}" >> live_market_qa_result.txt
          echo "Config: ${{ steps.extract.outputs.CONFIG_NAME }} (${{ steps.extract.outputs.CONFIG }})" >> live_market_qa_result.txt
          echo "Chain: ${{ steps.extract.outputs.CHAIN }}" >> live_market_qa_result.txt
          echo "EXTERNAL_PRICE_0=${{ steps.price.outputs.EXTERNAL_PRICE_0 }}" >> live_market_qa_result.txt
          echo "EXTERNAL_PRICE_1=${{ steps.price.outputs.EXTERNAL_PRICE_1 }}" >> live_market_qa_result.txt
          echo "" >> live_market_qa_result.txt
          
          # Add test results
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "✅ Tests PASSED" >> live_market_qa_result.txt
          else
            echo "❌ Tests FAILED (exit code: $TEST_EXIT_CODE)" >> live_market_qa_result.txt
          fi
          echo "" >> live_market_qa_result.txt
          
          cat live_market_qa.log >> live_market_qa_result.txt
          echo '```' >> live_market_qa_result.txt
          
          # Set output for next step
          echo "test_exit_code=$TEST_EXIT_CODE" >> $GITHUB_OUTPUT

      # Post LIVE MARKET QA result as a separate sticky comment on the PR
      - name: Comment LIVE MARKET QA result on PR
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: live-market-qa
          path: live_market_qa_result.txt
          
      # Fail the CI if tests failed
      - name: Check test results
        run: |
          if [ "${{ steps.live-market-qa.outputs.test_exit_code }}" != "0" ]; then
            echo "❌ LIVE MARKET QA tests failed with exit code ${{ steps.live-market-qa.outputs.test_exit_code }}"
            echo "Check the live-market-qa comment above for details"
            exit 1
          else
            echo "✅ LIVE MARKET QA tests passed"
          fi
  
        
