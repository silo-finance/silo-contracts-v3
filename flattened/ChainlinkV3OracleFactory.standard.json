{
  "language": "Solidity",
  "sources": {
    "silo-oracles/contracts/chainlinkV3/ChainlinkV3OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Clones} from \"openzeppelin5/proxy/Clones.sol\";\nimport {AggregatorV3Interface} from \"chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport {Create2Factory} from \"common/utils/Create2Factory.sol\";\nimport {OracleFactory} from \"../_common/OracleFactory.sol\";\nimport {IChainlinkV3Oracle} from \"../interfaces/IChainlinkV3Oracle.sol\";\nimport {ChainlinkV3Oracle} from \"../chainlinkV3/ChainlinkV3Oracle.sol\";\nimport {ChainlinkV3OracleConfig} from \"../chainlinkV3/ChainlinkV3OracleConfig.sol\";\nimport {OracleNormalization} from \"../lib/OracleNormalization.sol\";\n\ncontract ChainlinkV3OracleFactory is Create2Factory, OracleFactory {\n    constructor() OracleFactory(address(new ChainlinkV3Oracle())) {\n        // noting to configure\n    }\n\n    function create(\n        IChainlinkV3Oracle.ChainlinkV3DeploymentConfig memory _config,\n        bytes32 _externalSalt\n    ) external virtual returns (ChainlinkV3Oracle oracle) {\n        bytes32 id = hashConfig(_config);\n        ChainlinkV3OracleConfig oracleConfig = ChainlinkV3OracleConfig(getConfigAddress[id]);\n\n        if (address(oracleConfig) != address(0)) {\n            // config already exists, so oracle exists as well\n            return ChainlinkV3Oracle(getOracleAddress[address(oracleConfig)]);\n        }\n\n        verifyConfig(_config);\n\n        oracleConfig = new ChainlinkV3OracleConfig(_config);\n        oracle = ChainlinkV3Oracle(Clones.cloneDeterministic(ORACLE_IMPLEMENTATION, _salt(_externalSalt)));\n\n        _saveOracle(address(oracle), address(oracleConfig), id);\n\n        oracle.initialize(oracleConfig);\n    }\n\n    function hashConfig(IChainlinkV3Oracle.ChainlinkV3DeploymentConfig memory _config)\n        public\n        virtual\n        view\n        returns (bytes32 configId)\n    {\n        configId = keccak256(abi.encode(_config));\n    }\n\n    // solhint-disable-next-line code-complexity\n    function verifyConfig(IChainlinkV3Oracle.ChainlinkV3DeploymentConfig memory _config)\n        public\n        view\n        virtual\n        returns (uint256 secondaryPriceDecimals)\n    {\n        if (address(_config.quoteToken) == address(0)) revert IChainlinkV3Oracle.AddressZero();\n        if (address(_config.baseToken) == address(0)) revert IChainlinkV3Oracle.AddressZero();\n        if (address(_config.quoteToken) == address(_config.baseToken)) revert IChainlinkV3Oracle.TokensAreTheSame();\n\n        if (address(_config.primaryAggregator) == address(0)) revert IChainlinkV3Oracle.AddressZero();\n\n        if (address(_config.primaryAggregator) == address(_config.secondaryAggregator)) {\n            revert IChainlinkV3Oracle.AggregatorsAreTheSame();\n        }\n\n        if (address(_config.secondaryAggregator) != address(0)) {\n            secondaryPriceDecimals = _config.secondaryAggregator.decimals();\n        }\n\n        if (_config.normalizationDivider > 1e36) revert IChainlinkV3Oracle.HugeDivider();\n        if (_config.normalizationMultiplier > 1e36) revert IChainlinkV3Oracle.HugeMultiplier();\n\n        if (_config.normalizationDivider == 0 && _config.normalizationMultiplier == 0) {\n            revert IChainlinkV3Oracle.MultiplierAndDividerZero();\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "gitmodules/chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "common/utils/Create2Factory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Nonces} from \"openzeppelin5/utils/Nonces.sol\";\n\ncontract Create2Factory is Nonces {\n    function _salt() internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender)\n        ));\n    }\n\n    function _salt(bytes32 _externalSalt) internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender),\n            _externalSalt\n        ));\n    }\n\n    function _createSalt(address _deployer, bytes32 _externalSalt) internal view returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            _deployer,\n            nonces(_deployer),\n            _externalSalt\n        ));\n    }\n}\n"
    },
    "silo-oracles/contracts/_common/OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n\nabstract contract OracleFactory {\n    /// @dev implementation that will be cloned\n    address public immutable ORACLE_IMPLEMENTATION; // solhint-disable-line var-name-mixedcase\n\n    /// @dev hash(config) => oracle config contract\n    /// oracle ID is determine by initial configuration, the logic is the same, so config is the only difference\n    /// that's why we can use it as ID, at the same time we can detect duplicates and save gas by reusing same config\n    /// multiple times\n    mapping(bytes32 => address) public getConfigAddress;\n\n    /// @dev config address => oracle address\n    mapping(address => address) public getOracleAddress;\n\n    /// @dev config ID and config address should be easily accessible directly from oracle contract\n    event NewOracle(address indexed oracle);\n\n    constructor(address _oracleImplementation) {\n        if (_oracleImplementation == address(0)) revert(\"ZeroAddress\");\n\n        ORACLE_IMPLEMENTATION = _oracleImplementation;\n    }\n\n    /// @dev execute this method from target factory, to save ID and update mappings\n    /// @param _newOracle new oracle address\n    /// @param _newConfig oracle config address\n    /// @param _configId oracle config ID, hash(config)\n    function _saveOracle(address _newOracle, address _newConfig, bytes32 _configId) internal virtual {\n        if (getConfigAddress[_configId] != address(0)) revert(\"ConfigAlreadyExist\");\n\n        getConfigAddress[_configId] = _newConfig;\n        // config and oracle is 1:1 so no need to check if oracle exists\n        getOracleAddress[_newConfig] = _newOracle;\n\n        emit NewOracle(_newOracle);\n    }\n}\n"
    },
    "silo-oracles/contracts/interfaces/IChainlinkV3Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {AggregatorV3Interface} from \"chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {ChainlinkV3OracleConfig} from \"../chainlinkV3/ChainlinkV3OracleConfig.sol\";\n\ninterface IChainlinkV3Oracle {\n    /// @dev config based on which new oracle will be deployed\n    /// @notice there is no way to check if aggregators match tokens, so it is users job to verify config.\n    /// @param primaryAggregator used to read price from chainlink, if it can not provide price in quote token,\n    /// then you have to setup secondary one that will do the job\n    /// @param secondaryAggregator if set, it is used translate primary price into quote price eg:\n    /// primary price is ABC/USD and secondary is ETH/USD, then result will be price in ABC/ETH\n    /// @param baseToken base token address, it must have decimals() method available\n    /// @param quoteToken quote toke address, it must have decimals() method available\n    /// @param primaryHeartbeat heartbeat of primary price\n    /// @param secondaryHeartbeat heartbeat of secondary price\n    /// @param normalizationDivider divider that will be used in oracle to normalize price\n    /// @param normalizationMultiplier multiplier that will be used in oracle to normalize price\n    /// @param invertSecondPrice in case we using second price, this flag will tell us if we need to 1/secondPrice\n    struct ChainlinkV3DeploymentConfig {\n        IERC20Metadata baseToken;\n        IERC20Metadata quoteToken;\n        AggregatorV3Interface primaryAggregator;\n        uint32 primaryHeartbeat;\n        AggregatorV3Interface secondaryAggregator;\n        uint32 secondaryHeartbeat;\n        uint256 normalizationDivider;\n        uint256 normalizationMultiplier;\n        bool invertSecondPrice;\n    }\n\n    /// @dev config based on which new oracle will be deployed\n    /// @notice there is no way to check if aggregators match tokens, so it is users job to verify config.\n    /// @param primaryAggregator used to read price from chainlink, if it can not provide price in quote token,\n    /// then you have to setup secondary one that will do the job\n    /// @param secondaryAggregator if set, it is used translate primary price into quote price eg:\n    /// primary price is ABC/USD and secondary is ETH/USD, then result will be price in ABC/ETH\n    /// @param baseToken base token address, it must have decimals() method available\n    /// @param quoteToken quote toke address, it must have decimals() method available\n    /// @param primaryHeartbeat heartbeat of primary price\n    /// @param secondaryHeartbeat heartbeat of secondary price\n    /// @param invertSecondPrice in case we using second price, this flag will tell us if we need to 1/secondPrice\n    struct ChainlinkV3Config {\n        AggregatorV3Interface primaryAggregator;\n        AggregatorV3Interface secondaryAggregator;\n        uint256 primaryHeartbeat;\n        uint256 secondaryHeartbeat;\n        uint256 normalizationDivider;\n        uint256 normalizationMultiplier;\n        IERC20Metadata baseToken;\n        IERC20Metadata quoteToken;\n        bool convertToQuote;\n        bool invertSecondPrice;\n    }\n\n    event ChainlinkV3ConfigDeployed(ChainlinkV3OracleConfig configAddress);\n\n    event NewAggregator(address indexed asset, AggregatorV3Interface indexed aggregator, bool convertToQuote);\n    event NewHeartbeat(address indexed asset, uint256 heartbeat);\n    event NewQuoteAggregatorHeartbeat(uint256 heartbeat);\n    event AggregatorDisabled(address indexed asset, AggregatorV3Interface indexed aggregator);\n\n    error AddressZero();\n    error InvalidPrice();\n    error ZeroQuote();\n    error InvalidSecondPrice();\n    error BaseAmountOverflow();\n    error TokensAreTheSame();\n    error AggregatorsAreTheSame();\n\n    error QuoteTokenNotMatchEth();\n    error InvalidEthAggregatorDecimals();\n\n    error AssetNotSupported();\n    error HugeDivider();\n    error HugeMultiplier();\n    error MultiplierAndDividerZero();\n}\n"
    },
    "silo-oracles/contracts/chainlinkV3/ChainlinkV3Oracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {Initializable} from  \"openzeppelin5-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {AggregatorV3Interface} from \"chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {ISiloOracle} from \"silo-core/contracts/interfaces/ISiloOracle.sol\";\n\nimport {OracleNormalization} from \"../lib/OracleNormalization.sol\";\nimport {ChainlinkV3OracleConfig} from \"./ChainlinkV3OracleConfig.sol\";\nimport {IChainlinkV3Oracle} from \"../interfaces/IChainlinkV3Oracle.sol\";\n\ncontract ChainlinkV3Oracle is IChainlinkV3Oracle, ISiloOracle, Initializable {\n    ChainlinkV3OracleConfig public oracleConfig;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice validation of config is checked in factory, therefore you should not deploy and initialize directly\n    /// use factory always.\n    function initialize(ChainlinkV3OracleConfig _configAddress) external virtual initializer {\n        oracleConfig = _configAddress;\n        emit ChainlinkV3ConfigDeployed(_configAddress);\n    }\n\n    /// @inheritdoc ISiloOracle\n    // solhint-disable-next-line code-complexity\n    function quote(uint256 _baseAmount, address _baseToken) external view virtual returns (uint256 quoteAmount) {\n        ChainlinkV3Config memory config = oracleConfig.getConfig();\n\n        if (_baseToken != address(config.baseToken)) revert AssetNotSupported();\n        if (_baseAmount > type(uint128).max) revert BaseAmountOverflow();\n\n        (bool success, uint256 price) = _getAggregatorPrice(config.primaryAggregator, config.primaryHeartbeat);\n        if (!success) revert InvalidPrice();\n\n        if (!config.convertToQuote) {\n            quoteAmount = OracleNormalization.normalizePrice(\n                _baseAmount, price, config.normalizationDivider, config.normalizationMultiplier\n            );\n\n            if (quoteAmount == 0) revert ZeroQuote();\n            return quoteAmount;\n        }\n\n        (\n            bool secondSuccess,\n            uint256 secondPrice\n        ) = _getAggregatorPrice(config.secondaryAggregator, config.secondaryHeartbeat);\n\n        if (!secondSuccess) revert InvalidSecondPrice();\n\n        quoteAmount = OracleNormalization.normalizePrices(\n            _baseAmount,\n            price,\n            secondPrice,\n            config.normalizationDivider,\n            config.normalizationMultiplier,\n            config.invertSecondPrice\n        );\n\n        if (quoteAmount == 0) revert ZeroQuote();\n        return quoteAmount;\n    }\n\n    /// @dev Returns price directly from aggregator, this method is mostly for debug purposes\n    function getAggregatorPrice(bool _primary) external view virtual returns (bool success, uint256 price) {\n        IChainlinkV3Oracle.ChainlinkV3Config memory config = oracleConfig.getConfig();\n\n        return _primary\n            ? _getAggregatorPrice(config.primaryAggregator, config.primaryHeartbeat)\n            : _getAggregatorPrice(config.secondaryAggregator, config.secondaryHeartbeat);\n    }\n\n    /// @inheritdoc ISiloOracle\n    function quoteToken() external view virtual returns (address) {\n        IChainlinkV3Oracle.ChainlinkV3Config memory config = oracleConfig.getConfig();\n        return address(config.quoteToken);\n    }\n\n    function beforeQuote(address) external pure virtual override {\n        // nothing to execute\n    }\n\n    function _getAggregatorPrice(AggregatorV3Interface _aggregator, uint256 /* _heartbeat */)\n        internal\n        view\n        virtual\n        returns (bool success, uint256 price)\n    {\n        (\n            /*uint80 roundID*/,\n            int256 aggregatorPrice,\n            /*uint256 startedAt*/,\n            /* uint256 priceTimestamp */,\n            /*uint80 answeredInRound*/\n        ) = _aggregator.latestRoundData();\n\n        if (aggregatorPrice > 0) {\n            return (true, uint256(aggregatorPrice));\n        }\n\n        return (false, 0);\n    }\n}\n"
    },
    "silo-oracles/contracts/chainlinkV3/ChainlinkV3OracleConfig.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {AggregatorV3Interface} from \"chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {ISiloOracle} from \"silo-core/contracts/interfaces/ISiloOracle.sol\";\nimport {IChainlinkV3Oracle} from \"../interfaces/IChainlinkV3Oracle.sol\";\nimport {Layer1OracleConfig} from \"../_common/Layer1OracleConfig.sol\";\n\ncontract ChainlinkV3OracleConfig is Layer1OracleConfig {\n    /// @dev Chainlink aggregator\n    AggregatorV3Interface internal immutable _AGGREGATOR; // solhint-disable-line var-name-mixedcase\n\n    /// @dev secondary Chainlink aggregator to convert price to quote\n    AggregatorV3Interface internal immutable _SECONDARY_AGGREGATOR; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Threshold used to determine if the price returned by the _SECONDARY_AGGREGATOR is valid\n    uint256 internal immutable _SECONDARY_HEARTBEAT; // solhint-disable-line var-name-mixedcase\n\n    /// @dev this can be set to true to convert primary price into price denominated in quote\n    /// assuming that both AGGREGATORS providing price in the same token\n    bool internal immutable _CONVERT_TO_QUOTE; // solhint-disable-line var-name-mixedcase\n\n    /// @dev If TRUE price will be 1/price\n    bool internal immutable _INVERT_SECONDARY_PRICE; // solhint-disable-line var-name-mixedcase\n\n    /// @dev all verification should be done by factory\n    constructor(IChainlinkV3Oracle.ChainlinkV3DeploymentConfig memory _config)\n        Layer1OracleConfig(\n            _config.baseToken,\n            _config.quoteToken,\n            _config.primaryHeartbeat,\n            _config.normalizationDivider,\n            _config.normalizationMultiplier\n        )\n    {\n        _AGGREGATOR = _config.primaryAggregator;\n        _SECONDARY_AGGREGATOR = _config.secondaryAggregator;\n        _SECONDARY_HEARTBEAT = _config.secondaryHeartbeat;\n        _CONVERT_TO_QUOTE = address(_config.secondaryAggregator) != address(0);\n        _INVERT_SECONDARY_PRICE = _config.invertSecondPrice;\n    }\n\n    function getConfig() external view virtual returns (IChainlinkV3Oracle.ChainlinkV3Config memory config) {\n        config.primaryAggregator = _AGGREGATOR;\n        config.secondaryAggregator = _SECONDARY_AGGREGATOR;\n        config.primaryHeartbeat = _HEARTBEAT;\n        config.secondaryHeartbeat = _SECONDARY_HEARTBEAT;\n        config.normalizationDivider = _DECIMALS_NORMALIZATION_DIVIDER;\n        config.normalizationMultiplier = _DECIMALS_NORMALIZATION_MULTIPLIER;\n        config.baseToken = _BASE_TOKEN;\n        config.quoteToken = _QUOTE_TOKEN;\n        config.convertToQuote = _CONVERT_TO_QUOTE;\n        config.invertSecondPrice = _INVERT_SECONDARY_PRICE;\n    }\n}\n"
    },
    "silo-oracles/contracts/lib/OracleNormalization.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {TokenHelper} from \"silo-core/contracts/lib/TokenHelper.sol\";\n\n/// @notice please read carefully unchecked comments, there are some requirements tht must be met in order to not\n/// over/under flow\n/// @dev Rounding error policy.\n/// We're always rounding down by using build-in solidity way for division.\n///\n/// During normalization we're executing division by `_normalizationDivider` (unless there is multiplicator)\n/// and `_secondPrice` (in case second price exist). You can expect rounding errors to be in exclusive range of (0, 1)\n/// when doing division. What does it means? This means, that you can be short by up to 1 wei on result.\n/// eg. when normalising 12_345 (value with 3 decimals) to 2 decimals representation you lose last digit and end result\n/// will be 12_34.\n/// What are consequences for protocol?\n/// Eg. if 987 of tokens A is worth 12.34 tokens B (after normalization), by losing 0.005 we made tokens A worth a bit\n/// more than they really are. If we would round up, then tokens A would be a bit less expensive.\n/// Keep in mind we are talking tiny values. There is no argument that can tell which approach is correct.\n/// Considering that prices themselves are changing constantly (if you think about it, they are just random numbers\n/// close to previous value) and even TWAP price can be manipulated up to some level, if we compare this to rounding\n/// error, the rounding error has no meaning at all.\n/// Most important part is: how are we using prices in Silo and how rounding error affects the system?\n/// We're using prices to calculate LTV. We're deciding how much of token you can borrow but once you borrow you need to\n/// repay that amount (plus interest). Price of the token has no influence on how much you repay.\n/// Price change by 1 wei can also trigger liquidation, but it will be like switching from eg. 9,99999999999% => 10%.\n/// Summing up, rounding error can affect:\n/// - max amount of tokens one can borrow\n/// - when liquidation happen\n/// nn both cases we are talking about 1 wei of difference and this really does not matter to the protocol.\n/// It cannot make user to repay less than he borrow and it cannot affect any other operations like deposit,\n/// withdraw in a way, that you get less/more tokens.\n/// That said, choosing rounding policy is arbitrary decision and our decision is to use default rounding down.\nlibrary OracleNormalization {\n    error Overflow();\n\n    /// @notice if you call normalizePrice directly you can create overflow\n    /// @param _baseAmount amount of base token (can not be higher than uint128!)\n    /// @param _assetPrice price returned by oracle (can not be higher than uint128!)\n    /// @param _normalizationDivider constant that allows to translate output price to expected decimals\n    /// @param _normalizationMultiplier constant that allows to translate output price to expected decimals\n    /// @return assetPrice uint256 18 decimals price\n    function normalizePrice(\n        uint256 _baseAmount,\n        uint256 _assetPrice,\n        uint256 _normalizationDivider,\n        uint256 _normalizationMultiplier\n    )\n        internal\n        pure\n        returns (uint256 assetPrice)\n    {\n        if (_normalizationMultiplier == 0) {\n            // `_baseAmount * _assetPrice` is safe because we multiply uint128 * uint128\n            // - _baseAmount is checked in `_quote`\n            // - _assetPrice is uint128\n            // div is safe\n            unchecked { return _baseAmount * _assetPrice / _normalizationDivider; }\n        }\n\n        uint256 mul;\n        // this is save, check explanation above\n        unchecked { mul = _baseAmount * _assetPrice; }\n\n        return mul * _normalizationMultiplier;\n    }\n\n    /// @notice if you call normalizePrice directly you can create overflow\n    /// @param _baseAmount amount of base token (can not be higher than uint128!)\n    /// @param _assetPrice price returned by oracle (can not be higher than uint128!)\n    /// @param _secondPrice price of quote token denominated in same token as _assetPrice\n    /// (can not be higher than uint128!)\n    /// @param _normalizationDivider constant that allows to translate output price to expected decimals\n    /// @param _normalizationMultiplier constant that allows to translate output price to expected decimals\n    /// @param _invertSecondPrice if TRUE we have to 1/secondPrice\n    /// @return assetPrice uint256 18 decimals price\n    function normalizePrices(\n        uint256 _baseAmount,\n        uint256 _assetPrice,\n        uint256 _secondPrice,\n        uint256 _normalizationDivider,\n        uint256 _normalizationMultiplier,\n        bool _invertSecondPrice\n    )\n        internal\n        pure\n        returns (uint256 assetPrice)\n    {\n        // `_baseAmount * _assetPrice` is safe because we multiply uint128 * uint128\n        // - _baseAmount is checked in `_quote`, that checks covers `*1e8`, so we sure it is up to uint128\n        // - _assetPrice is uint128\n        // however if you call normalizePrice directly (because it is open method) you can create overflow\n        unchecked { assetPrice = _baseAmount * _assetPrice; }\n\n        if (_normalizationMultiplier == 0) {\n            assetPrice = _invertSecondPrice ? assetPrice / _secondPrice : assetPrice * _secondPrice;\n            // div is safe\n            unchecked {    assetPrice = assetPrice / _normalizationDivider; }\n            return assetPrice;\n        }\n\n        assetPrice = assetPrice * _normalizationMultiplier;\n        return _invertSecondPrice ? assetPrice / _secondPrice : assetPrice * _secondPrice;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ISiloOracle {\n    /// @notice Hook function to call before `quote` function reads price\n    /// @dev This hook function can be used to change state right before the price is read. For example it can be used\n    ///      for curve read only reentrancy protection. In majority of implementations this will be an empty function.\n    ///      WARNING: reverts are propagated to Silo so if `beforeQuote` reverts, Silo reverts as well.\n    /// @param _baseToken Address of priced token\n    function beforeQuote(address _baseToken) external;\n\n    /// @return quoteAmount Returns quote price for _baseAmount of _baseToken\n    /// @param _baseAmount Amount of priced token\n    /// @param _baseToken Address of priced token\n    function quote(uint256 _baseAmount, address _baseToken) external view returns (uint256 quoteAmount);\n\n    /// @return address of token in which quote (price) is denominated\n    function quoteToken() external view returns (address);\n}\n"
    },
    "silo-oracles/contracts/_common/Layer1OracleConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @notice to keep config contract size low (this is the one that will be deployed each time)\n/// factory contract take over verification. You should not deploy or use config that was not created by factory.\n/// @dev This is common config for Layer1 oracles\nabstract contract Layer1OracleConfig {\n    /// @dev price must be updated at least once every `_HEARTBEAT` seconds, otherwise something is wrong\n    uint256 internal immutable _HEARTBEAT; // solhint-disable-line var-name-mixedcase\n\n    /// @dev constant used for normalising price\n    uint256 internal immutable _DECIMALS_NORMALIZATION_DIVIDER; // solhint-disable-line var-name-mixedcase\n\n    /// @dev constant used for normalising price\n    uint256 internal immutable _DECIMALS_NORMALIZATION_MULTIPLIER; // solhint-disable-line var-name-mixedcase\n\n    IERC20Metadata internal immutable _BASE_TOKEN; // solhint-disable-line var-name-mixedcase\n    IERC20Metadata internal immutable _QUOTE_TOKEN; // solhint-disable-line var-name-mixedcase\n\n    /// @dev all verification should be done by factory\n    constructor(\n        IERC20Metadata _baseToken,\n        IERC20Metadata _quoteToken,\n        uint256 _heartbeat,\n        uint256 _normalizationDivider,\n        uint256 _normalizationMultiplier\n    ) {\n        _DECIMALS_NORMALIZATION_DIVIDER = _normalizationDivider;\n        _DECIMALS_NORMALIZATION_MULTIPLIER = _normalizationMultiplier;\n\n        _BASE_TOKEN = _baseToken;\n        _QUOTE_TOKEN = _quoteToken;\n\n        _HEARTBEAT = _heartbeat;\n    }\n}\n"
    },
    "silo-core/contracts/lib/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IsContract} from \"./IsContract.sol\";\n\nlibrary TokenHelper {\n    uint256 private constant _BYTES32_SIZE = 32;\n\n    error TokenIsNotAContract();\n\n    function assertAndGetDecimals(address _token) internal view returns (uint256) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.decimals, ()));\n\n        // decimals() is optional in the ERC20 standard, so if metadata is not accessible\n        // we assume there are no decimals and use 0.\n        if (!hasMetadata) {\n            return 0;\n        }\n\n        return abi.decode(data, (uint8));\n    }\n\n    /// @dev Returns the symbol for the provided ERC20 token.\n    /// An empty string is returned if the call to the token didn't succeed.\n    /// @param _token address of the token to get the symbol for\n    /// @return assetSymbol the token symbol\n    function symbol(address _token) internal view returns (string memory assetSymbol) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.symbol, ()));\n\n        if (!hasMetadata || data.length == 0) {\n            return \"?\";\n        } else if (data.length == _BYTES32_SIZE) {\n            return string(removeZeros(data));\n        } else {\n            return abi.decode(data, (string));\n        }\n    }\n\n    /// @dev Removes bytes with value equal to 0 from the provided byte array.\n    /// @param _data byte array from which to remove zeroes\n    /// @return result byte array with zeroes removed\n    function removeZeros(bytes memory _data) internal pure returns (bytes memory result) {\n        uint256 n = _data.length;\n\n        for (uint256 i; i < n; i++) {\n            if (_data[i] == 0) continue;\n\n            result = abi.encodePacked(result, _data[i]);\n        }\n    }\n\n    /// @dev Performs a staticcall to the token to get its metadata (symbol, decimals, name)\n    function _tokenMetadataCall(address _token, bytes memory _data) private view returns (bool, bytes memory) {\n        // We need to do this before the call, otherwise the call will succeed even for EOAs\n        require(IsContract.isContract(_token), TokenIsNotAContract());\n\n        (bool success, bytes memory result) = _token.staticcall(_data);\n\n        // If the call reverted we assume the token doesn't follow the metadata extension\n        if (!success) {\n            return (false, \"\");\n        }\n\n        return (true, result);\n    }\n}\n"
    },
    "silo-core/contracts/lib/IsContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nlibrary IsContract {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address _account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return _account.code.length > 0;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=gitmodules/forge-std/src/",
      "silo-foundry-utils/=gitmodules/silo-foundry-utils/contracts/",
      "properties/=gitmodules/crytic/properties/contracts/",
      "silo-core/=silo-core/",
      "silo-oracles/=silo-oracles/",
      "silo-vaults/=silo-vaults/",
      "@openzeppelin/=gitmodules/openzeppelin-contracts-5/",
      "morpho-blue/=gitmodules/morpho-blue/src/",
      "openzeppelin5/=gitmodules/openzeppelin-contracts-5/contracts/",
      "openzeppelin5-upgradeable/=gitmodules/openzeppelin-contracts-upgradeable-5/contracts/",
      "chainlink/=gitmodules/chainlink/contracts/src/",
      "chainlink-ccip/=gitmodules/chainlink-ccip/contracts/src/",
      "uniswap/=gitmodules/uniswap/",
      "@uniswap/v3-core/=gitmodules/uniswap/v3-core/",
      "pyth-sdk-solidity/=gitmodules/pyth-sdk-solidity/target_chains/ethereum/sdk/solidity/",
      "a16z-erc4626-tests/=gitmodules/a16z-erc4626-tests/",
      "@ensdomains/=node_modules/@ensdomains/",
      "@solidity-parser/=node_modules/prettier-plugin-solidity/node_modules/@solidity-parser/",
      "ERC4626/=gitmodules/crytic/properties/lib/ERC4626/contracts/",
      "createx/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/src/",
      "crytic/=gitmodules/crytic/",
      "ds-test/=gitmodules/openzeppelin-contracts-5/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=gitmodules/openzeppelin-contracts-5/lib/erc4626-tests/",
      "halmos-cheatcodes/=gitmodules/morpho-blue/lib/halmos-cheatcodes/src/",
      "hardhat/=node_modules/hardhat/",
      "openzeppelin-contracts-5/=gitmodules/openzeppelin-contracts-5/",
      "openzeppelin-contracts-upgradeable-5/=gitmodules/openzeppelin-contracts-upgradeable-5/",
      "openzeppelin-contracts-upgradeable/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/",
      "prettier-plugin-solidity/=node_modules/prettier-plugin-solidity/",
      "solady/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/lib/solady/",
      "solmate/=gitmodules/crytic/properties/lib/solmate/src/",
      "x-silo/=node_modules/x-silo/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false
  }
}