{
  "language": "Solidity",
  "sources": {
    "silo-core/contracts/interestRateModel/kink/DynamicKinkModelFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Clones} from \"openzeppelin5/proxy/Clones.sol\";\nimport {SafeCast} from \"openzeppelin5/utils/math/SafeCast.sol\";\n\nimport {Create2Factory} from \"common/utils/Create2Factory.sol\";\n\nimport {IInterestRateModel} from \"../../interfaces/IInterestRateModel.sol\";\nimport {IDynamicKinkModel} from \"../../interfaces/IDynamicKinkModel.sol\";\nimport {IDynamicKinkModelFactory} from \"../../interfaces/IDynamicKinkModelFactory.sol\";\n\nimport {DynamicKinkModel} from \"./DynamicKinkModel.sol\";\nimport {KinkMath} from \"../../lib/KinkMath.sol\";\n\ncontract DynamicKinkModelFactory is Create2Factory, IDynamicKinkModelFactory {\n    using KinkMath for int256;\n\n    /// @dev DP in 18 decimal points used for integer calculations\n    int256 public constant DP = int256(1e18);\n\n    /// @dev seconds per year used in interest calculations.\n    int256 public constant ONE_YEAR = 365 days;\n\n    /// @dev IRM contract implementation address to clone\n    DynamicKinkModel public immutable IRM;\n\n    mapping(address irm => bool) public createdByFactory;\n\n    constructor(DynamicKinkModel _implementation) {\n        IRM = _implementation;\n    }\n\n    /// @inheritdoc IDynamicKinkModelFactory\n    function create(\n        IDynamicKinkModel.Config calldata _config,\n        IDynamicKinkModel.ImmutableArgs calldata _immutableArgs,\n        address _initialOwner,\n        address _silo,\n        bytes32 _externalSalt\n    )\n        external\n        virtual\n        returns (IInterestRateModel irm)\n    {\n        return IInterestRateModel(address(_create(_config, _immutableArgs, _initialOwner, _silo, _externalSalt)));\n    }\n\n    /// @inheritdoc IDynamicKinkModelFactory\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function generateConfig(IDynamicKinkModel.UserFriendlyConfig calldata _default)\n        external\n        view\n        virtual\n        returns (IDynamicKinkModel.Config memory config)\n    {\n        IDynamicKinkModel.UserFriendlyConfigInt memory defaultInt = _castConfig(_default);\n\n        // 0 <= ulow < u1 < u2 < ucrit < DP\n        require(defaultInt.u1.inOpenInterval(defaultInt.ulow, defaultInt.u2), IDynamicKinkModel.InvalidU1());\n        require(defaultInt.u2.inOpenInterval(defaultInt.u1, defaultInt.ucrit), IDynamicKinkModel.InvalidU2());\n        require(defaultInt.ucrit.inOpenInterval(defaultInt.u2, DP), IDynamicKinkModel.InvalidUcrit());\n\n        config.ulow = defaultInt.ulow;\n        config.u1 = defaultInt.u1;\n        config.u2 = defaultInt.u2;\n        config.ucrit = defaultInt.ucrit;\n\n        // 0 <= rmin < rcritMin <= rcritMax < r100\n\n        require(\n            defaultInt.rcritMin.inOpenIntervalTopIncluded(defaultInt.rmin, defaultInt.rcritMax),\n            IDynamicKinkModel.InvalidRcritMin()\n        );\n\n        require(\n            defaultInt.rcritMax.inOpenIntervalLowIncluded(defaultInt.rcritMin, defaultInt.r100),\n            IDynamicKinkModel.InvalidRcritMax()\n        );\n\n        int256 s = 365 days;\n\n        // 0 < tMin <= tcrit <= t2 < 100y\n        require(defaultInt.tMin != 0, IDynamicKinkModel.InvalidTMin());\n        require(defaultInt.tcrit.inClosedInterval(defaultInt.tMin, defaultInt.t2), IDynamicKinkModel.InvalidTCrit());\n        require(defaultInt.t2.inOpenIntervalLowIncluded(defaultInt.tcrit, 100 * s), IDynamicKinkModel.InvalidT2());\n\n        // 0 < tlow <= t1 < 100y\n        require(defaultInt.tlow != 0, IDynamicKinkModel.InvalidTLow());\n        require(defaultInt.t1.inOpenIntervalLowIncluded(defaultInt.tlow, 100 * s), IDynamicKinkModel.InvalidT1());\n\n        // r check is move to the last, so it will be easier to detect issues with scallar values\n        int256 rCheckHi = (defaultInt.r100 - defaultInt.rmin) * DP / (defaultInt.rcritMax - defaultInt.rmin);\n        int256 rCheckLo = (DP - defaultInt.ulow) * DP / (defaultInt.ucrit - defaultInt.ulow);\n        require(rCheckHi >= rCheckLo, IDynamicKinkModel.InvalidDefaultConfig());\n\n        config.rmin = defaultInt.rmin / s;\n\n        config.kmin =\n            SafeCast.toInt96((defaultInt.rcritMin - defaultInt.rmin) * DP / (defaultInt.ucrit - defaultInt.ulow) / s);\n\n        config.kmax =\n            SafeCast.toInt96((defaultInt.rcritMax - defaultInt.rmin) * DP / (defaultInt.ucrit - defaultInt.ulow) / s);\n\n        config.alpha =\n            (rCheckHi * (defaultInt.ucrit - defaultInt.ulow) - (DP - defaultInt.ulow) * DP) / (DP - defaultInt.ucrit);\n\n        config.c1 = (config.kmax - config.kmin) * DP / defaultInt.t1;\n        config.c2 = (config.kmax - config.kmin) * DP / defaultInt.t2;\n\n        config.cminus =\n            ((config.kmax - config.kmin) * DP / defaultInt.tlow - config.c1) / (defaultInt.u1 - defaultInt.ulow);\n\n        config.cplus =\n            ((config.kmax - config.kmin) * DP / defaultInt.tcrit - config.c2) / (defaultInt.ucrit - defaultInt.u2);\n\n        config.c1 /= DP;\n        config.c2 /= DP;\n\n        config.dmax = (config.kmax - config.kmin) / defaultInt.tMin;\n\n        IDynamicKinkModel(address(IRM)).verifyConfig(config);\n    }\n\n    /// @inheritdoc IDynamicKinkModelFactory\n    function verifyConfig(IDynamicKinkModel.Config calldata _config) external view virtual {\n        IRM.verifyConfig(_config);\n    }\n\n    function predictAddress(address _deployer, bytes32 _externalSalt)\n        external\n        view\n        returns (address predictedAddress)\n    {\n        require(_deployer != address(0), DeployerCannotBeZero());\n\n        predictedAddress = Clones.predictDeterministicAddress(address(IRM), _createSalt(_deployer, _externalSalt));\n    }\n\n    function _create(\n        IDynamicKinkModel.Config memory _config,\n        IDynamicKinkModel.ImmutableArgs memory _immutableArgs,\n        address _initialOwner,\n        address _silo,\n        bytes32 _externalSalt\n    )\n        internal\n        virtual\n        returns (IDynamicKinkModel irm)\n    {\n        IRM.verifyConfig(_config);\n\n        bytes32 salt = _salt(_externalSalt);\n\n        irm = IDynamicKinkModel(Clones.cloneDeterministic(address(IRM), salt));\n        irm.initialize(_config, _immutableArgs, _initialOwner, _silo);\n\n        createdByFactory[address(irm)] = true;\n        emit NewDynamicKinkModel(irm);\n    }\n\n    function _castConfig(IDynamicKinkModel.UserFriendlyConfig calldata _default)\n        internal\n        pure\n        returns (IDynamicKinkModel.UserFriendlyConfigInt memory config)\n    {\n        config.ulow = SafeCast.toInt256(_default.ulow);\n        config.u1 = SafeCast.toInt256(_default.u1);\n        config.u2 = SafeCast.toInt256(_default.u2);\n        config.ucrit = SafeCast.toInt256(_default.ucrit);\n        config.rmin = SafeCast.toInt256(_default.rmin);\n        config.rcritMin = SafeCast.toInt256(_default.rcritMin);\n        config.rcritMax = SafeCast.toInt256(_default.rcritMax);\n        config.r100 = SafeCast.toInt256(_default.r100);\n        config.t1 = SafeCast.toInt256(_default.t1);\n        config.t2 = SafeCast.toInt256(_default.t2);\n        config.tlow = SafeCast.toInt256(_default.tlow);\n        config.tcrit = SafeCast.toInt256(_default.tcrit);\n        config.tMin = SafeCast.toInt256(_default.tMin);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "common/utils/Create2Factory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Nonces} from \"openzeppelin5/utils/Nonces.sol\";\n\ncontract Create2Factory is Nonces {\n    function _salt() internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender)\n        ));\n    }\n\n    function _salt(bytes32 _externalSalt) internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender),\n            _externalSalt\n        ));\n    }\n\n    function _createSalt(address _deployer, bytes32 _externalSalt) internal view returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            _deployer,\n            nonces(_deployer),\n            _externalSalt\n        ));\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IInterestRateModel {\n    event InterestRateModelError();\n\n    /// @dev Sets config address for all Silos that will use this model\n    /// @param _irmConfig address of IRM config contract\n    function initialize(address _irmConfig) external;\n\n    /// @dev get compound interest rate and update model storage for current block.timestamp\n    /// @param _collateralAssets total silo collateral assets\n    /// @param _debtAssets total silo debt assets\n    /// @param _interestRateTimestamp last IRM timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRateAndUpdate(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _interestRateTimestamp\n    )\n        external\n        returns (uint256 rcomp);\n\n    /// @dev get compound interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcomp);\n\n    /// @dev get current annual interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function getCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcur);\n\n    /// @dev returns decimal points used by model\n    function decimals() external view returns (uint256);\n}\n"
    },
    "silo-core/contracts/interfaces/IDynamicKinkModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IDynamicKinkModelConfig} from \"./IDynamicKinkModelConfig.sol\";\n\n/// @title IDynamicKinkModel\n/// @notice Interface for the Dynamic Kink Interest Rate Model\n/// @dev This interface defines an adaptive interest rate model that dynamically adjusts rates based on market\n///      utilization.\n///      The model uses a \"kink\" mechanism where interest rates change more aggressively as utilization increases.\n///      Unlike static models, this implementation adapts over time to market conditions.\n/// \n///      Key Features:\n///      - Dynamic rate adjustment based on utilization thresholds\n///      - Time-based rate evolution to prevent sudden spikes\n///      - Configurable parameters for different market conditions\n///      - Compound interest calculation for accurate accrual\n/// \n///      The model operates with several utilization zones:\n///      - Low utilization (0 to ulow): Minimal rates to encourage borrowing\n///      - Optimal range (u1 to u2): Stable rates for normal operations  \n///      - High utilization (u2 to ucrit): Increasing rates to manage risk\n///      - Critical utilization (ucrit to 1e18): Maximum rates\ninterface IDynamicKinkModel {\n    /// @notice User-friendly configuration structure for setting up the Dynamic Kink Model\n    /// @dev This structure provides intuitive parameters that are converted to internal model parameters.\n    ///      All utilization values are in 18 decimals (e.g., 0.5e18 = 50% utilization).\n    ///      All time values are in seconds.\n    /// \n    /// @param ulow Utilization threshold below which rates are minimal\n    /// @param ucrit Critical utilization threshold where rates become very high\n    /// @param u1 lower bound of optimal utilization range (the model is static when utilization is in this interval).\n    /// @param u2 upper bound of optimal utilization range (the model is static when utilization is in this interval).\n    /// @param rmin Minimal per-second interest rate (minimal APR), active below ulow.\n    /// @param rcritMin Minimal APR that the model can output at the critical utilization ucrit\n    /// @param rcritMax Maximal APR that the model can output at the critical utilization ucrit\n    /// @param r100 Maximum possible per-second rate at 100% utilization\n    /// @param t1 Time in seconds for rate to decrease from max to min at u1 utilization\n    /// @param t2 Time in seconds for rate to increase from min to max at u2 utilization\n    /// @param tlow Time in seconds to reset rates when utilization drops to ulow\n    /// @param tcrit Time in seconds for rate to increase from min to max at critical utilization\n    /// @param tMin minimal time it takes to grow from the minimal to the maximal APR at any utilization\n    struct UserFriendlyConfig {\n        uint64 ulow;\n        uint64 ucrit;\n        uint64 u1;\n        uint64 u2;\n        uint72 rmin;\n        uint72 rcritMin;\n        uint72 rcritMax;\n        uint72 r100;\n        uint32 t1;\n        uint32 t2;\n        uint32 tlow;\n        uint32 tcrit;\n        uint32 tMin;\n    }\n\n    /// @dev same as UserFriendlyConfig but with int256 values to help with calculations\n    struct UserFriendlyConfigInt {\n        int256 ulow;\n        int256 ucrit;\n        int256 u1;\n        int256 u2;\n        int256 rmin;\n        int256 rcritMin;\n        int256 rcritMax;\n        int256 r100;\n        int256 t1;\n        int256 t2;\n        int256 tlow;\n        int256 tcrit;\n        int256 tMin;\n    }\n\n    /// @notice Internal configuration structure used by the model for calculations\n    /// @dev These values are used in the mathematical calculations of the interest rate model.\n    ///     Utilization values are in 18 decimals 1e18 = 100%.\n    /// @param ulow ulow  [0, 1e18) Low utilization threshold\n    /// @param u1 u1  [0, 1e18) Lower bound of optimal utilization range\n    /// @param u2 u2  [u1, 1e18) Upper bound of optimal utilization range\n    /// @param ucrit ucrit  [ulow, 1e18) Critical utilization threshold\n    /// @param rmin rmin >= 0 Minimal per-second interest rate\n    /// @param kmin kmin >= 0 Minimal slope k of central segment (curve) of the kink\n    /// @param kmax kmax >= kmin Maximal slope k of central segment (curve) of the kink\n    /// @param alpha alpha >= 0 Factor controlling the slope for the critical segment of the kink\n    /// @param cminus cminus >= 0 Coefficient of decrease of the slope k\n    /// @param cplus cplus >= 0 Coefficient for increasing the slope k\n    /// @param c1 c1 >= 0 Minimal rate of decrease of the slope k\n    /// @param c2 c2 >= 0 Minimal growth rate of the slope k\n    /// @param dmax dmax >= 0 Maximum growth rate of the slope k\n    struct Config {\n        int256 ulow;\n        int256 u1;\n        int256 u2;\n        int256 ucrit;\n        int256 rmin;\n        int96 kmin;\n        int96 kmax;\n        int256 alpha;\n        int256 cminus;\n        int256 cplus;\n        int256 c1;\n        int256 c2;\n        int256 dmax;\n    }\n\n    struct ImmutableArgs {\n        uint32 timelock;\n        int96 rcompCap;\n    }\n\n    struct ImmutableConfig {\n        uint32 timelock;\n        int96 rcompCapPerSecond;\n    }\n\n    /// @notice Internal variables used during compound interest calculations\n    /// @dev This structure contains temporary variables used in the mathematical calculations.\n    ///      Integrators typically don't need to interact with these values directly.\n    /// \n    /// @param T Time elapsed since the last interest rate update (in seconds)\n    /// @param k1 Internal variable for slope calculations\n    /// @param f Factor used in kink slope calculations\n    /// @param roc Rate of change variable for slope calculations\n    /// @param x Internal calculation variable\n    /// @param interest Absolute value of compounded interest\n    struct LocalVarsRCOMP {\n        int256 T;\n        int256 k1;\n        int256 f;\n        int256 roc;\n        int256 x;\n        int256 interest;\n    }\n\n    struct CompoundInterestRateArgs {\n        address silo;\n        uint256 collateralAssets;\n        uint256 debtAssets;\n        uint256 interestRateTimestamp;\n        uint256 blockTimestamp;\n        bool usePending;\n    }\n\n    /// @notice Current state of the Dynamic Kink Model\n    /// @dev This structure tracks the current state of the model, including the dynamic slope value\n    ///      that changes over time based on utilization patterns.\n    /// \n    /// @param k Current slope value of the kink curve (changes dynamically over time)\n    /// @param silo Address of the Silo contract this model is associated with\n    struct ModelState {\n        int96 k;\n        address silo;\n    }\n\n    struct History {\n        int96 k;\n        IDynamicKinkModelConfig irmConfig;\n    }\n\n    /// @notice Emitted when the model is initialized with a new configuration\n    /// @param owner Address that will own this model instance\n    /// @param silo Address of the Silo contract this model is associated with\n    event Initialized(address indexed owner, address indexed silo);\n\n    /// @notice Emitted when a new configuration is set for the model\n    /// @param config The new configuration contract address\n    /// @param activeAt Timestamp at which the configuration becomes active\n    event NewConfig(IDynamicKinkModelConfig indexed config, uint256 activeAt);\n\n    /// @notice Emitted when a pending configuration update is canceled\n    /// @param config The canceled configuration contract address\n    event PendingUpdateConfigCanceled(IDynamicKinkModelConfig indexed config);\n\n    error AddressZero();\n    error AlphaDividerZero();\n    error AlreadyInitialized();\n    error EmptySilo();\n    error InvalidAlpha();\n    error InvalidC1();\n    error InvalidC2();\n    error InvalidCminus();\n    error InvalidCplus();\n    error InvalidDefaultConfig();\n    error InvalidDmax();\n    error InvalidKmax();\n    error InvalidKmin();\n    error InvalidKRange();\n    error InvalidRcompCap();\n    error InvalidRcritMax();\n    error InvalidRcritMin();\n    error InvalidRmin();\n    error InvalidSilo();\n    error InvalidT1();\n    error InvalidT2();\n    error InvalidTimelock();\n    error InvalidTimestamp();\n    error InvalidTMin();\n    error InvalidTLow();\n    error InvalidTCrit();\n    error InvalidU1();\n    error InvalidU2();\n    error InvalidUcrit();\n    error InvalidUlow();\n    error NegativeRcomp();\n    error NegativeRcur();\n    error NoPendingUpdateToCancel();\n    error NoPendingConfig();\n    error OnlySilo();\n    error PendingUpdate();\n    error XOverflow();\n\n    /// @notice Initialize the Dynamic Kink Model with configuration and ownership\n    /// @dev This function sets up the model for a specific Silo contract. Can only be called once.\n    /// @param _config The configuration parameters for the interest rate model\n    /// @param _immutableArgs The immutable configuration parameters for the interest rate model\n    /// @param _initialOwner Address that will own and control this model instance\n    /// @param _silo Address of the Silo contract this model will serve\n    function initialize(\n        IDynamicKinkModel.Config calldata _config, \n        IDynamicKinkModel.ImmutableArgs calldata _immutableArgs, \n        address _initialOwner, \n        address _silo\n    ) \n        external;\n\n    /// @notice Update the model configuration\n    /// @dev This function allows the model owner to update the configuration of the model.\n    ///      By setting the same config, we can reset k to kmin.\n    /// @param _config The new configuration parameters for the interest rate model\n    function updateConfig(IDynamicKinkModel.Config calldata _config) external;\n\n    /// @notice Cancel the pending configuration update\n    /// @dev This function allows the model owner to cancel the pending configuration update.\n    ///      It will revert if there is no pending update.\n    function cancelPendingUpdateConfig() external;\n\n    /// @notice Calculate compound interest rate and update the model's internal state\n    /// @dev This function is the primary method used by Silo contracts to calculate\n    ///      and accrue interest. Unlike getCompoundInterestRate(), this function\n    ///      modifies the model's internal state by updating the dynamic slope value (k).\n    /// \n    ///      This function should only be called by the associated Silo contract,\n    ///      as it performs state updates that affect future interest calculations.\n    ///      It includes comprehensive overflow protection and gracefully handles\n    ///      calculation errors by returning 0 and resetting the slope to minimum.\n    /// \n    ///      The function calculates interest based on:\n    ///      - Current collateral and debt amounts\n    ///      - Time elapsed since last interest rate update\n    ///      - Dynamic slope adjustments based on utilization patterns\n    /// \n    /// @param _collateralAssets Total collateral assets in the Silo (in asset units)\n    /// @param _debtAssets Total debt assets in the Silo (in asset units)\n    /// @param _interestRateTimestamp Timestamp of the last interest rate update\n    /// @return rcomp Total compound interest multiplier (in 18 decimals, represents total accrued interest)\n    /// @custom:throws OnlySilo() if called by any address other than the associated Silo contract\n    function getCompoundInterestRateAndUpdate(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _interestRateTimestamp\n    )\n        external\n        returns (uint256 rcomp);\n    \n    function configsHistory(IDynamicKinkModelConfig _irmConfig) \n        external \n        view \n        returns (int96 k, IDynamicKinkModelConfig irmConfig);\n\n    /// @notice Get the current (active) configuration contract for this model\n    /// @return config The IDynamicKinkModelConfig contract containing the model parameters\n    function irmConfig() external view returns (IDynamicKinkModelConfig config);\n\n    /// @notice Get the current (active) model state\n    function modelState() external view returns (ModelState memory state);\n    \n    /// @notice Get both the current model state and configuration\n    /// @param _usePending Whether to use the pending configuration to pull config from\n    /// @return state Current state of the model (including dynamic slope value)\n    /// @return config configuration parameters, either active or pending, depending on _usePending\n    /// @return immutableConfig Immutable configuration parameters\n    function getModelStateAndConfig(bool _usePending) \n        external \n        view \n        returns (ModelState memory state, Config memory config, ImmutableConfig memory immutableConfig);\n\n    /// @notice Maximum compound interest rate per second (prevents extreme rates)\n    /// @return cap Maximum per-second compound interest rate in 18 decimals\n    function RCOMP_CAP_PER_SECOND() external view returns (int256 cap); // solhint-disable-line func-name-mixedcase\n    \n    /// @notice Maximum current interest rate (prevents extreme APRs)\n    /// @return cap Maximum annual interest rate in 18 decimals (e.g., 25e18 = 2500% APR)\n    function RCUR_CAP() external view returns (int256 cap); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Number of seconds in one year (used for rate calculations)\n    /// @return secondsInYear Seconds in one year (365 days)\n    function ONE_YEAR() external view returns (int256 secondsInYear); // solhint-disable-line func-name-mixedcase\n    \n    /// @notice Maximum input value for exponential calculations (prevents overflow)\n    /// @return max Maximum safe input value for exp() function\n    function X_MAX() external view returns (int256 max); // solhint-disable-line func-name-mixedcase\n    \n    /// @notice Universal limit for various model parameters\n    /// @return limit Maximum allowed value for certain configuration parameters\n    function UNIVERSAL_LIMIT() external view returns (int256 limit); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Maximum time lock for configuration changes\n    /// @return maxTimeLock Maximum time lock for configuration changes\n    function MAX_TIMELOCK() external view returns (uint32 maxTimeLock); // solhint-disable-line func-name-mixedcase\n\n    /// @return timestamp Timestamp at which the pending configuration becomes active\n    function activateConfigAt() external view returns (uint256 timestamp);\n\n    /// @return pendingIrmConfig Pending irm config for configuration changes, 0 if no pending\n    function pendingIrmConfig() external view returns (address pendingIrmConfig);\n\n    /// @notice Validate that configuration parameters are within acceptable limits\n    /// @dev This function checks if all configuration parameters are within the safe operating ranges\n    ///      defined by the model whitepaper. Some limits are narrower than the original whitepaper\n    ///      due to additional research and safety considerations.\n    /// \n    ///      For detailed limits, see:\n    ///      https://silofinance.atlassian.net/wiki/spaces/SF/pages/347963393/DynamicKink+model+config+limits+V1\n    /// \n    /// @param _config The configuration to validate (does not include model state)\n    /// @custom:throws Reverts if any parameter is outside acceptable limits\n    function verifyConfig(IDynamicKinkModel.Config calldata _config) external view;\n\n    /// @notice Calculate compound interest rate for a specific Silo at a given timestamp\n    /// @dev This function calculates the total compound interest that has accrued over time\n    ///      for a specific Silo contract.\n    /// \n    ///      The function fetches current utilization data from the Silo contract and\n    ///      calculates interest based on the time elapsed since the last rate update.\n    ///      It handles overflow protection and returns 0 if calculations would overflow.\n    /// \n    /// @param _silo Address of the Silo contract to calculate interest for\n    /// @param _blockTimestamp Timestamp to calculate interest up to (usually block.timestamp)\n    /// @return rcomp Total compound interest multiplier (in 18 decimals, represents total accrued interest)\n    /// @custom:throws InvalidSilo() if the provided Silo address doesn't match this model's associated Silo\n    function getCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcomp);\n\n    /// @notice Same as getCompoundInterestRate but uses pending configuration, throws if no pending\n    function getPendingCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcomp);\n\n    /// @notice get current annual interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp timestamp to calculate interest up to (usually block.timestamp)\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function getCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcur);\n\n    /// @notice Same as getCurrentInterestRate but uses pending configuration, throws if no pending\n    function getPendingCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcur);\n\n    /// @notice Calculate the compound interest rate for a given time period\n    /// @dev This function calculates how much interest has accrued over a time period,\n    ///      taking into account the dynamic nature of the kink model. The rate changes\n    ///      over time based on utilization patterns and the model's adaptive behavior.\n    /// \n    ///      This is the core function used by Silo contracts to determine how much\n    ///      interest borrowers owe and how much lenders should receive.\n    /// \n    /// @param _cfg Model configuration parameters\n    /// @param _state Current model state (including dynamic slope value)\n    /// @param _rcompCapPerSecond Maximum compound interest rate per second\n    /// @param _t0 Timestamp of the last interest rate update\n    /// @param _t1 Current timestamp for the calculation\n    /// @param _u Utilization ratio at time _t0 (0 to 1e18, where 1e18 = 100% utilized)\n    /// @param _tba Total borrowed amount at time _t1\n    /// @return rcomp Total compound interest accrued over the time period (in 18 decimals, represents multiplier)\n    /// @return k Updated model state (new slope value) at time _t1\n    function compoundInterestRate(\n        Config memory _cfg,\n        ModelState memory _state,\n        int256 _rcompCapPerSecond,\n        int256 _t0,\n        int256 _t1,\n        int256 _u,\n        int256 _tba\n    )\n        external\n        pure\n        returns (int256 rcomp, int256 k);\n\n    /// @notice Calculate the current instantaneous interest rate\n    /// @dev This function returns the current interest rate that would apply if a new\n    ///      transaction were to occur right now. Unlike compoundInterestRate, this\n    ///      doesn't calculate accrued interest over time, but rather the rate at\n    ///      the current moment.\n    /// \n    ///      This is useful for:\n    ///      - Displaying current rates to users\n    ///      - Calculating what rate would apply to new borrows\n    ///      - Monitoring rate changes in real-time\n    /// \n    /// @param _cfg Model configuration parameters\n    /// @param _state Current model state (including dynamic slope value)\n    /// @param _t0 Timestamp of the last interest rate update\n    /// @param _t1 Current timestamp for the calculation\n    /// @param _u Current utilization ratio (0 to 1e18, where 1e18 = 100% utilized)\n    /// @param _tba Current total borrowed amount\n    /// @return rcur Current instantaneous interest rate (in 18 decimals, annual rate)\n    function currentInterestRate(\n        Config memory _cfg,\n        ModelState memory _state,\n        int256 _t0,\n        int256 _t1,\n        int256 _u,\n        int256 _tba\n    )\n        external\n        pure\n        returns (int256 rcur);\n}\n"
    },
    "silo-core/contracts/interfaces/IDynamicKinkModelFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IDynamicKinkModel} from \"./IDynamicKinkModel.sol\";\nimport {IInterestRateModel} from \"./IInterestRateModel.sol\";\n\n/// @title IDynamicKinkModelFactory\n/// @notice Factory interface for creating Dynamic Kink Interest Rate Model instances\n/// @dev This factory creates and manages DynamicKinkModel instances using a clone pattern.\n///      It provides utilities for configuration generation, validation, and deterministic\n///      address prediction using CREATE2.\n/// \n///      Key Features:\n///      - Creates DynamicKinkModel instances via cloning\n///      - Converts user-friendly configs to internal model parameters\n///      - Validates configurations before deployment\n///      - Predicts deterministic addresses for CREATE2 deployments\n///      - Tracks which models were created by this factory\n/// \n///      Usage Flow:\n///      1. Use generateConfig() to convert UserFriendlyConfig to internal Config\n///      2. Use verifyConfig() to validate the configuration\n///      3. Use create() to deploy a new DynamicKinkModel instance\n///      4. Use predictAddress() to determine the deployment address beforehand\ninterface IDynamicKinkModelFactory {\n    /// @notice Emitted when a new DynamicKinkModel instance is created\n    /// @param irm The address of the newly created DynamicKinkModel instance\n    event NewDynamicKinkModel(IDynamicKinkModel indexed irm);\n\n    /// @notice Thrown when trying to predict address with zero deployer address\n    error DeployerCannotBeZero();\n\n    /// @notice Creates a new DynamicKinkModel instance using CREATE2\n    /// @dev This function verifies the configuration, creates a clone of the implementation,\n    ///      initializes it with the provided parameters, and tracks it in the factory.\n    ///      The same salt will always produce the same address, enabling deterministic deployments.\n    /// \n    ///      The function can be used in separate transactions - configurations can be prepared\n    ///      and validated before being used for Silo creation.\n    /// \n    /// @param _config Updatable configuration parameters\n    /// @param _immutableArgs Immutable configuration arguments\n    /// @param _initialOwner Address that will own and control the created model instance\n    /// @param _silo Address of the Silo contract this model will serve\n    /// @param _externalSalt External salt for the CREATE2 deterministic deployment\n    /// @return irm The deployed DynamicKinkModel instance (IInterestRateModel interface)\n    function create(\n        IDynamicKinkModel.Config calldata _config, \n        IDynamicKinkModel.ImmutableArgs calldata _immutableArgs,\n        address _initialOwner,\n        address _silo,\n        bytes32 _externalSalt\n    )\n        external\n        returns (IInterestRateModel irm);\n\n    /// @notice Converts user-friendly configuration to internal model parameters\n    /// @dev This function takes intuitive configuration parameters and converts them to the\n    ///      internal mathematical parameters used by the DynamicKinkModel. It performs\n    ///      validation to ensure the configuration is mathematically sound and within\n    ///      acceptable limits.\n    /// \n    ///      The conversion includes:\n    ///      - Converting annual rates to per-second rates\n    ///      - Calculating slope parameters (kmin, kmax) from rate ranges\n    ///      - Computing time-based coefficients (c1, c2, cminus, cplus)\n    ///      - Validating parameter relationships and constraints\n    /// \n    /// @param _default User-friendly configuration parameters (utilization thresholds, rates, times)\n    /// @return config Internal configuration parameters ready for model initialization\n    function generateConfig(IDynamicKinkModel.UserFriendlyConfig calldata _default)\n        external\n        view\n        returns (IDynamicKinkModel.Config memory config);\n\n    /// @notice Validates that configuration parameters are within acceptable limits\n    /// @dev This function checks if all configuration parameters are within the safe operating ranges\n    ///      defined by the model whitepaper. Some limits are narrower than the original whitepaper\n    ///      due to additional research and safety considerations.\n    /// \n    ///      For detailed limits, see:\n    ///      https://silofinance.atlassian.net/wiki/spaces/SF/pages/347963393/DynamicKink+model+config+limits+V1\n    /// \n    /// @param _config The configuration to validate (does not include model state)\n    /// @custom:throws Reverts if any parameter is outside acceptable limits\n    function verifyConfig(IDynamicKinkModel.Config calldata _config) external view;\n\n    /// @notice Predicts the deterministic address of a DynamicKinkModel that would be created\n    /// @dev This function calculates the address that would be generated by CREATE2 when\n    ///      creating a DynamicKinkModel with the given deployer and salt. This enables\n    ///      front-running protection and allows users to know the address before deployment.\n    /// \n    ///      The same deployer and salt will always produce the same predicted address.\n    /// \n    /// @param _deployer Address of the account that will deploy the model\n    /// @param _externalSalt External salt for the CREATE2 deterministic deployment\n    /// @return predictedAddress The address where the DynamicKinkModel would be deployed\n    function predictAddress(address _deployer, bytes32 _externalSalt)\n        external\n        view\n        returns (address predictedAddress);\n\n    /// @notice Checks if a DynamicKinkModel was created by this factory\n    /// @dev This function verifies whether a given address corresponds to a DynamicKinkModel\n    ///      instance that was deployed through this factory. This is useful for:\n    ///      - Verifying the authenticity of model instances\n    ///      - Implementing access controls based on factory creation\n    ///      - Tracking and managing factory-deployed models\n    /// \n    /// @param _irm Address of the DynamicKinkModel contract to check\n    /// @return isCreated True if the model was created by this factory, false otherwise\n    function createdByFactory(address _irm) external view returns (bool isCreated);\n}\n"
    },
    "silo-core/contracts/interestRateModel/kink/DynamicKinkModel.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {SafeCast} from \"openzeppelin5/utils/math/SafeCast.sol\";\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\nimport {SignedMath} from \"openzeppelin5/utils/math/SignedMath.sol\";\nimport {Initializable} from \"openzeppelin5/proxy/utils/Initializable.sol\";\n\nimport {Ownable1and2Steps} from \"common/access/Ownable1and2Steps.sol\";\n\nimport {PRBMathSD59x18} from \"../../lib/PRBMathSD59x18.sol\";\nimport {ISilo} from \"../../interfaces/ISilo.sol\";\nimport {IDynamicKinkModel} from \"../../interfaces/IDynamicKinkModel.sol\";\nimport {IDynamicKinkModelConfig} from \"../../interfaces/IDynamicKinkModelConfig.sol\";\nimport {IVersioned} from \"../../interfaces/IVersioned.sol\";\n\nimport {DynamicKinkModelConfig} from \"./DynamicKinkModelConfig.sol\";\nimport {KinkMath} from \"../../lib/KinkMath.sol\";\nimport {SiloMathLib} from \"../../lib/SiloMathLib.sol\";\n\n/// @title DynamicKinkModel\n/// @notice Refer to Silo DynamicKinkModel paper for more details:\n/// silo-core/docs/Kink_Interest_Rate_Model_V2_2025_09_23.pdf\n/// @dev it follows `IInterestRateModel` interface except `initialize` method\n/// @custom:security-contact security@silo.finance\ncontract DynamicKinkModel is IDynamicKinkModel, IVersioned, Ownable1and2Steps, Initializable {\n    using KinkMath for int256;\n    using KinkMath for int96;\n    using KinkMath for uint256;\n\n    string public constant VERSION = \"DynamicKinkModel 3.14.0\";\n\n    /// @dev DP in 18 decimal points used for integer calculations\n    int256 internal constant _DP = int256(1e18);\n\n    /// @dev universal limit for several DynamicKinkModel config parameters. Follow the model whitepaper for more\n    ///     information. Units of measure vary per variable type. Any config within these limits is considered\n    ///     valid.\n    int256 public constant UNIVERSAL_LIMIT = 1e9 * _DP;\n\n    /// @dev maximum value of current interest rate the model will return. This is 1,000% APR in 18-decimals.\n    int256 public constant RCUR_CAP = 10 * _DP;\n\n    /// @dev seconds per year used in interest calculations.\n    int256 public constant ONE_YEAR = 365 days;\n\n    /// @dev maximum value of compound interest per second the model will return. This is per-second rate.\n    int256 public constant RCOMP_CAP_PER_SECOND = RCUR_CAP / ONE_YEAR;\n\n    /// @dev maximum exp() input to prevent an overflow.\n    int256 public constant X_MAX = 11 * _DP;\n\n    uint32 public constant MAX_TIMELOCK = 7 days;\n\n    /// @dev this is used for storing the current or pending model state\n    ModelState internal _modelState;\n\n    /// @inheritdoc IDynamicKinkModel\n    uint256 public activateConfigAt;\n\n    /// @dev Map of all configs for the model, used for restoring to last state\n    mapping(IDynamicKinkModelConfig current => History prev) public configsHistory;\n\n    IDynamicKinkModelConfig internal _irmConfig;\n\n    constructor() Ownable1and2Steps(address(0xdead)) {\n        // lock the implementation\n        _transferOwnership(address(0));\n        _disableInitializers();\n    }\n\n    function initialize(\n        IDynamicKinkModel.Config calldata _config,\n        IDynamicKinkModel.ImmutableArgs calldata _immutableArgs,\n        address _initialOwner,\n        address _silo\n    )\n        external\n        virtual\n        initializer\n    {\n        require(_silo != address(0), EmptySilo());\n        require(_immutableArgs.timelock <= MAX_TIMELOCK, InvalidTimelock());\n        require(_immutableArgs.rcompCap > 0, InvalidRcompCap());\n        require(_immutableArgs.rcompCap <= RCUR_CAP, InvalidRcompCap());\n\n        IDynamicKinkModel.ImmutableConfig memory immutableConfig = IDynamicKinkModel.ImmutableConfig({\n            timelock: _immutableArgs.timelock,\n            rcompCapPerSecond: int96(_immutableArgs.rcompCap / ONE_YEAR) // forge-lint: disable-line(unsafe-typecast)\n        });\n\n        _modelState.silo = _silo;\n\n        _updateConfiguration({_config: _config, _immutableConfig: immutableConfig, _init: true});\n\n        _transferOwnership(_initialOwner);\n\n        emit Initialized(_initialOwner, _silo);\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function updateConfig(IDynamicKinkModel.Config calldata _config) external virtual onlyOwner {\n        _updateConfiguration(_config);\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function cancelPendingUpdateConfig() external virtual onlyOwner {\n        require(pendingConfigExists(), NoPendingUpdateToCancel());\n\n        IDynamicKinkModelConfig pendingConfig = _irmConfig;\n        History memory currentState = configsHistory[pendingConfig];\n\n        _irmConfig = currentState.irmConfig;\n        _modelState.k = currentState.k;\n\n        configsHistory[pendingConfig] = History(0, IDynamicKinkModelConfig(address(0)));\n\n        activateConfigAt = 0;\n\n        emit PendingUpdateConfigCanceled(pendingConfig);\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function getCompoundInterestRateAndUpdate(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _interestRateTimestamp\n    )\n        external\n        virtual\n        returns (uint256 rcomp) \n    {\n        int96 newK;\n        uint256 result; \n\n        (result, newK) = _getCompoundInterestRate(CompoundInterestRateArgs({\n            silo: msg.sender,\n            collateralAssets: _collateralAssets,\n            debtAssets: _debtAssets,\n            interestRateTimestamp: _interestRateTimestamp,\n            blockTimestamp: block.timestamp,\n            usePending: false\n        }));\n\n        rcomp = result;\n\n        if (pendingConfigExists()) {\n            configsHistory[_irmConfig].k = newK;\n        } else {\n            _modelState.k = newK;\n        }\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function getCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        virtual\n        returns (uint256 rcomp)\n    {\n        (rcomp,) = _getCompoundInterestRate({_silo: _silo, _blockTimestamp: _blockTimestamp, _usePending: false});\n    }\n\n    function getPendingCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        virtual\n        returns (uint256 rcomp)\n    {\n        (rcomp,) = _getCompoundInterestRate({_silo: _silo, _blockTimestamp: _blockTimestamp, _usePending: true});\n    }\n\n    /// @notice it reverts for invalid silo\n    function getCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        virtual\n        returns (uint256 rcur)\n    {\n        rcur = _getCurrentInterestRate({_silo: _silo, _blockTimestamp: _blockTimestamp, _usePending: false});\n    }\n\n    function getPendingCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        virtual\n        returns (uint256 rcur)\n    {\n        rcur = _getCurrentInterestRate({_silo: _silo, _blockTimestamp: _blockTimestamp, _usePending: true});\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function irmConfig() public view returns (IDynamicKinkModelConfig config) {\n        config = pendingConfigExists() ? configsHistory[_irmConfig].irmConfig : _irmConfig;\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function modelState() public view returns (ModelState memory state) {\n        if (!pendingConfigExists()) return _modelState;\n\n        // in case of pending config, we need to read k from history\n        state.silo = _modelState.silo;\n        state.k = configsHistory[_irmConfig].k;\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function pendingIrmConfig() public view returns (address config) {\n        config = pendingConfigExists() ? address(_irmConfig) : address(0);\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function getModelStateAndConfig(bool _usePending)\n        public\n        view\n        virtual\n        returns (ModelState memory state, Config memory config, ImmutableConfig memory immutableConfig)\n    {\n        IDynamicKinkModelConfig irmConfigToUse;\n\n        if (_usePending) {\n            irmConfigToUse = IDynamicKinkModelConfig(pendingIrmConfig());\n            require(address(irmConfigToUse) != address(0), NoPendingConfig());\n\n            state = _modelState;\n        } else {\n            irmConfigToUse = irmConfig();\n            state = modelState();\n        }\n\n        (config, immutableConfig) = irmConfigToUse.getConfig();\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function verifyConfig(IDynamicKinkModel.Config memory _config) public view virtual {\n        require(_config.ulow.inClosedInterval(0, _DP), InvalidUlow());\n        require(_config.u1.inClosedInterval(0, _DP), InvalidU1());\n        require(_config.u2.inClosedInterval(_config.u1, _DP), InvalidU2());\n\n        require(_config.ucrit.inClosedInterval(_config.ulow, _DP), InvalidUcrit());\n\n        require(_config.rmin.inClosedInterval(0, _DP), InvalidRmin());\n\n        require(_config.kmin.inClosedInterval(0, UNIVERSAL_LIMIT), InvalidKmin());\n        require(_config.kmax.inClosedInterval(_config.kmin, UNIVERSAL_LIMIT), InvalidKmax());\n\n        // we store k as int96, so we double check if it is in the range of int96\n        require(_config.kmin.inClosedInterval(0, type(int96).max), InvalidKmin());\n        require(_config.kmax.inClosedInterval(_config.kmin, type(int96).max), InvalidKmax());\n\n        require(_config.alpha.inClosedInterval(0, UNIVERSAL_LIMIT), InvalidAlpha());\n\n        require(_config.cminus.inClosedInterval(0, UNIVERSAL_LIMIT), InvalidCminus());\n        require(_config.cplus.inClosedInterval(0, UNIVERSAL_LIMIT), InvalidCplus());\n\n        require(_config.c1.inClosedInterval(0, UNIVERSAL_LIMIT), InvalidC1());\n        require(_config.c2.inClosedInterval(0, UNIVERSAL_LIMIT), InvalidC2());\n\n        require(_config.dmax.inClosedInterval(_config.c2, UNIVERSAL_LIMIT), InvalidDmax());\n    }\n\n    function pendingConfigExists() public view returns (bool) {\n        return activateConfigAt > block.timestamp;\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function currentInterestRate( // solhint-disable-line function-max-lines, code-complexity\n        Config memory _cfg,\n        ModelState memory _state, \n        int256 _t0, \n        int256 _t1,\n        int256 _u,\n        int256 _tba\n    )\n        public\n        pure\n        virtual\n        returns (int256 rcur)\n    {\n        if (_tba == 0) return 0; // no debt, no interest\n\n        int256 T = _t1 - _t0;\n\n        // k is stored capped, so we can use it as is\n        int256 k = _state.k;\n\n        if (_u < _cfg.u1) {\n            k = SignedMath.max(k - (_cfg.c1 + _cfg.cminus * (_cfg.u1 - _u) / _DP) * T, _cfg.kmin);\n        } else if (_u > _cfg.u2) {\n            k = SignedMath.min(\n                k + SignedMath.min(_cfg.c2 + _cfg.cplus * (_u - _cfg.u2) / _DP, _cfg.dmax) * T, _cfg.kmax\n            );\n        }\n\n        int256 excessU; // additional interest rate\n        if (_u >= _cfg.ulow) {\n            excessU = _u - _cfg.ulow;\n\n            if (_u >= _cfg.ucrit) {\n                excessU = excessU + _cfg.alpha * (_u - _cfg.ucrit) / _DP;\n            }\n\n            rcur = excessU * k * ONE_YEAR / _DP + _cfg.rmin * ONE_YEAR;\n        } else {\n            rcur = _cfg.rmin * ONE_YEAR;\n        }\n\n        require(rcur >= 0, NegativeRcur());\n        rcur = SignedMath.min(rcur, RCUR_CAP);\n    }\n\n    /// @inheritdoc IDynamicKinkModel\n    function compoundInterestRate( // solhint-disable-line code-complexity, function-max-lines\n        Config memory _cfg,\n        ModelState memory _state,\n        int256 _rcompCapPerSecond,\n        int256 _t0,\n        int256 _t1,\n        int256 _u,\n        int256 _tba\n    )\n        public\n        pure\n        virtual\n        returns (int256 rcomp, int256 k)\n    {\n        LocalVarsRCOMP memory _l;\n\n        require(_t0 <= _t1, InvalidTimestamp());\n\n        _l.T = _t1 - _t0;\n        // if there is no time change, then k should not change\n        if (_l.T == 0) return (0, _state.k);\n\n        // rate of change of k\n        if (_u < _cfg.u1) {\n            _l.roc = -_cfg.c1 - _cfg.cminus * (_cfg.u1 - _u) / _DP;\n        } else if (_u > _cfg.u2) {\n            _l.roc = SignedMath.min(_cfg.c2 + _cfg.cplus * (_u - _cfg.u2) / _DP, _cfg.dmax);\n        }\n\n        k = _state.k;\n\n        // slope of the kink at t1 ignoring lower and upper bounds\n        _l.k1 = k + _l.roc * _l.T;\n\n        // calculate the resulting slope state\n        if (_l.k1 > _cfg.kmax) {\n            _l.x = _cfg.kmax * _l.T - (_cfg.kmax - k) ** 2 / (2 * _l.roc);\n            k = _cfg.kmax;\n        } else if (_l.k1 < _cfg.kmin) {\n            _l.x = _cfg.kmin * _l.T - (k - _cfg.kmin) ** 2 / (2 * _l.roc);\n            k = _cfg.kmin;\n        } else {\n            _l.x = (k + _l.k1) * _l.T / 2;\n            k = _l.k1;\n        }\n\n        if (_u >= _cfg.ulow) {\n            _l.f = _u - _cfg.ulow;\n\n            if (_u >= _cfg.ucrit) {\n                _l.f = _l.f + _cfg.alpha * (_u - _cfg.ucrit) / _DP;\n            }\n        }\n\n        _l.x = _cfg.rmin * _l.T + _l.f * _l.x / _DP;\n\n        // Overflow Checks\n\n        // limit x, so the exp() function will not overflow, we have unchecked math there\n        require(_l.x <= X_MAX, XOverflow());\n\n        rcomp = PRBMathSD59x18.exp(_l.x) - _DP;\n        require(rcomp >= 0, NegativeRcomp());\n\n        // limit rcomp\n        if (rcomp > _rcompCapPerSecond * _l.T) {\n            rcomp = _rcompCapPerSecond * _l.T;\n            // k should be set to min only on overflow or cap\n            k = _cfg.kmin;\n        }\n\n        // no debt, no interest, overriding min APR\n        if (_tba == 0) rcomp = 0;\n    }\n\n    function _updateConfiguration(IDynamicKinkModel.Config memory _config) internal virtual {\n        // even if _irmConfig is pending timelock, immutable config can be pulled from it\n        (, IDynamicKinkModel.ImmutableConfig memory immutableConfig) = _irmConfig.getConfig();\n        _updateConfiguration({_config: _config, _immutableConfig: immutableConfig, _init: false});\n    }\n\n    function _updateConfiguration(\n        IDynamicKinkModel.Config memory _config,\n        IDynamicKinkModel.ImmutableConfig memory _immutableConfig,\n        bool _init\n    ) internal virtual {\n        require(!pendingConfigExists(), PendingUpdate());\n\n        activateConfigAt = _init ? block.timestamp : block.timestamp + _immutableConfig.timelock;\n\n        verifyConfig(_config);\n\n        IDynamicKinkModelConfig newCfg = IDynamicKinkModelConfig(new DynamicKinkModelConfig(_config, _immutableConfig));\n\n        configsHistory[newCfg] = History({k: _modelState.k, irmConfig: _irmConfig});\n        _modelState.k = _config.kmin;\n        _irmConfig = newCfg;\n\n        emit NewConfig(newCfg, activateConfigAt);\n    }\n\n    function _getCompoundInterestRate(\n        address _silo,\n        uint256 _blockTimestamp,\n        bool _usePending\n    )\n        internal\n        view\n        virtual\n        returns (uint256 rcomp, int96 k)\n    {\n        ISilo.UtilizationData memory data = ISilo(_silo).utilizationData();\n\n        (rcomp, k) = _getCompoundInterestRate(CompoundInterestRateArgs({\n            silo: _silo,\n            collateralAssets: data.collateralAssets,\n            debtAssets: data.debtAssets,\n            interestRateTimestamp: data.interestRateTimestamp,\n            blockTimestamp: _blockTimestamp,\n            usePending: _usePending\n        }));\n    }\n\n    function _getCompoundInterestRate(CompoundInterestRateArgs memory _args)\n        internal\n        view\n        virtual\n        returns (uint256 rcomp, int96 k)\n    {\n        (ModelState memory state, Config memory cfg, ImmutableConfig memory immutableCfg) =\n            getModelStateAndConfig(_args.usePending);\n\n        require(_args.silo == state.silo, InvalidSilo());\n\n        // k should be set to min on overflow\n        if (_args.interestRateTimestamp.wouldOverflowOnCastToInt256()) return (0, cfg.kmin);\n        if (_args.blockTimestamp.wouldOverflowOnCastToInt256()) return (0, cfg.kmin);\n        if (_args.collateralAssets.wouldOverflowOnCastToInt256()) return (0, cfg.kmin);\n        if (_args.debtAssets.wouldOverflowOnCastToInt256()) return (0, cfg.kmin);\n\n        try this.compoundInterestRate({\n            _cfg: cfg,\n            _state: state,\n            _rcompCapPerSecond: immutableCfg.rcompCapPerSecond,\n            _t0: int256(uint256(_args.interestRateTimestamp)),\n            _t1: int256(_args.blockTimestamp),\n            _u: _calculateUtiliation(_args.collateralAssets, _args.debtAssets),\n            _tba: int256(_args.debtAssets)\n        }) returns (int256 rcompInt, int256 newK) {\n            rcomp = SafeCast.toUint256(rcompInt);\n            k = _capK(newK, cfg.kmin, cfg.kmax);\n        } catch {\n            rcomp = 0;\n            k = cfg.kmin; // k should be set to min on overflow\n        }\n    }\n\n    function _getCurrentInterestRate(address _silo, uint256 _blockTimestamp, bool _usePending)\n        internal\n        view\n        virtual\n        returns (uint256 rcur)\n    {\n        (ModelState memory state, Config memory cfg,) = getModelStateAndConfig(_usePending);\n        require(_silo == state.silo, InvalidSilo());\n\n        ISilo.UtilizationData memory data = ISilo(state.silo).utilizationData();\n\n        if (data.debtAssets.wouldOverflowOnCastToInt256()) return 0;\n        if (_blockTimestamp.wouldOverflowOnCastToInt256()) return 0;\n\n        try this.currentInterestRate({\n            _cfg: cfg,\n            _state: state,\n            _t0: SafeCast.toInt256(data.interestRateTimestamp),\n            _t1: int256(_blockTimestamp), // forge-lint: disable-line(unsafe-typecast)\n            _u: _calculateUtiliation(data.collateralAssets, data.debtAssets),\n            _tba: int256(data.debtAssets) // forge-lint: disable-line(unsafe-typecast)\n        }) returns (int256 rcurInt) {\n            rcur = SafeCast.toUint256(rcurInt);\n        } catch {\n            rcur = 0;\n        }\n    }\n\n    // hard rule: utilization in the model should never be above 100%.\n    function _calculateUtiliation(uint256 _collateralAssets, uint256 _debtAssets)\n        internal\n        pure\n        virtual\n        returns (int256 u)\n    {\n        // forge-lint: disable-next-line(unsafe-typecast)\n        u = int256(SiloMathLib.calculateUtilization(uint256(_DP), _collateralAssets, _debtAssets));\n    }\n\n    /// @dev we expect _kmin and _kmax to be in the range of int96\n    function _capK(int256 _k, int256 _kmin, int256 _kmax) internal pure virtual returns (int96 cappedK) {\n        require(_kmin <= _kmax, InvalidKRange());\n\n        // safe to cast to int96, because we know, that _kmin and _kmax are in the range of int96\n        cappedK = int96(SignedMath.max(_kmin, SignedMath.min(_kmax, _k)));\n    }\n}\n"
    },
    "silo-core/contracts/lib/KinkMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary KinkMath {\n    /// @notice Check if a value is within a closed interval [a, b]\n    /// @dev Mathematical notation: x  [a, b] where a  x  b\n    /// @param _var The value to check\n    /// @param _lowIncluded Lower bound (inclusive)\n    /// @param _topIncluded Upper bound (inclusive)\n    /// @return isWithinInterval true if _var is within the closed interval\n    function inClosedInterval(\n        int256 _var, \n        int256 _lowIncluded, \n        int256 _topIncluded\n    ) internal pure returns (bool isWithinInterval) {\n        return (_lowIncluded <= _var && _var <= _topIncluded);\n    }\n\n    /// @notice Check if a value is within a half-open interval [a, b)\n    /// @dev Mathematical notation: x  [a, b) where a  x < b\n    /// @param _var The value to check\n    /// @param _lowIncluded Lower bound (inclusive)\n    /// @param _topExcluded Upper bound (exclusive)\n    /// @return isWithinInterval true if _var is within the half-open interval\n    function inOpenIntervalLowIncluded(\n        int256 _var, \n        int256 _lowIncluded, \n        int256 _topExcluded\n    ) internal pure returns (bool isWithinInterval) {\n        return (_lowIncluded <= _var && _var < _topExcluded);\n    }\n\n    /// @notice Check if a value is within a half-open interval (a, b]\n    /// @dev Mathematical notation: x  (a, b] where a < x  b\n    /// @param _var The value to check\n    /// @param _lowExcluded Lower bound (exclusive)\n    /// @param _topIncluded Upper bound (inclusive)\n    /// @return isWithinInterval true if _var is within the half-open interval\n    function inOpenIntervalTopIncluded(\n        int256 _var, \n        int256 _lowExcluded, \n        int256 _topIncluded\n    ) internal pure returns (bool isWithinInterval) {\n        return (_lowExcluded < _var && _var <= _topIncluded);\n    }\n\n    /// @notice Check if a value is within an open interval (a, b)\n    /// @dev Mathematical notation: x  (a, b) where a < x < b\n    /// @param _var The value to check\n    /// @param _lowExcluded Lower bound (exclusive)\n    /// @param _topExcluded Upper bound (exclusive)\n    /// @return isWithinInterval true if _var is within the open interval\n    function inOpenInterval(\n        int256 _var, \n        int256 _lowExcluded, \n        int256 _topExcluded\n    ) internal pure returns (bool isWithinInterval) {\n        return (_lowExcluded < _var && _var < _topExcluded);\n    }\n\n    /// @notice Check if a uint256 value would overflow when cast to int256\n    /// @dev This is a safety check for casting unsigned to signed integers\n    /// @param _value The uint256 value to check\n    /// @return wouldOverflow true if casting would cause overflow\n    function wouldOverflowOnCastToInt256(uint256 _value) internal pure returns (bool wouldOverflow) {\n        return _value > uint256(type(int256).max);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/IDynamicKinkModelConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IDynamicKinkModel} from \"./IDynamicKinkModel.sol\";\n\ninterface IDynamicKinkModelConfig {\n    /// @return config returns immutable IRM configuration that is present in contract\n    function getConfig() \n        external \n        view \n        returns (IDynamicKinkModel.Config memory config, IDynamicKinkModel.ImmutableConfig memory immutableConfig);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return a == 0 ? 0 : (a - 1) / b + 1;\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.UNDER_OVERFLOW);\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, expect 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Ferma's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return x < 0 ? (n - uint256(-x)) : uint256(x); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked has failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "common/access/Ownable1and2Steps.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {Ownable2Step, Ownable} from \"openzeppelin5/access/Ownable2Step.sol\";\n\n/// @dev This contract is a wrapper around Ownable2Step that allows for 1-step ownership transfer\nabstract contract Ownable1and2Steps is Ownable2Step {\n    constructor(address _initialOwner) Ownable(_initialOwner) {}\n\n    /// @notice Transfer ownership to a new address. Pending ownership transfer will be canceled.\n    /// @param newOwner The new owner of the contract\n    function transferOwnership1Step(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n\n        Ownable2Step._transferOwnership(newOwner);\n    }\n}\n"
    },
    "silo-core/contracts/lib/PRBMathSD59x18.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.28;\n\nimport {PRBMathCommon} from \"./PRBMathCommon.sol\";\n\n/* solhint-disable */\n/// @title PRBMathSD59x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math. It works with int256 numbers considered to have 18\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\nlibrary PRBMathSD59x18 {\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\n    int256 internal constant _LOG2_E = 1442695040888963407;\n\n    /// @dev Half the SCALE number.\n    int256 internal constant _HALF_SCALE = 5e17;\n\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant _MAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    /// @dev How many trailing decimals can be represented.\n    int256 internal constant _SCALE = 1e18;\n\n    /// INTERNAL FUNCTIONS ///\n\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 88722839111672999628.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp(int256 x) internal pure returns (int256 result) {\n        // Without this check, the value passed to \"exp2\" would be less than -59794705707972522261.\n        if (x < -41446531673892822322) {\n            return 0;\n        }\n\n        // Without this check, the value passed to \"exp2\" would be greater than 128e18.\n        require(x < 88722839111672999628);\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            int256 doubleScaleProduct = x * _LOG2_E;\n            result = exp2((doubleScaleProduct + _HALF_SCALE) / _SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 128e18 or less.\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - For any x less than -59794705707972522261, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp2(int256 x) internal pure returns (int256 result) {\n        // This works because 2^-x = 1/2^x.\n        if (x < 0) {\n            // 2**59.794705707972522262 is the maximum number whose inverse does not equal zero.\n            if (x < -59794705707972522261) {\n                return 0;\n            }\n\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n            unchecked { result = 1e36 / exp2(-x); }\n            return result;\n        } else {\n            // 2**128 doesn't fit within the 128.128-bit fixed-point representation.\n            require(x < 128e18);\n\n            unchecked {\n                // Convert x to the 128.128-bit fixed-point format.\n                uint256 x128x128 = (uint256(x) << 128) / uint256(_SCALE);\n\n                // Safe to convert the result to int256 directly because the maximum input allowed is 128e18.\n                result = int256(PRBMathCommon.exp2(x128x128));\n            }\n        }\n    }\n}\n/* solhint-enable */\n"
    },
    "silo-core/contracts/interfaces/ISilo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC4626, IERC20, IERC20Metadata} from \"openzeppelin5/interfaces/IERC4626.sol\";\n\nimport {IERC3156FlashLender} from \"./IERC3156FlashLender.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\nimport {ISiloFactory} from \"./ISiloFactory.sol\";\n\nimport {IHookReceiver} from \"./IHookReceiver.sol\";\n\n// solhint-disable ordering\ninterface ISilo is IERC20, IERC4626, IERC3156FlashLender {\n    /// @dev Interest accrual happens on each deposit/withdraw/borrow/repay. View methods work on storage that might be\n    ///      outdate. Some calculations require accrued interest to return current state of Silo. This struct is used\n    ///      to make a decision inside functions if interest should be accrued in memory to work on updated values.\n    enum AccrueInterestInMemory {\n        No,\n        Yes\n    }\n\n    /// @dev Silo has two separate oracles for solvency and maxLtv calculations. MaxLtv oracle is optional. Solvency\n    ///      oracle can also be optional if asset is used as denominator in Silo config. For example, in ETH/USDC Silo\n    ///      one could setup only solvency oracle for ETH that returns price in USDC. Then USDC does not need an oracle\n    ///      because it's used as denominator for ETH and it's \"price\" can be assume as 1.\n    enum OracleType {\n        Solvency,\n        MaxLtv\n    }\n\n    /// @dev There are 3 types of accounting in the system: for non-borrowable collateral deposit called \"protected\",\n    ///      for borrowable collateral deposit called \"collateral\" and for borrowed tokens called \"debt\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum AssetType {\n        Protected, // default\n        Collateral,\n        Debt\n    }\n\n    /// @dev There are 2 types of accounting in the system: for non-borrowable collateral deposit called \"protected\" and\n    ///      for borrowable collateral deposit called \"collateral\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum CollateralType {\n        Protected, // default\n        Collateral\n    }\n\n    /// @dev Types of calls that can be made by the hook receiver on behalf of Silo via `callOnBehalfOfSilo` fn\n    enum CallType {\n        Call, // default\n        Delegatecall\n    }\n\n    /// @param _assets Amount of assets the user wishes to withdraw. Use 0 if shares are provided.\n    /// @param _shares Shares the user wishes to burn in exchange for the withdrawal. Use 0 if assets are provided.\n    /// @param _receiver Address receiving the withdrawn assets\n    /// @param _owner Address of the owner of the shares being burned\n    /// @param _spender Address executing the withdrawal; may be different than `_owner` if an allowance was set\n    /// @param _collateralType Type of the asset being withdrawn (Collateral or Protected)\n    struct WithdrawArgs {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        ISilo.CollateralType collateralType;\n    }\n\n    /// @param assets Number of assets the borrower intends to borrow. Use 0 if shares are provided.\n    /// @param shares Number of shares corresponding to the assets that the borrower intends to borrow. Use 0 if\n    /// assets are provided.\n    /// @param receiver Address that will receive the borrowed assets\n    /// @param borrower The user who is borrowing the assets\n    struct BorrowArgs {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n    }\n\n    /// @param shares Amount of shares the user wishes to transit.\n    /// @param owner owner of the shares after transition.\n    /// @param transitionFrom type of collateral that will be transitioned.\n    struct TransitionCollateralArgs {\n        uint256 shares;\n        address owner;\n        ISilo.CollateralType transitionFrom;\n    }\n\n    struct UtilizationData {\n        /// @dev COLLATERAL: Amount of asset token that has been deposited to Silo plus interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        uint256 collateralAssets;\n        /// @dev DEBT: Amount of asset token that has been borrowed plus accrued interest.\n        uint256 debtAssets;\n        /// @dev timestamp of the last interest accrual\n        uint64 interestRateTimestamp;\n    }\n\n    /// @dev Interest and revenue may be rounded down to zero if the underlying token's decimal is low.\n    /// Because of that, we need to store fractions for further calculation to minimize losses.\n    struct Fractions {\n        /// @dev interest value that we could not convert to full token in 36 decimals, max value for it is 1e18.\n        /// this value was not yet apply as interest for borrowers\n        uint64 interest;\n        /// @dev revenue value that we could not convert to full token in 36 decimals, max value for it is 1e18.\n        uint64 revenue;\n    }\n\n    struct SiloStorage {\n        /// @param daoAndDeployerRevenue Current amount of assets (fees) accrued by DAO and Deployer\n        /// but not yet withdrawn\n        uint192 daoAndDeployerRevenue;\n        /// @dev timestamp of the last interest accrual\n        uint64 interestRateTimestamp;\n        /// @dev Interest and revenue fractions for more precise calculations\n        Fractions fractions;\n\n        /// @dev silo is just for one asset,\n        /// but this one asset can be of three types: mapping key is uint256(AssetType), so we store `assets` by type.\n        /// Assets based on type:\n        /// - PROTECTED COLLATERAL: Amount of asset token that has been deposited to Silo that can be ONLY used\n        /// as collateral. These deposits do NOT earn interest and CANNOT be borrowed.\n        /// - COLLATERAL: Amount of asset token that has been deposited to Silo plus interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        /// - DEBT: Amount of asset token that has been borrowed plus accrued interest.\n        /// `totalAssets` can have outdated value (without interest), if you doing view call (of off-chain call)\n        /// please use getters eg `getCollateralAssets()` to fetch value that includes interest.\n        mapping(AssetType assetType => uint256 assets) totalAssets;\n    }\n\n    /// @notice Emitted on protected deposit\n    /// @param sender wallet address that deposited asset\n    /// @param owner wallet address that received shares in Silo\n    /// @param assets amount of asset that was deposited\n    /// @param shares amount of shares that was minted\n    event DepositProtected(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @notice Emitted on protected withdraw\n    /// @param sender wallet address that sent transaction\n    /// @param receiver wallet address that received asset\n    /// @param owner wallet address that owned asset\n    /// @param assets amount of asset that was withdrew\n    /// @param shares amount of shares that was burn\n    event WithdrawProtected(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Emitted on borrow\n    /// @param sender wallet address that sent transaction\n    /// @param receiver wallet address that received asset\n    /// @param owner wallet address that owes assets\n    /// @param assets amount of asset that was borrowed\n    /// @param shares amount of shares that was minted\n    event Borrow(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Emitted on repayment\n    /// @param sender wallet address that repaid asset\n    /// @param owner wallet address that owed asset\n    /// @param assets amount of asset that was repaid\n    /// @param shares amount of shares that was burn\n    event Repay(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @notice emitted only when collateral has been switched to other one\n    event CollateralTypeChanged(address indexed borrower);\n\n    event HooksUpdated(uint24 hooksBefore, uint24 hooksAfter);\n\n    event AccruedInterest(uint256 hooksBefore);\n\n    event FlashLoan(uint256 amount);\n\n    event WithdrawnFees(uint256 daoFees, uint256 deployerFees, bool redirectedDeployerFees);\n\n    event DeployerFeesRedirected(uint256 deployerFees);\n\n    error UnsupportedFlashloanToken();\n    error FlashloanAmountTooBig();\n    error NothingToWithdraw();\n    error ProtectedProtection();\n    error NotEnoughLiquidity();\n    error NotSolvent();\n    error BorrowNotPossible();\n    error EarnedZero();\n    error FlashloanFailed();\n    error AboveMaxLtv();\n    error SiloInitialized();\n    error OnlyHookReceiver();\n    error NoLiquidity();\n    error InputCanBeAssetsOrShares();\n    error CollateralSiloAlreadySet();\n    error RepayTooHigh();\n    error ZeroAmount();\n    error InputZeroShares();\n    error ReturnZeroAssets();\n    error ReturnZeroShares();\n    error Deprecated();\n\n    /// @return siloFactory The associated factory of the silo\n    function factory() external view returns (ISiloFactory siloFactory);\n\n    /// @notice Method for HookReceiver only to call on behalf of Silo\n    /// @param _target address of the contract to call\n    /// @param _value amount of ETH to send\n    /// @param _callType type of the call (Call or Delegatecall)\n    /// @param _input calldata for the call\n    function callOnBehalfOfSilo(address _target, uint256 _value, CallType _callType, bytes calldata _input)\n        external\n        payable\n        returns (bool success, bytes memory result);\n\n    /// @notice Initialize Silo\n    /// @param _siloConfig address of ISiloConfig with full config for this Silo\n    function initialize(ISiloConfig _siloConfig) external;\n\n    /// @notice Update hooks configuration for Silo\n    /// @dev This function must be called after the hooks configuration is changed in the hook receiver\n    function updateHooks() external;\n\n    /// @notice Fetches the silo configuration contract\n    /// @return siloConfig Address of the configuration contract associated with the silo\n    function config() external view returns (ISiloConfig siloConfig);\n\n    /// @notice Fetches the utilization data of the silo used by IRM\n    function utilizationData() external view returns (UtilizationData memory utilizationData);\n\n    /// @notice Fetches the real (available to borrow) liquidity in the silo, it does include interest\n    /// @return liquidity The amount of liquidity\n    function getLiquidity() external view returns (uint256 liquidity);\n\n    /// @notice Determines if a borrower is solvent\n    /// @param _borrower Address of the borrower to check for solvency\n    /// @return True if the borrower is solvent, otherwise false\n    function isSolvent(address _borrower) external view returns (bool);\n\n    /// @notice Retrieves the raw total amount of assets based on provided type (direct storage access)\n    function getTotalAssetsStorage(AssetType _assetType) external view returns (uint256);\n\n    /// @notice Direct storage access to silo storage\n    /// @dev See struct `SiloStorage` for more details\n    function getSiloStorage()\n        external\n        view\n        returns (\n            uint192 daoAndDeployerRevenue,\n            uint64 interestRateTimestamp,\n            uint256 protectedAssets,\n            uint256 collateralAssets,\n            uint256 debtAssets\n        );\n\n    /// @notice Direct access to silo storage fractions variables\n    function getFractionsStorage() external view returns (Fractions memory fractions);\n\n    /// @notice Retrieves the total amount of collateral (borrowable) assets with interest\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    function getCollateralAssets() external view returns (uint256 totalCollateralAssets);\n\n    /// @notice Retrieves the total amount of debt assets with interest\n    /// @return totalDebtAssets The total amount of assets of type 'Debt'\n    function getDebtAssets() external view returns (uint256 totalDebtAssets);\n\n    /// @notice Retrieves the total amounts of collateral and protected (non-borrowable) assets\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    /// @return totalProtectedAssets The total amount of protected (non-borrowable) assets\n    function getCollateralAndProtectedTotalsStorage()\n        external\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalProtectedAssets);\n\n    /// @notice Retrieves the total amounts of collateral and debt assets\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    /// @return totalDebtAssets The total amount of debt assets of type 'Debt'\n    function getCollateralAndDebtTotalsStorage()\n        external\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalDebtAssets);\n\n    /// @notice Implements IERC4626.convertToShares for each asset type\n    function convertToShares(uint256 _assets, AssetType _assetType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.convertToAssets for each asset type\n    function convertToAssets(uint256 _shares, AssetType _assetType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.previewDeposit for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewDeposit(uint256 _assets, CollateralType _collateralType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.deposit for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function deposit(uint256 _assets, address _receiver, CollateralType _collateralType)\n        external\n        returns (uint256 shares);\n\n    /// @notice Implements IERC4626.previewMint for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewMint(uint256 _shares, CollateralType _collateralType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.mint for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function mint(uint256 _shares, address _receiver, CollateralType _collateralType) external returns (uint256 assets);\n\n    /// @notice Implements IERC4626.maxWithdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function maxWithdraw(address _owner, CollateralType _collateralType) external view returns (uint256 maxAssets);\n\n    /// @notice Implements IERC4626.previewWithdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewWithdraw(uint256 _assets, CollateralType _collateralType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.withdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function withdraw(uint256 _assets, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        returns (uint256 shares);\n\n    /// @notice Implements IERC4626.maxRedeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function maxRedeem(address _owner, CollateralType _collateralType) external view returns (uint256 maxShares);\n\n    /// @notice Implements IERC4626.previewRedeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewRedeem(uint256 _shares, CollateralType _collateralType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.redeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function redeem(uint256 _shares, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        returns (uint256 assets);\n\n    /// @notice Calculates the maximum amount of assets that can be borrowed by the given address\n    /// @param _borrower Address of the potential borrower\n    /// @return maxAssets Maximum amount of assets that the borrower can borrow, this value is underestimated\n    /// That means, in some cases when you borrow maxAssets, you will be able to borrow again eg. up to 2wei\n    /// Reason for underestimation is to return value that will not cause borrow revert\n    function maxBorrow(address _borrower) external view returns (uint256 maxAssets);\n\n    /// @notice Previews the amount of shares equivalent to the given asset amount for borrowing\n    /// @param _assets Amount of assets to preview the equivalent shares for\n    /// @return shares Amount of shares equivalent to the provided asset amount\n    function previewBorrow(uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Allows an address to borrow a specified amount of assets\n    /// @param _assets Amount of assets to borrow\n    /// @param _receiver Address receiving the borrowed assets\n    /// @param _borrower Address responsible for the borrowed assets\n    /// @return shares Amount of shares equivalent to the borrowed assets\n    function borrow(uint256 _assets, address _receiver, address _borrower)\n        external returns (uint256 shares);\n\n    /// @notice Calculates the maximum amount of shares that can be borrowed by the given address\n    /// @param _borrower Address of the potential borrower\n    /// @return maxShares Maximum number of shares that the borrower can borrow\n    function maxBorrowShares(address _borrower) external view returns (uint256 maxShares);\n\n    /// @notice Previews the amount of assets equivalent to the given share amount for borrowing\n    /// @param _shares Amount of shares to preview the equivalent assets for\n    /// @return assets Amount of assets equivalent to the provided share amount\n    function previewBorrowShares(uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice deprecated\n    function maxBorrowSameAsset(address _borrower) external view returns (uint256 maxAssets);\n\n    /// @notice deprecated\n    function borrowSameAsset(uint256 _assets, address _receiver, address _borrower)\n        external returns (uint256 shares);\n\n    /// @notice Allows a user to borrow assets based on the provided share amount\n    /// @param _shares Amount of shares to borrow against\n    /// @param _receiver Address to receive the borrowed assets\n    /// @param _borrower Address responsible for the borrowed assets\n    /// @return assets Amount of assets borrowed\n    function borrowShares(uint256 _shares, address _receiver, address _borrower)\n        external\n        returns (uint256 assets);\n\n    /// @notice Calculates the maximum amount an address can repay based on their debt shares\n    /// @param _borrower Address of the borrower\n    /// @return assets Maximum amount of assets the borrower can repay\n    function maxRepay(address _borrower) external view returns (uint256 assets);\n\n    /// @notice Provides an estimation of the number of shares equivalent to a given asset amount for repayment\n    /// @param _assets Amount of assets to be repaid\n    /// @return shares Estimated number of shares equivalent to the provided asset amount\n    function previewRepay(uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Repays a given asset amount and returns the equivalent number of shares\n    /// @param _assets Amount of assets to be repaid\n    /// @param _borrower Address of the borrower whose debt is being repaid\n    /// @return shares The equivalent number of shares for the provided asset amount\n    function repay(uint256 _assets, address _borrower) external returns (uint256 shares);\n\n    /// @notice Calculates the maximum number of shares that can be repaid for a given borrower\n    /// @param _borrower Address of the borrower\n    /// @return shares The maximum number of shares that can be repaid for the borrower\n    function maxRepayShares(address _borrower) external view returns (uint256 shares);\n\n    /// @notice Provides a preview of the equivalent assets for a given number of shares to repay\n    /// @param _shares Number of shares to preview repayment for\n    /// @return assets Equivalent assets for the provided shares\n    function previewRepayShares(uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice Allows a user to repay a loan using shares instead of assets\n    /// @param _shares The number of shares the borrower wants to repay with\n    /// @param _borrower The address of the borrower for whom to repay the loan\n    /// @return assets The equivalent assets amount for the provided shares\n    function repayShares(uint256 _shares, address _borrower) external returns (uint256 assets);\n\n    /// @notice Transitions assets between borrowable (collateral) and non-borrowable (protected) states\n    /// @dev This function allows assets to move between collateral and protected (non-borrowable) states without\n    /// leaving the protocol\n    /// @param _shares Amount of shares to be transitioned\n    /// @param _owner Owner of the assets being transitioned\n    /// @param _transitionFrom Specifies if the transition is from collateral or protected assets\n    /// @return assets Amount of assets transitioned\n    function transitionCollateral(uint256 _shares, address _owner, CollateralType _transitionFrom)\n        external\n        returns (uint256 assets);\n\n    /// @notice deprecated\n    function switchCollateralToThisSilo() external;\n\n    /// @notice Accrues interest for the asset and returns the accrued interest amount\n    /// @return accruedInterest The total interest accrued during this operation\n    function accrueInterest() external returns (uint256 accruedInterest);\n\n    /// @notice only for SiloConfig\n    function accrueInterestForConfig(\n        address _interestRateModel,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    ) external;\n\n    /// @notice Withdraws earned fees and distributes them to the DAO and deployer fee receivers\n    function withdrawFees() external;\n}\n"
    },
    "silo-core/contracts/interfaces/IVersioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IVersioned {\n    /// @notice Returns the version of the contract\n    /// @return version The version of the contract in format \"SiloLens v3.17.0\"\n    function VERSION() external pure returns (string memory version); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "silo-core/contracts/interestRateModel/kink/DynamicKinkModelConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IDynamicKinkModelConfig} from \"../../interfaces/IDynamicKinkModelConfig.sol\";\nimport {IDynamicKinkModel} from \"../../interfaces/IDynamicKinkModel.sol\";\n\n/// @title InterestRateModelV2Config\n/// @notice Please never deploy config manually, always use factory, because factory does necessary checks.\ncontract DynamicKinkModelConfig is IDynamicKinkModelConfig {\n    int256 internal immutable _ULOW;\n    int256 internal immutable _U1;\n    int256 internal immutable _U2;\n    int256 internal immutable _UCRIT;\n    int256 internal immutable _RMIN;\n    int96 internal immutable _KMIN;\n    int96 internal immutable _KMAX;\n    int256 internal immutable _ALPHA;\n    int256 internal immutable _CMINUS;\n    int256 internal immutable _CPLUS;\n    int256 internal immutable _C1;\n    int256 internal immutable _C2;\n    int256 internal immutable _DMAX;\n\n    uint32 internal immutable _TIMELOCK;\n    int96 internal immutable _RCOMP_CAP_PER_SECOND;\n\n    constructor(IDynamicKinkModel.Config memory _config, IDynamicKinkModel.ImmutableConfig memory _immutableConfig) {\n        _ULOW = _config.ulow;\n        _U1 = _config.u1;\n        _U2 = _config.u2;\n        _UCRIT = _config.ucrit;\n        _RMIN = _config.rmin;\n        _KMIN = _config.kmin;\n        _KMAX = _config.kmax;\n        _ALPHA = _config.alpha;\n        _CMINUS = _config.cminus;\n        _CPLUS = _config.cplus;\n        _C1 = _config.c1;\n        _C2 = _config.c2;\n        _DMAX = _config.dmax;\n\n        _TIMELOCK = _immutableConfig.timelock;\n        _RCOMP_CAP_PER_SECOND = _immutableConfig.rcompCapPerSecond;\n    }\n\n    /// @inheritdoc IDynamicKinkModelConfig\n    function getConfig()\n        external\n        view\n        virtual\n        returns (IDynamicKinkModel.Config memory config, IDynamicKinkModel.ImmutableConfig memory immutableConfig)\n    {\n        config.ulow = _ULOW;\n        config.u1 = _U1;\n        config.u2 = _U2;\n        config.ucrit = _UCRIT;\n        config.rmin = _RMIN;\n        config.kmin = _KMIN;\n        config.kmax = _KMAX;\n        config.alpha = _ALPHA;\n        config.cminus = _CMINUS;\n        config.cplus = _CPLUS;\n        config.c1 = _C1;\n        config.c2 = _C2;\n        config.dmax = _DMAX;\n\n        immutableConfig.timelock = _TIMELOCK;\n        immutableConfig.rcompCapPerSecond = _RCOMP_CAP_PER_SECOND;\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloMathLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n// solhint-disable ordering\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\nimport {Rounding} from \"../lib/Rounding.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\n\nlibrary SiloMathLib {\n    using Math for uint256;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    uint256 internal constant _DECIMALS_OFFSET = 3;\n\n    /// @dev this is constant version of openzeppelin5/contracts/token/ERC20/extensions/ERC4626._decimalsOffset\n    uint256 internal constant _DECIMALS_OFFSET_POW = 10 ** _DECIMALS_OFFSET;\n\n    /// @notice Returns available liquidity to be borrowed\n    /// @dev Accrued interest is entirely added to `debtAssets` but only part of it is added to `collateralAssets`. The\n    ///      difference is DAO's and deployer's cut. That means DAO's and deployer's cut is not considered a borrowable\n    ///      liquidity.\n    function liquidity(uint256 _collateralAssets, uint256 _debtAssets) internal pure returns (uint256 liquidAssets) {\n        unchecked {\n            // we checked the underflow\n            liquidAssets = _debtAssets > _collateralAssets ? 0 : _collateralAssets - _debtAssets;\n        }\n    }\n\n    /// @notice Calculate collateral assets with accrued interest and associated fees\n    /// @param _collateralAssets The total amount of collateral assets\n    /// @param _debtAssets The total amount of debt assets\n    /// @param _rcomp Compound interest rate for debt\n    /// @param _daoFee The fee (in 18 decimals points) to be taken for the DAO\n    /// @param _deployerFee The fee (in 18 decimals points) to be taken for the deployer\n    /// @return collateralAssetsWithInterest The total collateral assets including the accrued interest\n    /// @return debtAssetsWithInterest The debt assets with accrued interest\n    /// @return daoAndDeployerRevenue Total fees amount to be split between DAO and deployer\n    /// @return accruedInterest The total accrued interest\n    function getCollateralAmountsWithInterest(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _rcomp,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    )\n        internal\n        pure\n        returns (\n            uint256 collateralAssetsWithInterest,\n            uint256 debtAssetsWithInterest,\n            uint256 daoAndDeployerRevenue,\n            uint256 accruedInterest\n        )\n    {\n        (debtAssetsWithInterest, accruedInterest) = getDebtAmountsWithInterest(_debtAssets, _rcomp);\n\n        uint256 fees;\n\n        // _daoFee and _deployerFee are expected to be less than 1e18, so we will not overflow\n        unchecked { fees = _daoFee + _deployerFee; }\n\n        daoAndDeployerRevenue = mulDivOverflow(accruedInterest, fees, _PRECISION_DECIMALS);\n\n        // we will not underflow because daoAndDeployerRevenue is chunk of accruedInterest\n        uint256 collateralInterest = accruedInterest - daoAndDeployerRevenue;\n\n        uint256 cap;\n        // save to uncheck because variable can not be more than max\n        unchecked { cap = type(uint256).max - _collateralAssets; }\n\n        if (cap < collateralInterest) {\n            // avoid overflow on interest\n            collateralInterest = cap;\n        }\n\n        // safe to uncheck because of cap\n        unchecked {  collateralAssetsWithInterest = _collateralAssets + collateralInterest; }\n    }\n\n    /// @notice Calculate the debt assets with accrued interest, it should never revert with over/under flow\n    /// @param _totalDebtAssets The total amount of debt assets before accrued interest\n    /// @param _rcomp Compound interest rate for the debt in 18 decimal precision\n    /// @return debtAssetsWithInterest The debt assets including the accrued interest\n    /// @return accruedInterest The total amount of interest accrued on the debt assets\n    function getDebtAmountsWithInterest(uint256 _totalDebtAssets, uint256 _rcomp)\n        internal\n        pure\n        returns (uint256 debtAssetsWithInterest, uint256 accruedInterest)\n    {\n        if (_totalDebtAssets == 0 || _rcomp == 0) {\n            return (_totalDebtAssets, 0);\n        }\n\n        accruedInterest = mulDivOverflow(_totalDebtAssets, _rcomp, _PRECISION_DECIMALS);\n\n        unchecked {\n            // We intentionally allow overflow here, to prevent transaction revert due to interest calculation.\n            debtAssetsWithInterest = _totalDebtAssets + accruedInterest;\n\n            // If overflow occurs, we skip accruing interest.\n            if (debtAssetsWithInterest < _totalDebtAssets) {\n                debtAssetsWithInterest = _totalDebtAssets;\n                accruedInterest = 0;\n            }\n        }\n    }\n\n    /// @notice Calculates fraction between borrowed and deposited amount of tokens denominated in percentage\n    /// @dev It assumes `_dp` = 100%.\n    /// @param _dp decimal points used by model\n    /// @param _collateralAssets current total deposits for assets\n    /// @param _debtAssets current total borrows for assets\n    /// @return utilization value, capped to 100%\n    /// Limiting utilization ratio by 100% max will allows us to perform better interest rate computations\n    /// and should not affect any other part of protocol. It is possible to go over 100% only when bad debt.\n    function calculateUtilization(uint256 _dp, uint256 _collateralAssets, uint256 _debtAssets)\n        internal\n        pure\n        returns (uint256 utilization)\n    {\n        if (_collateralAssets == 0 || _debtAssets == 0 || _dp == 0) return 0;\n\n        /*\n            how to prevent overflow on: _debtAssets.mulDiv(_dp, _collateralAssets, Rounding.ACCRUED_INTEREST):\n            1. max > _debtAssets * _dp / _collateralAssets\n            2. max / _dp > _debtAssets / _collateralAssets\n        */\n        if (type(uint256).max / _dp > _debtAssets / _collateralAssets) {\n            utilization = _debtAssets.mulDiv(_dp, _collateralAssets, Rounding.ACCRUED_INTEREST);\n            // cap at 100%\n            if (utilization > _dp) utilization = _dp;\n        } else {\n            // we have overflow\n            utilization = _dp;\n        }\n    }\n\n    function convertToAssetsOrToShares(\n        uint256 _assets,\n        uint256 _shares,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _roundingToAssets,\n        Math.Rounding _roundingToShares,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 assets, uint256 shares) {\n        if (_assets == 0) {\n            require(_shares != 0, ISilo.InputZeroShares());\n            shares = _shares;\n            assets = convertToAssets(_shares, _totalAssets, _totalShares, _roundingToAssets, _assetType);\n            require(assets != 0, ISilo.ReturnZeroAssets());\n        } else if (_shares == 0) {\n            shares = convertToShares(_assets, _totalAssets, _totalShares, _roundingToShares, _assetType);\n            assets = _assets;\n            require(shares != 0, ISilo.ReturnZeroShares());\n        } else {\n            revert ISilo.InputCanBeAssetsOrShares();\n        }\n    }\n\n    /// @dev Math for collateral is exact copy of\n    ///      openzeppelin5/contracts/token/ERC20/extensions/ERC4626._convertToShares\n    function convertToShares(\n        uint256 _assets,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _rounding,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 shares) {\n        (uint256 totalShares, uint256 totalAssets) = _commonConvertTo(_totalAssets, _totalShares, _assetType);\n\n        // initially, in case of debt, if silo is empty we return shares==assets\n        // for collateral, this will never be the case, because we are adding `+1` and offset in `_commonConvertTo`\n        if (totalShares == 0) return _assets;\n\n        shares = _assets.mulDiv(totalShares, totalAssets, _rounding);\n    }\n\n    /// @dev Math for collateral is exact copy of\n    ///      openzeppelin5/contracts/token/ERC20/extensions/ERC4626._convertToAssets\n    function convertToAssets(\n        uint256 _shares,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _rounding,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 assets) {\n        (uint256 totalShares, uint256 totalAssets) = _commonConvertTo(_totalAssets, _totalShares, _assetType);\n\n        // initially, in case of debt, if silo is empty we return shares==assets\n        // for collateral, this will never be the case, because of `+1` in line above\n        if (totalShares == 0) return _shares;\n\n        assets = _shares.mulDiv(totalAssets, totalShares, _rounding);\n    }\n\n    /// @param _collateralMaxLtv maxLTV in 18 decimals that is set for debt asset\n    /// @param _sumOfBorrowerCollateralValue borrower total collateral value (including protected)\n    /// @param _borrowerDebtValue total value of borrower debt\n    /// @return maxBorrowValue max borrow value yet available for borrower\n    function calculateMaxBorrowValue(\n        uint256 _collateralMaxLtv,\n        uint256 _sumOfBorrowerCollateralValue,\n        uint256 _borrowerDebtValue\n    ) internal pure returns (uint256 maxBorrowValue) {\n        if (_sumOfBorrowerCollateralValue == 0) {\n            return 0;\n        }\n\n        uint256 maxDebtValue = _sumOfBorrowerCollateralValue.mulDiv(\n            _collateralMaxLtv, _PRECISION_DECIMALS, Rounding.MAX_BORROW_VALUE\n        );\n\n        unchecked {\n            // we will not underflow because we checking `maxDebtValue > _borrowerDebtValue`\n            maxBorrowValue = maxDebtValue > _borrowerDebtValue ? maxDebtValue - _borrowerDebtValue : 0;\n        }\n    }\n\n    /// @notice Calculate the maximum assets a borrower can withdraw without breaching the liquidation threshold\n    /// @param _sumOfCollateralsValue The combined value of collateral and protected assets of the borrower\n    /// @param _debtValue The total debt value of the borrower\n    /// @param _lt The liquidation threshold in 18 decimal points\n    /// @param _borrowerCollateralAssets The borrower's collateral assets before the withdrawal\n    /// @param _borrowerProtectedAssets The borrower's protected assets before the withdrawal\n    /// @return maxAssets The maximum assets the borrower can safely withdraw\n    function calculateMaxAssetsToWithdraw(\n        uint256 _sumOfCollateralsValue,\n        uint256 _debtValue,\n        uint256 _lt,\n        uint256 _borrowerCollateralAssets,\n        uint256 _borrowerProtectedAssets\n    ) internal pure returns (uint256 maxAssets) {\n        if (_sumOfCollateralsValue == 0) return 0;\n        if (_debtValue == 0) return _sumOfCollateralsValue;\n        if (_lt == 0) return 0;\n\n        // using Rounding.LT (up) to have highest collateralValue that we have to leave for user to stay solvent\n        uint256 minimumCollateralValue = _debtValue.mulDiv(_PRECISION_DECIMALS, _lt, Rounding.LTV);\n\n        // if we over LT, we can not withdraw\n        if (_sumOfCollateralsValue <= minimumCollateralValue) {\n            return 0;\n        }\n\n        uint256 spareCollateralValue;\n        // safe because we checked `if (_sumOfCollateralsValue <= minimumCollateralValue)`\n        unchecked { spareCollateralValue = _sumOfCollateralsValue - minimumCollateralValue; }\n\n        maxAssets = (_borrowerProtectedAssets + _borrowerCollateralAssets)\n                .mulDiv(spareCollateralValue, _sumOfCollateralsValue, Rounding.MAX_WITHDRAW_TO_ASSETS);\n    }\n\n    /// @notice Determines the maximum number of assets and corresponding shares a borrower can safely withdraw\n    /// @param _maxAssets The calculated limit on how many assets can be withdrawn without breaching the liquidation\n    /// threshold\n    /// @param _borrowerCollateralAssets Amount of collateral assets currently held by the borrower\n    /// @param _borrowerProtectedAssets Amount of protected assets currently held by the borrower\n    /// @param _collateralType Specifies whether the asset is of type Collateral or Protected\n    /// @param _totalAssets The entire quantity of assets available in the system for withdrawal\n    /// @param _assetTypeShareTokenTotalSupply Total supply of share tokens for the specified asset type\n    /// @param _liquidity Current liquidity in the system for the asset type\n    /// @return assets Maximum assets the borrower can withdraw\n    /// @return shares Corresponding number of shares for the derived `assets` amount\n    function maxWithdrawToAssetsAndShares(\n        uint256 _maxAssets,\n        uint256 _borrowerCollateralAssets,\n        uint256 _borrowerProtectedAssets,\n        ISilo.CollateralType _collateralType,\n        uint256 _totalAssets,\n        uint256 _assetTypeShareTokenTotalSupply,\n        uint256 _liquidity\n    ) internal pure returns (uint256 assets, uint256 shares) {\n        if (_maxAssets == 0) return (0, 0);\n        if (_assetTypeShareTokenTotalSupply == 0) return (0, 0);\n\n        if (_collateralType == ISilo.CollateralType.Collateral) {\n            assets = _maxAssets > _borrowerCollateralAssets ? _borrowerCollateralAssets : _maxAssets;\n\n            if (assets > _liquidity) {\n                assets = _liquidity;\n            }\n        } else {\n            assets = _maxAssets > _borrowerProtectedAssets ? _borrowerProtectedAssets : _maxAssets;\n        }\n\n        shares = SiloMathLib.convertToShares(\n            assets,\n            _totalAssets,\n            _assetTypeShareTokenTotalSupply,\n            Rounding.MAX_WITHDRAW_TO_SHARES,\n            ISilo.AssetType(uint256(_collateralType))\n        );\n    }\n\n    /// @dev executed `_a * _b / _c`, reverts on _c == 0\n    /// @return mulDivResult on overflow returns 0\n    function mulDivOverflow(uint256 _a, uint256 _b, uint256 _c)\n        internal\n        pure\n        returns (uint256 mulDivResult)\n    {\n        if (_a == 0) return (0);\n\n        unchecked {\n            // we have to uncheck to detect overflow\n            mulDivResult = _a * _b;\n            if (mulDivResult / _a != _b) return 0;\n\n            mulDivResult /= _c;\n        }\n    }\n\n    /// @dev Debt calculations should not lower the result. Debt is a liability so protocol should not take any for\n    /// itself. It should return actual result and round it up.\n    function _commonConvertTo(\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        ISilo.AssetType _assetType\n    ) private pure returns (uint256 totalShares, uint256 totalAssets) {\n        if (_totalShares == 0) {\n            // silo is empty and we have dust to redistribute: this can only happen when everyone exits silo\n            // this case can happen only for collateral, because for collateral we rounding in favorite of protocol\n            // by resetting totalAssets, the dust that we have will go to first depositor and we starts from clean state\n            _totalAssets = 0;\n        }\n\n            (totalShares, totalAssets) = _assetType == ISilo.AssetType.Debt\n                ? (_totalShares, _totalAssets)\n                : (_totalShares + _DECIMALS_OFFSET_POW, _totalAssets + 1);\n    }\n\n    /// @dev Calculates the fraction of a given total and percentage\n    /// @param _total The total value to calculate the fraction from\n    /// @param _percent The percentage to calculate the fraction from\n    /// @param _currentFraction The current fraction to add to the result\n    /// @return integral The integral part of the fraction\n    /// @return fraction The fractional part of the fraction\n    function calculateFraction(\n        uint256 _total,\n        uint256 _percent,\n        uint64 _currentFraction\n    ) internal pure returns (uint256 integral, uint64 fraction) {\n        if (_total == 0) {\n            return (0, _currentFraction);\n        }\n\n        unchecked {\n            // safe to unchecked because: _currentFraction if never more than max uint256, div is safe\n            if (type(uint256).max / _total < _percent) {\n                // when overflow, reset `_currentFraction ` to zero as part of circuit breaker\n                return (0, 0);\n            }\n\n            // `_total * _percent` safe to unchecked because we checked for overflow in above `if`\n            // `% _PRECISION_DECIMALS` safe, because max value after modulo will be 1e18 - 1  (_PRECISION_DECIMALS - 1)\n            // and this is less than 2 ** 64\n            // calculate remainder for current interest\n            uint256 remainder = (_total * _percent) % _PRECISION_DECIMALS;\n            // integral is amount above 1e18 after adding _currentFraction and remainder\n            integral = (_currentFraction + remainder) / _PRECISION_DECIMALS;\n            // fraction is what we get below 1e18\n            fraction = uint64((_currentFraction + remainder) % _PRECISION_DECIMALS);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "silo-core/contracts/lib/PRBMathCommon.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.28;\n\n/* solhint-disable */\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n// representation. When it does not, it is annotated in the function's NatSpec documentation.\n/// @author Paul Razvan Berg\nlibrary PRBMathCommon {\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant _SCALE = 1e18;\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Uses 128.128-bit fixed-point numbers - it is the most efficient way.\n    /// @param x The exponent as an unsigned 128.128-bit fixed-point number.\n    /// @return result The result as an unsigned 60x18 decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 128.128-bit fixed-point format. We need to use uint256 because the intermediary\n            // may get very close to 2^256, which doesn't fit in int256.\n            result = 0x80000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at debt i is 1. None of the intermediary results overflows\n            // because the initial result is 2^127 and all magic factors are less than 2^129.\n            if (x & 0x80000000000000000000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\n            if (x & 0x40000000000000000000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDED) >> 128;\n            if (x & 0x20000000000000000000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A7920) >> 128;\n            if (x & 0x10000000000000000000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98364) >> 128;\n            if (x & 0x8000000000000000000000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FE) >> 128;\n            if (x & 0x4000000000000000000000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE9) >> 128;\n            if (x & 0x2000000000000000000000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA40) >> 128;\n            if (x & 0x1000000000000000000000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9544) >> 128;\n            if (x & 0x800000000000000000000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679C) >> 128;\n            if (x & 0x400000000000000000000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A011) >> 128;\n            if (x & 0x200000000000000000000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5E0) >> 128;\n            if (x & 0x100000000000000000000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939726) >> 128;\n            if (x & 0x80000000000000000000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3E) >> 128;\n            if (x & 0x40000000000000000000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B4) >> 128;\n            if (x & 0x20000000000000000000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292027) >> 128;\n            if (x & 0x10000000000000000000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FD) >> 128;\n            if (x & 0x8000000000000000000000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAC) >> 128;\n            if (x & 0x4000000000000000000000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7CA) >> 128;\n            if (x & 0x2000000000000000000000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\n            if (x & 0x1000000000000000000000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\n            if (x & 0x800000000000000000000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1629) >> 128;\n            if (x & 0x400000000000000000000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2C) >> 128;\n            if (x & 0x200000000000000000000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A6) >> 128;\n            if (x & 0x100000000000000000000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFF) >> 128;\n            if (x & 0x80000000000000000000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2F0) >> 128;\n            if (x & 0x40000000000000000000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737B) >> 128;\n            if (x & 0x20000000000000000000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F07) >> 128;\n            if (x & 0x10000000000000000000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44FA) >> 128;\n            if (x & 0x8000000000000000000000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC824) >> 128;\n            if (x & 0x4000000000000000000000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE51) >> 128;\n            if (x & 0x2000000000000000000000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFD0) >> 128;\n            if (x & 0x1000000000000000000000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\n            if (x & 0x800000000000000000000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AE) >> 128;\n            if (x & 0x400000000000000000000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CD) >> 128;\n            if (x & 0x200000000000000000000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\n            if (x & 0x100000000000000000000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AF) >> 128;\n            if (x & 0x80000000000000000000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCF) >> 128;\n            if (x & 0x40000000000000000000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0E) >> 128;\n            if (x & 0x20000000000000000000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\n            if (x & 0x10000000000000000000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94D) >> 128;\n            if (x & 0x8000000000000000000000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33E) >> 128;\n            if (x & 0x4000000000000000000000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26946) >> 128;\n            if (x & 0x2000000000000000000000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388D) >> 128;\n            if (x & 0x1000000000000000000000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D41) >> 128;\n            if (x & 0x800000000000000000000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDF) >> 128;\n            if (x & 0x400000000000000000000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77F) >> 128;\n            if (x & 0x200000000000000000000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C3) >> 128;\n            if (x & 0x100000000000000000000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E3) >> 128;\n            if (x & 0x80000000000000000000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F2) >> 128;\n            if (x & 0x40000000000000000000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA39) >> 128;\n            if (x & 0x20000000000000000000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\n            if (x & 0x10000000000000000000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\n            if (x & 0x8000000000000000000 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\n            if (x & 0x4000000000000000000 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\n            if (x & 0x2000000000000000000 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D92) >> 128;\n            if (x & 0x1000000000000000000 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\n            if (x & 0x800000000000000000 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE545) >> 128;\n            if (x & 0x400000000000000000 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\n            if (x & 0x200000000000000000 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\n            if (x & 0x100000000000000000 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\n            if (x & 0x80000000000000000 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6E) >> 128;\n            if (x & 0x40000000000000000 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B3) >> 128;\n            if (x & 0x20000000000000000 > 0) result = (result * 0x1000000000000000162E42FEFA39EF359) >> 128;\n            if (x & 0x10000000000000000 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AC) >> 128;\n\n            // Multiply the result by the integer part 2^n + 1. We have to shift by one bit extra because we have already divided\n            // by two when we set the result equal to 0.5 above.\n            result = result << ((x >> 128) + 1);\n\n            // Convert the result to the signed 60.18-decimal fixed-point format.\n            result = PRBMathCommon.mulDiv(result, 1e18, 2**128);\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2**256 and mod 2**256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256. Also prevents denominator == 0.\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2**256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2**256. Now that denominator is an odd number, it has an inverse modulo 2**256 such\n            // that denominator * inv = 1 mod 2**256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2**8\n            inverse *= 2 - denominator * inverse; // inverse mod 2**16\n            inverse *= 2 - denominator * inverse; // inverse mod 2**32\n            inverse *= 2 - denominator * inverse; // inverse mod 2**64\n            inverse *= 2 - denominator * inverse; // inverse mod 2**128\n            inverse *= 2 - denominator * inverse; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2**256. Since the preconditions guarantee that the outcome is\n            // less than 2**256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n}\n/* solhint-enable */\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "silo-core/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/// @notice https://eips.ethereum.org/EIPS/eip-3156\ninterface IERC3156FlashLender {\n    /// @notice Protected deposits are not available for a flash loan.\n    /// During the execution of the flashloan, Silo methods are not taking into consideration the fact,\n    /// that some (or all) tokens were transferred as flashloan, therefore some methods can return invalid state\n    /// eg. maxWithdraw can return amount that are not available to withdraw during flashlon.\n    /// @dev Initiate a flash loan.\n    /// @param _receiver The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)\n        external\n        returns (bool);\n\n    /// @dev The amount of currency available to be lent.\n    /// @param _token The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address _token) external view returns (uint256);\n\n    /// @dev The fee to be charged for a given loan.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address _token, uint256 _amount) external view returns (uint256);\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISilo} from \"./ISilo.sol\";\nimport {ICrossReentrancyGuard} from \"./ICrossReentrancyGuard.sol\";\n\ninterface ISiloConfig is ICrossReentrancyGuard {\n    struct InitData {\n        /// @notice Can be address zero if deployer fees are not to be collected. If deployer address is zero then\n        /// deployer fee must be zero as well. Deployer will be minted an NFT that gives the right to claim deployer\n        /// fees. NFT can be transferred with the right to claim.\n        address deployer;\n\n        /// @notice Address of the hook receiver called on every before/after action on Silo. Hook contract also\n        /// implements liquidation logic and veSilo gauge connection.\n        address hookReceiver;\n\n        /// @notice Deployer's fee in 18 decimals points. Deployer will earn this fee based on the interest earned\n        /// by the Silo. Max deployer fee is set by the DAO. At deployment it is 15%.\n        uint256 deployerFee;\n\n        /// @notice DAO's fee in 18 decimals points. DAO will earn this fee based on the interest earned\n        /// by the Silo. Acceptable fee range fee is set by the DAO. Default at deployment is 5% - 50%.\n        uint256 daoFee;\n\n        /// @notice Address of the first token\n        address token0;\n\n        /// @notice Address of the solvency oracle. Solvency oracle is used to calculate LTV when deciding if borrower\n        /// is solvent or should be liquidated. Solvency oracle is optional and if not set price of 1 will be assumed.\n        address solvencyOracle0;\n\n        /// @notice Address of the maxLtv oracle. Max LTV oracle is used to calculate LTV when deciding if borrower\n        /// can borrow given amount of assets. Max LTV oracle is optional and if not set it defaults to solvency\n        /// oracle. If neither is set price of 1 will be assumed.\n        address maxLtvOracle0;\n\n        /// @notice Address of the interest rate model\n        address interestRateModel0;\n\n        /// @notice Maximum LTV for first token. maxLTV is in 18 decimals points and is used to determine, if borrower\n        /// can borrow given amount of assets. MaxLtv is in 18 decimals points. MaxLtv must be lower or equal to LT.\n        uint256 maxLtv0;\n\n        /// @notice Liquidation threshold for first token. LT is used to calculate solvency. LT is in 18 decimals\n        /// points. LT must not be lower than maxLTV.\n        uint256 lt0;\n\n        /// @notice minimal acceptable LTV after liquidation, in 18 decimals points\n        uint256 liquidationTargetLtv0;\n\n        /// @notice Liquidation fee for the first token in 18 decimals points. Liquidation fee is what liquidator earns\n        /// for repaying insolvent loan.\n        uint256 liquidationFee0;\n\n        /// @notice Flashloan fee sets the cost of taking a flashloan in 18 decimals points\n        uint256 flashloanFee0;\n\n        /// @notice Indicates if a beforeQuote on oracle contract should be called before quoting price\n        bool callBeforeQuote0;\n\n        /// @notice Address of the second token\n        address token1;\n\n        /// @notice Address of the solvency oracle. Solvency oracle is used to calculate LTV when deciding if borrower\n        /// is solvent or should be liquidated. Solvency oracle is optional and if not set price of 1 will be assumed.\n        address solvencyOracle1;\n\n        /// @notice Address of the maxLtv oracle. Max LTV oracle is used to calculate LTV when deciding if borrower\n        /// can borrow given amount of assets. Max LTV oracle is optional and if not set it defaults to solvency\n        /// oracle. If neither is set price of 1 will be assumed.\n        address maxLtvOracle1;\n\n        /// @notice Address of the interest rate model\n        address interestRateModel1;\n\n        /// @notice Maximum LTV for first token. maxLTV is in 18 decimals points and is used to determine,\n        /// if borrower can borrow given amount of assets. maxLtv is in 18 decimals points\n        uint256 maxLtv1;\n\n        /// @notice Liquidation threshold for first token. LT is used to calculate solvency. LT is in 18 decimals points\n        uint256 lt1;\n\n        /// @notice minimal acceptable LTV after liquidation, in 18 decimals points\n        uint256 liquidationTargetLtv1;\n\n        /// @notice Liquidation fee is what liquidator earns for repaying insolvent loan.\n        uint256 liquidationFee1;\n\n        /// @notice Flashloan fee sets the cost of taking a flashloan in 18 decimals points\n        uint256 flashloanFee1;\n\n        /// @notice Indicates if a beforeQuote on oracle contract should be called before quoting price\n        bool callBeforeQuote1;\n    }\n\n    struct ConfigData {\n        uint256 daoFee;\n        uint256 deployerFee;\n        address silo;\n        address token;\n        address protectedShareToken;\n        address collateralShareToken;\n        address debtShareToken;\n        address solvencyOracle;\n        address maxLtvOracle;\n        address interestRateModel;\n        uint256 maxLtv;\n        uint256 lt;\n        uint256 liquidationTargetLtv;\n        uint256 liquidationFee;\n        uint256 flashloanFee;\n        address hookReceiver;\n        bool callBeforeQuote;\n    }\n\n    struct DepositConfig {\n        address silo;\n        address token;\n        address collateralShareToken;\n        address protectedShareToken;\n        uint256 daoFee;\n        uint256 deployerFee;\n        address interestRateModel;\n    }\n\n    error OnlySilo();\n    error OnlySiloOrTokenOrHookReceiver();\n    error WrongSilo();\n    error OnlyDebtShareToken();\n    error DebtExistInOtherSilo();\n    error FeeTooHigh();\n    error Deprecated();\n\n    /// @dev It should be called on debt transfer (debt share token transfer).\n    /// In the case if the`_recipient` doesn't have configured a collateral silo,\n    /// it will be set to the collateral silo of the `_sender`.\n    /// @param _sender sender address\n    /// @param _recipient recipient address\n    function onDebtTransfer(address _sender, address _recipient) external;\n\n    /// @notice deprecated\n    function setThisSiloAsCollateralSilo(address _borrower) external returns (bool collateralSiloChanged);\n\n    /// @notice Set collateral silo\n    /// @dev Revert if msg.sender is not a SILO_0 or SILO_1.\n    /// @dev Always set collateral silo opposite to the msg.sender.\n    /// @param _borrower borrower address\n    /// @return collateralSiloChanged TRUE if collateral silo changed\n    function setOtherSiloAsCollateralSilo(address _borrower) external returns (bool collateralSiloChanged);\n\n    /// @notice Accrue interest for the silo\n    /// @param _silo silo for which accrue interest\n    function accrueInterestForSilo(address _silo) external;\n\n    /// @notice Accrue interest for both silos (SILO_0 and SILO_1 in a config)\n    function accrueInterestForBothSilos() external;\n\n    /// @notice Retrieves the collateral silo for a specific borrower.\n    /// @dev As a user can deposit into `Silo0` and `Silo1`, this property specifies which Silo\n    /// will be used as collateral for the debt. Later on, it will be used for max LTV and solvency checks.\n    /// After being set, the collateral silo is never set to `address(0)` again but such getters as\n    /// `getConfigsForSolvency`, `getConfigsForBorrow`, `getConfigsForWithdraw` will return empty\n    /// collateral silo config if borrower doesn't have debt.\n    ///\n    /// In the SiloConfig collateral silo is set by the following functions:\n    /// `onDebtTransfer` - only if the recipient doesn't have collateral silo set (inherits it from the sender)\n    /// This function is called on debt share token transfer (debt transfer).\n    /// `setOtherSiloAsCollateralSilo` - sets the opposite silo as collateral from the one that calls the function.\n    ///\n    /// In the Silo collateral silo is set by the following functions:\n    /// `borrow` - always sets opposite silo as collateral.\n    /// If Silo0 borrows, then Silo1 will be collateral and vice versa.\n    /// @param _borrower The address of the borrower for which the collateral silo is being retrieved\n    /// @return collateralSilo The address of the collateral silo for the specified borrower\n    function borrowerCollateralSilo(address _borrower) external view returns (address collateralSilo);\n\n    /// @notice Retrieves the silo ID\n    /// @dev Each silo is assigned a unique ID. ERC-721 token is minted with identical ID to deployer.\n    /// An owner of that token receives the deployer fees.\n    /// @return siloId The ID of the silo\n    function SILO_ID() external view returns (uint256 siloId); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Retrieves the addresses of the two silos\n    /// @return silo0 The address of the first silo\n    /// @return silo1 The address of the second silo\n    function getSilos() external view returns (address silo0, address silo1);\n\n    /// @notice Retrieves the asset associated with a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which the associated asset is being retrieved\n    /// @return asset The address of the asset associated with the specified silo\n    function getAssetForSilo(address _silo) external view returns (address asset);\n\n    /// @notice Verifies if the borrower has debt in other silo by checking the debt share token balance\n    /// @param _thisSilo The address of the silo in respect of which the debt is checked\n    /// @param _borrower The address of the borrower for which the debt is checked\n    /// @return hasDebt true if the borrower has debt in other silo\n    function hasDebtInOtherSilo(address _thisSilo, address _borrower) external view returns (bool hasDebt);\n\n    /// @notice Retrieves the debt silo associated with a specific borrower\n    /// @dev This function reverts if debt present in two silo (should not happen)\n    /// @param _borrower The address of the borrower for which the debt silo is being retrieved\n    function getDebtSilo(address _borrower) external view returns (address debtSilo);\n\n    /// @notice Retrieves configuration data for both silos. First config is for the silo that is asking for configs.\n    /// @param borrower borrower address for which debtConfig will be returned\n    /// @return collateralConfig The configuration data for collateral silo (empty if there is no debt).\n    /// @return debtConfig The configuration data for debt silo (empty if there is no debt).\n    function getConfigsForSolvency(address borrower)\n        external\n        view\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig);\n\n    /// @notice Retrieves configuration data for a specific silo\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _silo The address of the silo for which configuration data is being retrieved\n    /// @return config The configuration data for the specified silo\n    function getConfig(address _silo) external view returns (ConfigData memory config);\n\n    /// @notice Retrieves configuration data for a specific silo for withdraw fn.\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _silo The address of the silo for which configuration data is being retrieved\n    /// @return depositConfig The configuration data for the specified silo (always config for `_silo`)\n    /// @return collateralConfig The configuration data for the collateral silo (empty if there is no debt)\n    /// @return debtConfig The configuration data for the debt silo (empty if there is no debt)\n    function getConfigsForWithdraw(address _silo, address _borrower) external view returns (\n        DepositConfig memory depositConfig,\n        ConfigData memory collateralConfig,\n        ConfigData memory debtConfig\n    );\n\n    /// @notice Retrieves configuration data for a specific silo for borrow fn.\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _debtSilo The address of the silo for which configuration data is being retrieved\n    /// @return collateralConfig The configuration data for the collateral silo (always other than `_debtSilo`)\n    /// @return debtConfig The configuration data for the debt silo (always config for `_debtSilo`)\n    function getConfigsForBorrow(address _debtSilo)\n        external\n        view\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig);\n\n    /// @notice Retrieves fee-related information for a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which fee-related information is being retrieved.\n    /// @return daoFee The DAO fee percentage in 18 decimals points.\n    /// @return deployerFee The deployer fee percentage in 18 decimals points.\n    /// @return flashloanFee The flashloan fee percentage in 18 decimals points.\n    /// @return asset The address of the asset associated with the specified silo.\n    function getFeesWithAsset(address _silo)\n        external\n        view\n        returns (uint256 daoFee, uint256 deployerFee, uint256 flashloanFee, address asset);\n\n    /// @notice Retrieves share tokens associated with a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which share tokens are being retrieved\n    /// @return protectedShareToken The address of the protected (non-borrowable) share token\n    /// @return collateralShareToken The address of the collateral share token\n    /// @return debtShareToken The address of the debt share token\n    function getShareTokens(address _silo)\n        external\n        view\n        returns (address protectedShareToken, address collateralShareToken, address debtShareToken);\n\n    /// @notice Retrieves the share token and the silo token associated with a specific silo\n    /// @param _silo The address of the silo for which the share token and silo token are being retrieved\n    /// @param _collateralType The type of collateral\n    /// @return shareToken The address of the share token (collateral or protected collateral)\n    /// @return asset The address of the silo token\n    function getCollateralShareTokenAndAsset(address _silo, ISilo.CollateralType _collateralType)\n        external\n        view\n        returns (address shareToken, address asset);\n\n    /// @notice Retrieves the share token and the silo token associated with a specific silo\n    /// @param _silo The address of the silo for which the share token and silo token are being retrieved\n    /// @return shareToken The address of the share token (debt)\n    /// @return asset The address of the silo token\n    function getDebtShareTokenAndAsset(address _silo)\n        external\n        view\n        returns (address shareToken, address asset);\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC721} from \"openzeppelin5/interfaces/IERC721.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\ninterface ISiloFactory is IERC721 {\n    struct Range {\n        uint128 min;\n        uint128 max;\n    }\n\n    /// @notice Emitted on the creation of a Silo.\n    /// @param implementation Address of the Silo implementation.\n    /// @param token0 Address of the first Silo token.\n    /// @param token1 Address of the second Silo token.\n    /// @param silo0 Address of the first Silo.\n    /// @param silo1 Address of the second Silo.\n    /// @param siloConfig Address of the SiloConfig.\n    event NewSilo(\n        address indexed implementation,\n        address indexed token0,\n        address indexed token1,\n        address silo0,\n        address silo1,\n        address siloConfig\n    );\n\n    /// @notice Emitted on the creation of a Silo, note that collateral share token == silo\n    event NewSiloShareTokens(\n        address indexed protectedShareToken, \n        address indexed collateralShareToken,\n        address indexed debtShareToken\n    );\n\n    event NewSiloHook(address indexed silo, address indexed hook);\n\n    event BaseURI(string newBaseURI);\n\n    /// @notice Emitted on the update of DAO fee.\n    /// @param minDaoFee Value of the new minimal DAO fee.\n    /// @param maxDaoFee Value of the new maximal DAO fee.\n    event DaoFeeChanged(uint128 minDaoFee, uint128 maxDaoFee);\n\n    /// @notice Emitted on the update of max deployer fee.\n    /// @param maxDeployerFee Value of the new max deployer fee.\n    event MaxDeployerFeeChanged(uint256 maxDeployerFee);\n\n    /// @notice Emitted on the update of max flashloan fee.\n    /// @param maxFlashloanFee Value of the new max flashloan fee.\n    event MaxFlashloanFeeChanged(uint256 maxFlashloanFee);\n\n    /// @notice Emitted on the update of max liquidation fee.\n    /// @param maxLiquidationFee Value of the new max liquidation fee.\n    event MaxLiquidationFeeChanged(uint256 maxLiquidationFee);\n\n    /// @notice Emitted on the change of DAO fee receiver.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChanged(address daoFeeReceiver);\n\n    /// @notice Emitted on the change of DAO fee receiver for particular silo\n    /// @param silo Address for which new DAO fee receiver is set.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChangedForSilo(address silo, address daoFeeReceiver);\n\n    /// @notice Emitted on the change of DAO fee receiver for particular asset\n    /// @param asset Address for which new DAO fee receiver is set.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChangedForAsset(address asset, address daoFeeReceiver);\n\n    error MissingHookReceiver();\n    error ZeroAddress();\n    error DaoFeeReceiverZeroAddress();\n    error SameDaoFeeReceiver();\n    error EmptyToken0();\n    error EmptyToken1();\n    error MaxFeeExceeded();\n    error InvalidFeeRange();\n    error SameAsset();\n    error SameRange();\n    error InvalidIrm();\n    error InvalidMaxLtv();\n    error InvalidLt();\n    error InvalidDeployer();\n    error DaoMinRangeExceeded();\n    error DaoMaxRangeExceeded();\n    error MaxDeployerFeeExceeded();\n    error MaxFlashloanFeeExceeded();\n    error MaxLiquidationFeeExceeded();\n    error InvalidCallBeforeQuote();\n    error OracleMisconfiguration();\n    error InvalidQuoteToken();\n    error HookIsZeroAddress();\n    error LiquidationTargetLtvTooHigh();\n    error NotYourSilo();\n    error ConfigMismatchSilo();\n    error ConfigMismatchShareProtectedToken();\n    error ConfigMismatchShareDebtToken();\n    error ConfigMismatchShareCollateralToken();\n\n    /// @notice Create a new Silo.\n    /// @param _siloConfig Silo configuration.\n    /// @param _siloImpl Address of the `Silo` implementation.\n    /// @param _shareProtectedCollateralTokenImpl Address of the `ShareProtectedCollateralToken` implementation.\n    /// @param _shareDebtTokenImpl Address of the `ShareDebtToken` implementation.\n    /// @param _deployer Address of the deployer.\n    /// @param _creator Address of the creator.\n    function createSilo(\n        ISiloConfig _siloConfig,\n        address _siloImpl,\n        address _shareProtectedCollateralTokenImpl,\n        address _shareDebtTokenImpl,\n        address _deployer,\n        address _creator\n    )\n        external;\n\n    /// @notice NFT ownership represents the deployer fee receiver for the each Silo ID.  After burning, \n    /// the deployer fee is sent to the DAO. Burning doesn't affect Silo's behavior. It is only about fee distribution.\n    /// @param _siloIdToBurn silo ID to burn.\n    function burn(uint256 _siloIdToBurn) external;\n\n    /// @notice Update the value of DAO fee. Updated value will be used only for a new Silos.\n    /// Previously deployed SiloConfigs are immutable.\n    /// @param _minFee Value of the new DAO minimal fee.\n    /// @param _maxFee Value of the new DAO maximal fee.\n    function setDaoFee(uint128 _minFee, uint128 _maxFee) external;\n\n    /// @notice Set the default DAO fee receiver.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiver(address _newDaoFeeReceiver) external;\n\n    /// @notice Set the new DAO fee receiver for asset, this setup will be used when fee receiver for silo is empty.\n    /// @param _asset Address for which new DAO fee receiver is set.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiverForAsset(address _asset, address _newDaoFeeReceiver) external;\n\n    /// @notice Set the new DAO fee receiver for silo. This setup has highest priority.\n    /// @param _silo Address for which new DAO fee receiver is set.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiverForSilo(address _silo, address _newDaoFeeReceiver) external;\n\n    /// @notice Update the value of max deployer fee. Updated value will be used only for a new Silos max deployer\n    /// fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxDeployerFee Value of the new max deployer fee.\n    function setMaxDeployerFee(uint256 _newMaxDeployerFee) external;\n\n    /// @notice Update the value of max flashloan fee. Updated value will be used only for a new Silos max flashloan\n    /// fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxFlashloanFee Value of the new max flashloan fee.\n    function setMaxFlashloanFee(uint256 _newMaxFlashloanFee) external;\n\n    /// @notice Update the value of max liquidation fee. Updated value will be used only for a new Silos max\n    /// liquidation fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxLiquidationFee Value of the new max liquidation fee.\n    function setMaxLiquidationFee(uint256 _newMaxLiquidationFee) external;\n   \n    /// @notice Update the base URI.\n    /// @param _newBaseURI Value of the new base URI.\n    function setBaseURI(string calldata _newBaseURI) external;\n\n    /// @notice Acceptable DAO fee range for new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function daoFeeRange() external view returns (Range memory);\n\n    /// @notice Max deployer fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxDeployerFee() external view returns (uint256);\n\n    /// @notice Max flashloan fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxFlashloanFee() external view returns (uint256);\n\n    /// @notice Max liquidation fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxLiquidationFee() external view returns (uint256);\n\n    /// @notice The recipient of DAO fees.\n    function daoFeeReceiver() external view returns (address);\n\n    /// @notice Get SiloConfig address by Silo id.\n    function idToSiloConfig(uint256 _id) external view returns (address);\n\n    /// @notice Get the counter of silos created by the wallet.\n    function creatorSiloCounter(address _creator) external view returns (uint256);\n\n    /// @notice Do not use this method to check if silo is secure. Anyone can deploy silo with any configuration\n    /// and implementation. Most critical part of verification would be to check who deployed it.\n    /// @dev True if the address was deployed using SiloFactory.\n    function isSilo(address _silo) external view returns (bool);\n\n    /// @notice Id of a next Silo to be deployed. This is an ID of non-existing Silo outside of createSilo\n    /// function call. ID of a first Silo is 1.\n    function getNextSiloId() external view returns (uint256);\n\n    /// @notice Get the DAO and deployer fee receivers for a particular Silo address.\n    /// @param _silo Silo address.\n    /// @return dao DAO fee receiver.\n    /// @return deployer Deployer fee receiver.\n    function getFeeReceivers(address _silo) external view returns (address dao, address deployer);\n\n    /// @notice Validate InitData for a new Silo. Config will be checked for the fee limits, missing parameters.\n    /// @param _initData Silo init data.\n    function validateSiloInitData(ISiloConfig.InitData memory _initData) external view returns (bool);\n}\n"
    },
    "silo-core/contracts/interfaces/IHookReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\ninterface IHookReceiver {\n    struct HookConfig {\n        uint24 hooksBefore;\n        uint24 hooksAfter;\n    }\n\n    event HookConfigured(address silo, uint24 hooksBefore, uint24 hooksAfter);\n\n    /// @dev Revert if provided silo configuration during initialization is empty\n    error EmptySiloConfig();\n    /// @dev Revert if the hook receiver is already configured/initialized\n    error AlreadyConfigured();\n    /// @dev Revert if the caller is not a silo\n    error OnlySilo();\n    /// @dev Revert if the caller is not a silo or a share token\n    error OnlySiloOrShareToken();\n\n    /// @notice Initialize a hook receiver\n    /// @param _siloConfig Silo configuration with all the details about the silo\n    /// @param _data Data to initialize the hook receiver (if needed)\n    function initialize(ISiloConfig _siloConfig, bytes calldata _data) external;\n\n    /// @notice state of Silo before action, can be also without interest, if you need them, call silo.accrueInterest()\n    function beforeAction(address _silo, uint256 _action, bytes calldata _input) external;\n\n    function afterAction(address _silo, uint256 _action, bytes calldata _inputAndOutput) external;\n\n    /// @notice return hooksBefore and hooksAfter configuration\n    function hookReceiverConfig(address _silo) external view returns (uint24 hooksBefore, uint24 hooksAfter);\n}\n"
    },
    "silo-core/contracts/lib/Rounding.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\n// solhint-disable private-vars-leading-underscore\nlibrary Rounding {\n    Math.Rounding internal constant UP = Math.Rounding.Ceil;\n    Math.Rounding internal constant DOWN = Math.Rounding.Floor;\n    Math.Rounding internal constant DEBT_TO_ASSETS = Math.Rounding.Ceil;\n    // COLLATERAL_TO_ASSETS is used to calculate borrower collateral (so we want to round down)\n    Math.Rounding internal constant COLLATERAL_TO_ASSETS = Math.Rounding.Floor;\n    // why DEPOSIT_TO_ASSETS is Up if COLLATERAL_TO_ASSETS is Down?\n    // DEPOSIT_TO_ASSETS is used for preview deposit and deposit, based on provided shares we want to pull \"more\" tokens\n    // so we rounding up, \"token flow\" is in different direction than for COLLATERAL_TO_ASSETS, that's why\n    // different rounding policy\n    Math.Rounding internal constant DEPOSIT_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant DEPOSIT_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant BORROW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant BORROW_TO_SHARES = Math.Rounding.Ceil;\n    Math.Rounding internal constant MAX_BORROW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_BORROW_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_BORROW_VALUE = Math.Rounding.Floor;\n    Math.Rounding internal constant REPAY_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant REPAY_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_REPAY_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant WITHDRAW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant WITHDRAW_TO_SHARES = Math.Rounding.Ceil;\n    Math.Rounding internal constant MAX_WITHDRAW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_WITHDRAW_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant LIQUIDATE_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant LTV = Math.Rounding.Ceil;\n    Math.Rounding internal constant ACCRUED_INTEREST = Math.Rounding.Floor;\n    Math.Rounding internal constant DAO_REVENUE = Math.Rounding.Ceil;\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "silo-core/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IERC3156FlashBorrower {\n    /// @notice During the execution of the flashloan, Silo methods are not taking into consideration the fact,\n    /// that some (or all) tokens were transferred as flashloan, therefore some methods can return invalid state\n    /// eg. maxWithdraw can return amount that are not available to withdraw during flashlon.\n    /// @dev Receive a flash loan.\n    /// @param _initiator The initiator of the loan.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _fee The additional amount of tokens to repay.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    /// @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n    function onFlashLoan(address _initiator, address _token, uint256 _amount, uint256 _fee, bytes calldata _data)\n        external\n        returns (bytes32);\n}\n"
    },
    "silo-core/contracts/interfaces/ICrossReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ICrossReentrancyGuard {\n    error CrossReentrantCall();\n    error CrossReentrancyNotActive();\n\n    /// @notice only silo method for cross Silo reentrancy\n    function turnOnReentrancyProtection() external;\n\n    /// @notice only silo method for cross Silo reentrancy\n    function turnOffReentrancyProtection() external;\n\n    /// @notice view method for checking cross Silo reentrancy flag\n    /// @return entered true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n    /// `nonReentrant` function in the call stack.\n    function reentrancyGuardEntered() external view returns (bool entered);\n}"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=gitmodules/forge-std/src/",
      "silo-foundry-utils/=gitmodules/silo-foundry-utils/contracts/",
      "properties/=gitmodules/crytic/properties/contracts/",
      "silo-core/=silo-core/",
      "silo-oracles/=silo-oracles/",
      "silo-vaults/=silo-vaults/",
      "@openzeppelin/=gitmodules/openzeppelin-contracts-5/",
      "morpho-blue/=gitmodules/morpho-blue/src/",
      "openzeppelin5/=gitmodules/openzeppelin-contracts-5/contracts/",
      "openzeppelin5-upgradeable/=gitmodules/openzeppelin-contracts-upgradeable-5/contracts/",
      "chainlink/=gitmodules/chainlink/contracts/src/",
      "chainlink-ccip/=gitmodules/chainlink-ccip/contracts/src/",
      "uniswap/=gitmodules/uniswap/",
      "@uniswap/v3-core/=gitmodules/uniswap/v3-core/",
      "pyth-sdk-solidity/=gitmodules/pyth-sdk-solidity/target_chains/ethereum/sdk/solidity/",
      "a16z-erc4626-tests/=gitmodules/a16z-erc4626-tests/",
      "@ensdomains/=node_modules/@ensdomains/",
      "@solidity-parser/=node_modules/prettier-plugin-solidity/node_modules/@solidity-parser/",
      "ERC4626/=gitmodules/crytic/properties/lib/ERC4626/contracts/",
      "createx/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/src/",
      "crytic/=gitmodules/crytic/",
      "ds-test/=gitmodules/openzeppelin-contracts-5/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=gitmodules/openzeppelin-contracts-5/lib/erc4626-tests/",
      "halmos-cheatcodes/=gitmodules/morpho-blue/lib/halmos-cheatcodes/src/",
      "hardhat/=node_modules/hardhat/",
      "openzeppelin-contracts-5/=gitmodules/openzeppelin-contracts-5/",
      "openzeppelin-contracts-upgradeable-5/=gitmodules/openzeppelin-contracts-upgradeable-5/",
      "openzeppelin-contracts-upgradeable/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/",
      "prettier-plugin-solidity/=node_modules/prettier-plugin-solidity/",
      "solady/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/lib/solady/",
      "solmate/=gitmodules/crytic/properties/lib/solmate/src/",
      "x-silo/=node_modules/x-silo/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false
  }
}