{
  "language": "Solidity",
  "sources": {
    "silo-core/contracts/utils/GlobalPause.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport {EnumerableSet} from \"openzeppelin5/utils/structs/EnumerableSet.sol\";\n\nimport {Ownable1and2Steps, Ownable2Step} from \"common/access/Ownable1and2Steps.sol\";\nimport {IPausable} from \"common/utils/interfaces/IPausable.sol\";\nimport {IGnosisSafeLike} from \"common/utils/interfaces/IGnosisSafeLike.sol\";\nimport {IGlobalPause} from \"common/utils/interfaces/IGlobalPause.sol\";\n\ncontract GlobalPause is Ownable1and2Steps, IGlobalPause {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice The list of contracts to pause and unpause\n    EnumerableSet.AddressSet private _contracts;\n\n    /// @notice The list of accounts who can pause and unpause contracts\n    EnumerableSet.AddressSet private _authorizedToPause;\n\n    /// @dev Modifier to check if the caller is a signer of the multisig contract or a manager\n    modifier onlyAuthorized() {\n        require(\n            isSigner(msg.sender) || _authorizedToPause.contains(msg.sender) || msg.sender == owner(),\n            Forbidden()\n        );\n        _;\n    }\n\n    /// @param _multisig The multisig contract which owners are allowed to pause and unpause contracts\n    constructor(address _multisig) Ownable1and2Steps(_multisig) {}\n\n    /// @inheritdoc IGlobalPause\n    function pauseAll() external onlyAuthorized {\n        uint256 length = _contracts.length();\n\n        for (uint256 i = 0; i < length; i++) {\n            _pause(_contracts.at(i));\n        }\n    }\n\n    /// @inheritdoc IGlobalPause\n    function unpauseAll() external onlyAuthorized {\n        uint256 length = _contracts.length();\n\n        for (uint256 i = 0; i < length; i++) {\n            _unpause(_contracts.at(i));\n        }\n    }\n\n    /// @inheritdoc IGlobalPause\n    function pause(address _contract) external onlyAuthorized {\n        _pause(_contract);\n    }\n\n    /// @inheritdoc IGlobalPause\n    function unpause(address _contract) external onlyAuthorized {\n        _unpause(_contract);\n    }\n\n    /// @inheritdoc IGlobalPause\n    function addContract(address _contract) external onlyAuthorized {\n        require(_contracts.add(_contract), FailedToAdd());\n        emit ContractAdded(_contract);\n    }\n\n    /// @inheritdoc IGlobalPause\n    function removeContract(address _contract) external onlyOwner {\n        require(_contracts.remove(_contract), FailedToRemove());\n        emit ContractRemoved(_contract);\n    }\n\n    /// @inheritdoc IGlobalPause\n    function grantAuthorization(address _account) external onlyOwner {\n        require(_authorizedToPause.add(_account), FailedToAdd());\n        emit Authorized(_account);\n    }\n\n    /// @inheritdoc IGlobalPause\n    function revokeAuthorization(address _account) external onlyOwner {\n        require(_authorizedToPause.remove(_account), FailedToRemove());\n        emit Unauthorized(_account);\n    }\n\n    /// @inheritdoc IGlobalPause\n    function acceptOwnership(address _contract) external onlyAuthorized {\n        Ownable2Step(_contract).acceptOwnership();\n        emit OwnershipAccepted(_contract);\n    }\n\n    /// @inheritdoc IGlobalPause\n    function transferOwnershipFrom(address _contract, address _newOwner) external onlyOwner {\n        Ownable2Step(_contract).transferOwnership(_newOwner);\n        emit OwnershipTransferStarted(_contract, _newOwner);\n    }\n\n    /// @inheritdoc IGlobalPause\n    function allContracts() external view returns (address[] memory) {\n        return _contracts.values();\n    }\n\n    /// @inheritdoc IGlobalPause\n    function authorizedToPause() external view returns (address[] memory) {\n        return _authorizedToPause.values();\n    }\n\n    /// @notice Renounce ownership of the contract and ensure that _contracts and _authorizedToPause are empty\n    function renounceOwnership() public virtual override {\n        require(_contracts.length() == 0, ContractsNotEmpty());\n        require(_authorizedToPause.length() == 0, AuthorizedToPauseNotEmpty());\n\n        super.renounceOwnership();\n    }\n\n    /// @inheritdoc IGlobalPause\n    function isSigner(address _account) public view returns (bool result) {\n        address[] memory signers = IGnosisSafeLike(owner()).getOwners();\n\n        for (uint256 i = 0; i < signers.length; i++) {\n            if (signers[i] == _account) {\n                return true;\n            }\n        }\n    }\n\n    /// @inheritdoc IGlobalPause\n    function getAllContractsPauseStatus() external view returns (ContractPauseStatus[] memory result) {\n        uint256 length = _contracts.length();\n        result = new ContractPauseStatus[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            address contractAddress = _contracts.at(i);\n            bool isPaused = IPausable(contractAddress).paused();\n\n            result[i] = ContractPauseStatus({contractAddress: contractAddress, isPaused: isPaused});\n        }\n    }\n\n    /// @dev Pause a contract\n    /// @param _contract The contract to pause\n    function _pause(address _contract) internal {\n        // Using try/catch to avoid blockage of the `pauseAll` fn\n        // in case contract permissions were revoked and contract was not removed.\n        try IPausable(_contract).pause() {\n            emit Paused(_contract);\n        } catch {\n            emit FailedToPause(_contract);\n        }\n    }\n\n    /// @dev Unpause a contract\n    /// @param _contract The contract to unpause\n    function _unpause(address _contract) internal {\n        // Using try/catch to avoid blockage of the `unpauseAll` fn\n        try IPausable(_contract).unpause() {\n            emit Unpaused(_contract);\n        } catch {\n            emit FailedToUnpause(_contract);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "common/access/Ownable1and2Steps.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {Ownable2Step, Ownable} from \"openzeppelin5/access/Ownable2Step.sol\";\n\n/// @dev This contract is a wrapper around Ownable2Step that allows for 1-step ownership transfer\nabstract contract Ownable1and2Steps is Ownable2Step {\n    constructor(address _initialOwner) Ownable(_initialOwner) {}\n\n    /// @notice Transfer ownership to a new address. Pending ownership transfer will be canceled.\n    /// @param newOwner The new owner of the contract\n    function transferOwnership1Step(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n\n        Ownable2Step._transferOwnership(newOwner);\n    }\n}\n"
    },
    "common/utils/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ninterface IPausable {\n    function pause() external;\n    function unpause() external;\n    function paused() external view returns (bool);\n}\n"
    },
    "common/utils/interfaces/IGnosisSafeLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ninterface IGnosisSafeLike {\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "common/utils/interfaces/IGlobalPause.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ninterface IGlobalPause {\n    struct ContractPauseStatus {\n        address contractAddress;\n        bool isPaused;\n    }\n\n    event Paused(address _contract);\n    event Unpaused(address _contract);\n    event OwnershipAccepted(address _contract);\n    event ContractAdded(address _contract);\n    event ContractRemoved(address _contract);\n    event Authorized(address _account);\n    event Unauthorized(address _account);\n    event FailedToPause(address _contract);\n    event FailedToUnpause(address _contract);\n\n    error Forbidden();\n    error ContractsNotEmpty();\n    error AuthorizedToPauseNotEmpty();\n    error FailedToAdd();\n    error FailedToRemove();\n\n    /// @notice Pause all contracts\n    function pauseAll() external;\n\n    /// @notice Unpause all contracts\n    function unpauseAll() external;\n\n    /// @notice Add a contract to the list of contracts to pause and unpause\n    /// @param _contract The contract to add\n    function addContract(address _contract) external;\n\n    /// @notice Remove a contract from the list of contracts to pause and unpause\n    /// @param _contract The contract to remove\n    function removeContract(address _contract) external;\n\n    /// @notice Grant authorization to an account to pause and unpause contracts\n    /// @param _account The account to grant authorization to\n    function grantAuthorization(address _account) external;\n\n    /// @notice Revoke authorization from an account to pause and unpause contracts\n    /// @param _account The account to revoke authorization from\n    function revokeAuthorization(address _account) external;\n\n    /// @notice Pause a contract\n    /// @param _contract The contract to pause\n    function pause(address _contract) external;\n\n    /// @notice Unpause a contract\n    /// @param _contract The contract to unpause\n    function unpause(address _contract) external;\n\n    /// @notice Transfer ownership of a contract\n    /// @param _contract The contract to transfer ownership of\n    /// @param _newOwner The new owner of the contract\n    function transferOwnershipFrom(address _contract, address _newOwner) external;\n\n    /// @notice Accept ownership of a contract\n    /// @param _contract The contract to accept ownership of\n    function acceptOwnership(address _contract) external;\n\n    /// @notice Get all contracts\n    /// @return _contracts The list of contracts\n    function allContracts() external view returns (address[] memory);\n\n    /// @notice Get all authorized accounts to pause and unpause contracts\n    /// @return _authorizedToPause The list of authorized accounts\n    function authorizedToPause() external view returns (address[] memory);\n\n    /// @notice Check if an account is a signer of the multisig contract\n    /// @param _account The account to check\n    /// @return result True if the account is a signer, false otherwise\n    function isSigner(address _account) external view returns (bool result);\n\n    /// @notice Get the pause status of all contracts\n    /// @return result The list of contracts and their pause statuses\n    function getAllContractsPauseStatus() external view returns (ContractPauseStatus[] memory result);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=gitmodules/forge-std/src/",
      "silo-foundry-utils/=gitmodules/silo-foundry-utils/contracts/",
      "properties/=gitmodules/crytic/properties/contracts/",
      "silo-core/=silo-core/",
      "silo-oracles/=silo-oracles/",
      "silo-vaults/=silo-vaults/",
      "@openzeppelin/=gitmodules/openzeppelin-contracts-5/",
      "morpho-blue/=gitmodules/morpho-blue/src/",
      "openzeppelin5/=gitmodules/openzeppelin-contracts-5/contracts/",
      "openzeppelin5-upgradeable/=gitmodules/openzeppelin-contracts-upgradeable-5/contracts/",
      "chainlink/=gitmodules/chainlink/contracts/src/",
      "chainlink-ccip/=gitmodules/chainlink-ccip/contracts/src/",
      "uniswap/=gitmodules/uniswap/",
      "@uniswap/v3-core/=gitmodules/uniswap/v3-core/",
      "pyth-sdk-solidity/=gitmodules/pyth-sdk-solidity/target_chains/ethereum/sdk/solidity/",
      "a16z-erc4626-tests/=gitmodules/a16z-erc4626-tests/",
      "ERC4626/=gitmodules/crytic/properties/lib/ERC4626/contracts/",
      "createx/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/src/",
      "crytic/=gitmodules/crytic/",
      "ds-test/=gitmodules/openzeppelin-contracts-5/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=gitmodules/openzeppelin-contracts-5/lib/erc4626-tests/",
      "halmos-cheatcodes/=gitmodules/morpho-blue/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts-5/=gitmodules/openzeppelin-contracts-5/",
      "openzeppelin-contracts-upgradeable-5/=gitmodules/openzeppelin-contracts-upgradeable-5/",
      "openzeppelin-contracts-upgradeable/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/",
      "solady/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/lib/solady/",
      "solmate/=gitmodules/crytic/properties/lib/solmate/src/",
      "x-silo/=node_modules/x-silo/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}