{
  "language": "Solidity",
  "sources": {
    "silo-core/contracts/Silo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.28;\n\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\n\nimport {ISilo, IERC4626, IERC3156FlashLender} from \"./interfaces/ISilo.sol\";\nimport {IShareToken} from \"./interfaces/IShareToken.sol\";\nimport {IVersioned} from \"./interfaces/IVersioned.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {ISiloConfig} from \"./interfaces/ISiloConfig.sol\";\nimport {ISiloFactory} from \"./interfaces/ISiloFactory.sol\";\n\nimport {ShareCollateralToken} from \"./utils/ShareCollateralToken.sol\";\n\nimport {Actions} from \"./lib/Actions.sol\";\nimport {Views} from \"./lib/Views.sol\";\nimport {SiloStdLib} from \"./lib/SiloStdLib.sol\";\nimport {SiloLendingLib} from \"./lib/SiloLendingLib.sol\";\nimport {SiloERC4626Lib} from \"./lib/SiloERC4626Lib.sol\";\nimport {SiloMathLib} from \"./lib/SiloMathLib.sol\";\nimport {Rounding} from \"./lib/Rounding.sol\";\nimport {Hook} from \"./lib/Hook.sol\";\nimport {ShareTokenLib} from \"./lib/ShareTokenLib.sol\";\nimport {SiloStorageLib} from \"./lib/SiloStorageLib.sol\";\n\n// Keep ERC4626 ordering\n// solhint-disable ordering\n\n/// @title Silo vault with lending and borrowing functionality\n/// @notice Silo is a ERC4626-compatible vault that allows users to deposit collateral and borrow debt. This contract\n/// is deployed twice for each asset for two-asset lending markets.\n/// Version: 2.0.0\ncontract Silo is ISilo, ShareCollateralToken {\n    using SafeERC20 for IERC20;\n\n    ISiloFactory public immutable factory;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(ISiloFactory _siloFactory) {\n        factory = _siloFactory;\n    }\n\n    /// @dev Silo is not designed to work with ether, but it can act as a middleware\n    /// between any third-party contract and hook receiver. So, this is the responsibility\n    /// of the hook receiver developer to handle it if needed.\n    receive() external payable {}\n\n    /// @inheritdoc IShareToken\n    function silo() external view virtual override returns (ISilo) {\n        return this;\n    }\n\n    /// @inheritdoc IVersioned\n    // solhint-disable-next-line func-name-mixedcase\n    function VERSION() external pure virtual override returns (string memory) {\n        return \"Silo 4.0.0\";\n    }\n\n    /// @inheritdoc ISilo\n    function callOnBehalfOfSilo(address _target, uint256 _value, CallType _callType, bytes calldata _input)\n        external\n        virtual\n        payable\n        returns (bool success, bytes memory result)\n    {\n        (success, result) = Actions.callOnBehalfOfSilo(_target, _value, _callType, _input);\n    }\n\n    /// @inheritdoc ISilo\n    function initialize(ISiloConfig _config) external virtual {\n        // silo initialization\n        address hookReceiver = Actions.initialize(_config);\n        // silo (vault) share token initialization\n        _shareTokenInitialize(this, hookReceiver, uint24(Hook.COLLATERAL_TOKEN));\n    }\n\n    /// @inheritdoc ISilo\n    function updateHooks() external virtual {\n        (uint24 hooksBefore, uint24 hooksAfter) = Actions.updateHooks();\n        emit HooksUpdated(hooksBefore, hooksAfter);\n    }\n\n    /// @inheritdoc ISilo\n    function config() external view virtual returns (ISiloConfig siloConfig) {\n        siloConfig = ShareTokenLib.siloConfig();\n    }\n\n    /// @inheritdoc ISilo\n    function utilizationData() external view virtual returns (UtilizationData memory) {\n        return Views.utilizationData();\n    }\n\n    /// @inheritdoc ISilo\n    function getLiquidity() external view virtual returns (uint256 liquidity) {\n        return SiloLendingLib.getLiquidity(ShareTokenLib.siloConfig());\n    }\n\n    /// @inheritdoc ISilo\n    function isSolvent(address _borrower) external view virtual returns (bool) {\n        return Views.isSolvent(_borrower);\n    }\n\n    /// @inheritdoc ISilo\n    function getTotalAssetsStorage(AssetType _assetType)\n        external\n        view\n        virtual\n        returns (uint256 totalAssetsByType)\n    {\n        totalAssetsByType = SiloStorageLib.getSiloStorage().totalAssets[_assetType];\n    }\n\n    /// @inheritdoc ISilo\n    function getSiloStorage()\n        external\n        view\n        virtual\n        returns (\n            uint192 daoAndDeployerRevenue,\n            uint64 interestRateTimestamp,\n            uint256 protectedAssets,\n            uint256 collateralAssets,\n            uint256 debtAssets\n        )\n    {\n        return Views.getSiloStorage();\n    }\n\n    /// @inheritdoc ISilo\n    function getFractionsStorage() external view returns (Fractions memory fractions) {\n        fractions = Views.getFractionsStorage();\n    }\n\n    /// @inheritdoc ISilo\n    function getCollateralAssets() external view virtual returns (uint256 totalCollateralAssets) {\n        totalCollateralAssets = _totalAssets();\n    }\n\n    /// @inheritdoc ISilo\n    function getDebtAssets() external view virtual returns (uint256 totalDebtAssets) {\n        totalDebtAssets = Views.getDebtAssets();\n    }\n\n    /// @inheritdoc ISilo\n    function getCollateralAndProtectedTotalsStorage()\n        external\n        view\n        virtual\n        returns (uint256 totalCollateralAssets, uint256 totalProtectedAssets)\n    {\n        (totalCollateralAssets, totalProtectedAssets) = Views.getCollateralAndProtectedAssets();\n    }\n\n    /// @inheritdoc ISilo\n    function getCollateralAndDebtTotalsStorage()\n        external\n        view\n        virtual\n        returns (uint256 totalCollateralAssets, uint256 totalDebtAssets)\n    {\n        (totalCollateralAssets, totalDebtAssets) = Views.getCollateralAndDebtAssets();\n    }\n\n    // ERC4626\n\n    /// @inheritdoc IERC4626\n    function asset() external view virtual returns (address assetTokenAddress) {\n        return ShareTokenLib.siloConfig().getAssetForSilo(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    /// @notice Returns the total amount of the underlying asset that is “managed” by Vault.\n    /// When accrue interest in memory, in extreme scenario result may be overestimated by 1wei, because on view method\n    /// we do not apply math for fractions.\n    function totalAssets() external view virtual returns (uint256 totalManagedAssets) {\n        totalManagedAssets = _totalAssets();\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev For protected (non-borrowable) collateral and debt, use:\n    /// `convertToShares(uint256 _assets, AssetType _assetType)` with `AssetType.Protected` or `AssetType.Debt`\n    function convertToShares(uint256 _assets) external view virtual returns (uint256 shares) {\n        shares = _convertToShares(_assets, AssetType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    /// @dev For protected (non-borrowable) collateral and debt, use:\n    /// `convertToAssets(uint256 _shares, AssetType _assetType)` with `AssetType.Protected` or `AssetType.Debt`\n    function convertToAssets(uint256 _shares) external view virtual returns (uint256 assets) {\n        assets = _convertToAssets(_shares, AssetType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address /* _receiver */) external pure virtual returns (uint256 maxAssets) {\n        maxAssets = SiloERC4626Lib._VIRTUAL_DEPOSIT_LIMIT;\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 _assets) external view virtual returns (uint256 shares) {\n        return _previewDeposit(_assets, CollateralType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 _assets, address _receiver)\n        external\n        virtual\n        returns (uint256 shares)\n    {\n        (, shares) = _deposit(_assets, 0 /* shares */, _receiver, CollateralType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address /* _receiver */) external view virtual returns (uint256 maxShares) {\n        return SiloERC4626Lib._VIRTUAL_DEPOSIT_LIMIT;\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 _shares) external view virtual returns (uint256 assets) {\n        return _previewMint(_shares, CollateralType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 _shares, address _receiver) external virtual returns (uint256 assets) {\n        (assets,) = _deposit({\n            _assets: 0,\n            _shares: _shares,\n            _receiver: _receiver,\n            _collateralType: CollateralType.Collateral\n        });\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address _owner) external view virtual returns (uint256 maxAssets) {\n        (maxAssets,) = _maxWithdraw(_owner, CollateralType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 _assets) external view virtual returns (uint256 shares) {\n        return _previewWithdraw(_assets, CollateralType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 _assets, address _receiver, address _owner)\n        external\n        virtual\n        returns (uint256 shares)\n    {\n        (, shares) = _withdraw({\n            _assets: _assets,\n            _shares: 0,\n            _receiver: _receiver,\n            _owner: _owner,\n            _spender: msg.sender,\n            _collateralType: CollateralType.Collateral\n        });\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address _owner) external view virtual returns (uint256 maxShares) {\n        (, maxShares) = _maxWithdraw(_owner, CollateralType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 _shares) external view virtual returns (uint256 assets) {\n        return _previewRedeem(_shares, CollateralType.Collateral);\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 _shares, address _receiver, address _owner)\n        external\n        virtual\n        returns (uint256 assets)\n    {\n        (assets,) = _withdraw({\n            _assets: 0,\n            _shares: _shares,\n            _receiver: _receiver,\n            _owner: _owner,\n            _spender: msg.sender,\n            _collateralType: CollateralType.Collateral\n        });\n    }\n\n    /// @inheritdoc ISilo\n    function convertToShares(uint256 _assets, AssetType _assetType) external view virtual returns (uint256 shares) {\n        shares = _convertToShares(_assets, _assetType);\n    }\n\n    /// @inheritdoc ISilo\n    function convertToAssets(uint256 _shares, AssetType _assetType) external view virtual returns (uint256 assets) {\n        assets = _convertToAssets(_shares, _assetType);\n    }\n\n    /// @inheritdoc ISilo\n    function previewDeposit(uint256 _assets, CollateralType _collateralType)\n        external\n        view\n        virtual\n        returns (uint256 shares)\n    {\n        return _previewDeposit(_assets, _collateralType);\n    }\n\n    /// @inheritdoc ISilo\n    function deposit(uint256 _assets, address _receiver, CollateralType _collateralType)\n        external\n        virtual\n        returns (uint256 shares)\n    {\n        (, shares) = _deposit({\n            _assets: _assets,\n            _shares: 0,\n            _receiver: _receiver,\n            _collateralType: _collateralType\n        });\n    }\n\n    /// @inheritdoc ISilo\n    function previewMint(uint256 _shares, CollateralType _collateralType)\n        external\n        view\n        virtual\n        returns (uint256 assets)\n    {\n        return _previewMint(_shares, _collateralType);\n    }\n\n    /// @inheritdoc ISilo\n    function mint(uint256 _shares, address _receiver, CollateralType _collateralType)\n        external\n        virtual\n        returns (uint256 assets)\n    {\n        (assets,) = _deposit({\n            _assets: 0,\n            _shares: _shares,\n            _receiver: _receiver,\n            _collateralType: _collateralType\n        });\n    }\n\n    /// @inheritdoc ISilo\n    function maxWithdraw(address _owner, CollateralType _collateralType)\n        external\n        view\n        virtual\n        returns (uint256 maxAssets)\n    {\n        (maxAssets,) = _maxWithdraw(_owner, _collateralType);\n    }\n\n    /// @inheritdoc ISilo\n    function previewWithdraw(uint256 _assets, CollateralType _collateralType)\n        external\n        view\n        virtual\n        returns (uint256 shares)\n    {\n        return _previewWithdraw(_assets, _collateralType);\n    }\n\n    /// @inheritdoc ISilo\n    function withdraw(uint256 _assets, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        virtual\n        returns (uint256 shares)\n    {\n        (, shares) = _withdraw({\n            _assets: _assets,\n            _shares: 0,\n            _receiver: _receiver,\n            _owner: _owner,\n            _spender: msg.sender,\n            _collateralType: _collateralType\n        });\n    }\n\n    /// @inheritdoc ISilo\n    function maxRedeem(address _owner, CollateralType _collateralType)\n        external\n        view\n        virtual\n        returns (uint256 maxShares)\n    {\n        (, maxShares) = _maxWithdraw(_owner, _collateralType);\n    }\n\n    /// @inheritdoc ISilo\n    function previewRedeem(uint256 _shares, CollateralType _collateralType)\n        external\n        view\n        virtual\n        returns (uint256 assets)\n    {\n        return _previewRedeem(_shares, _collateralType);\n    }\n\n    /// @inheritdoc ISilo\n    function redeem(uint256 _shares, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        virtual\n        returns (uint256 assets)\n    {\n        (assets,) = _withdraw({\n            _assets: 0,\n            _shares: _shares,\n            _receiver: _receiver,\n            _owner: _owner,\n            _spender: msg.sender,\n            _collateralType: _collateralType\n        });\n    }\n\n    /// @inheritdoc ISilo\n    function maxBorrow(address _borrower) external view virtual returns (uint256 maxAssets) {\n        (maxAssets,) = Views.maxBorrow({_borrower: _borrower});\n    }\n\n    /// @inheritdoc ISilo\n    function previewBorrow(uint256 _assets) external view virtual returns (uint256 shares) {\n        (\n            uint256 totalSiloAssets, uint256 totalShares\n        ) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(ShareTokenLib.getConfig(), AssetType.Debt);\n\n        return SiloMathLib.convertToShares(\n            _assets, totalSiloAssets, totalShares, Rounding.BORROW_TO_SHARES, AssetType.Debt\n        );\n    }\n\n    /// @inheritdoc ISilo\n    function borrow(uint256 _assets, address _receiver, address _borrower)\n        external\n        virtual\n        returns (uint256 shares)\n    {\n        uint256 assets;\n        bool collateralTypeChanged;\n\n        (assets, shares, collateralTypeChanged) = Actions.borrow(\n            BorrowArgs({\n                assets: _assets,\n                shares: 0,\n                receiver: _receiver,\n                borrower: _borrower\n            })\n        );\n\n        emit Borrow(msg.sender, _receiver, _borrower, assets, shares);\n\n        if (collateralTypeChanged) emit CollateralTypeChanged(msg.sender);\n    }\n\n    /// @inheritdoc ISilo\n    function maxBorrowShares(address _borrower) external view virtual returns (uint256 maxShares) {\n        (,maxShares) = Views.maxBorrow({_borrower: _borrower});\n    }\n\n    /// @inheritdoc ISilo\n    function previewBorrowShares(uint256 _shares) external view virtual returns (uint256 assets) {\n        (\n            uint256 totalSiloAssets, uint256 totalShares\n        ) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(ShareTokenLib.getConfig(), AssetType.Debt);\n\n        return SiloMathLib.convertToAssets(\n            _shares, totalSiloAssets, totalShares, Rounding.BORROW_TO_ASSETS, AssetType.Debt\n        );\n    }\n\n    /// @inheritdoc ISilo\n    function borrowShares(uint256 _shares, address _receiver, address _borrower)\n        external\n        virtual\n        returns (uint256 assets)\n    {\n        uint256 shares;\n        bool collateralTypeChanged;\n\n        (assets, shares, collateralTypeChanged) = Actions.borrow(\n            BorrowArgs({\n                assets: 0,\n                shares: _shares,\n                receiver: _receiver,\n                borrower: _borrower\n            })\n        );\n\n        emit Borrow(msg.sender, _receiver, _borrower, assets, shares);\n\n        if (collateralTypeChanged) emit CollateralTypeChanged(msg.sender);\n    }\n\n    /// @inheritdoc ISilo\n    function maxBorrowSameAsset(address) external pure virtual returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc ISilo\n    function borrowSameAsset(uint256, address, address) external virtual returns (uint256) {\n        revert Deprecated();\n    }\n\n    /// @inheritdoc ISilo\n    function transitionCollateral(\n        uint256 _shares,\n        address _owner,\n        CollateralType _transitionFrom\n    )\n        external\n        virtual\n        returns (uint256 assets)\n    {\n        uint256 toShares;\n\n        (assets, toShares) = Actions.transitionCollateral(\n            TransitionCollateralArgs({\n                shares: _shares,\n                owner: _owner,\n                transitionFrom: _transitionFrom\n            })\n        );\n\n        if (_transitionFrom == CollateralType.Collateral) {\n            emit Withdraw(msg.sender, _owner, _owner, assets, _shares);\n            emit DepositProtected(msg.sender, _owner, assets, toShares);\n        } else {\n            emit WithdrawProtected(msg.sender, _owner, _owner, assets, _shares);\n            emit Deposit(msg.sender, _owner, assets, toShares);\n        }\n    }\n\n    /// @inheritdoc ISilo\n    function switchCollateralToThisSilo() external virtual {\n        revert Deprecated();\n    }\n\n    /// @inheritdoc ISilo\n    function maxRepay(address _borrower) external view virtual returns (uint256 assets) {\n        assets = Views.maxRepay(_borrower);\n    }\n\n    /// @inheritdoc ISilo\n    function previewRepay(uint256 _assets) external view virtual returns (uint256 shares) {\n        (\n            uint256 totalSiloAssets, uint256 totalShares\n        ) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(ShareTokenLib.getConfig(), AssetType.Debt);\n\n        return SiloMathLib.convertToShares(\n            _assets, totalSiloAssets, totalShares, Rounding.REPAY_TO_SHARES, AssetType.Debt\n        );\n    }\n\n    /// @inheritdoc ISilo\n    function repay(uint256 _assets, address _borrower)\n        external\n        virtual\n        returns (uint256 shares)\n    {\n        uint256 assets;\n\n        (assets, shares) = Actions.repay({\n            _assets: _assets,\n            _shares: 0,\n            _borrower: _borrower,\n            _repayer: msg.sender\n        });\n\n        emit Repay(msg.sender, _borrower, assets, shares);\n    }\n\n    /// @inheritdoc ISilo\n    function maxRepayShares(address _borrower) external view virtual returns (uint256 shares) {\n        (address debtShareToken,) = _getSiloConfig().getDebtShareTokenAndAsset(address(this));\n        shares = IShareToken(debtShareToken).balanceOf(_borrower);\n    }\n\n    /// @inheritdoc ISilo\n    function previewRepayShares(uint256 _shares) external view virtual returns (uint256 assets) {\n        (\n            uint256 totalSiloAssets, uint256 totalShares\n        ) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(ShareTokenLib.getConfig(), AssetType.Debt);\n\n        return SiloMathLib.convertToAssets(\n            _shares, totalSiloAssets, totalShares, Rounding.REPAY_TO_ASSETS, AssetType.Debt\n        );\n    }\n\n    /// @inheritdoc ISilo\n    function repayShares(uint256 _shares, address _borrower)\n        external\n        virtual\n        returns (uint256 assets)\n    {\n        uint256 shares;\n\n        (assets, shares) = Actions.repay({\n            _assets: 0,\n            _shares: _shares,\n            _borrower: _borrower,\n            _repayer: msg.sender\n        });\n\n        emit Repay(msg.sender, _borrower, assets, shares);\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function maxFlashLoan(address _token) external view virtual returns (uint256 maxLoan) {\n        maxLoan = Views.maxFlashLoan(_token);\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashFee(address _token, uint256 _amount) external view virtual returns (uint256 fee) {\n        fee = Views.flashFee(_token, _amount);\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)\n        external\n        virtual\n        returns (bool success)\n    {\n        success = Actions.flashLoan(_receiver, _token, _amount, _data);\n        if (success) emit FlashLoan(_amount);\n    }\n\n    /// @inheritdoc ISilo\n    function accrueInterest() external virtual returns (uint256 accruedInterest) {\n        accruedInterest = _accrueInterest();\n    }\n\n    /// @inheritdoc ISilo\n    function accrueInterestForConfig(address _interestRateModel, uint256 _daoFee, uint256 _deployerFee)\n        external\n        virtual\n    {\n        require(msg.sender == address(ShareTokenLib.siloConfig()), OnlySiloConfig());\n\n        _accrueInterestForAsset(_interestRateModel, _daoFee, _deployerFee);\n    }\n\n    /// @inheritdoc ISilo\n    function withdrawFees() external virtual {\n        _accrueInterest();\n        (uint256 daoFees, uint256 deployerFees, bool redirectedDeployerFees) = Actions.withdrawFees(this);\n\n        emit WithdrawnFees(daoFees, deployerFees, redirectedDeployerFees);\n    }\n\n    function _totalAssets() internal view virtual returns (uint256 totalManagedAssets) {\n        (totalManagedAssets,) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(\n            ShareTokenLib.getConfig(),\n            AssetType.Collateral\n        );\n    }\n\n    function _convertToAssets(uint256 _shares, AssetType _assetType) internal view virtual returns (uint256 assets) {\n        (\n            uint256 totalSiloAssets, uint256 totalShares\n        ) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(ShareTokenLib.getConfig(), _assetType);\n\n        assets = SiloMathLib.convertToAssets(\n            _shares,\n            totalSiloAssets,\n            totalShares,\n            _assetType == AssetType.Debt ? Rounding.BORROW_TO_ASSETS : Rounding.DEPOSIT_TO_ASSETS,\n            _assetType\n        );\n    }\n\n    function _convertToShares(uint256 _assets, AssetType _assetType) internal view virtual returns (uint256 shares) {\n        (\n            uint256 totalSiloAssets, uint256 totalShares\n        ) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(ShareTokenLib.getConfig(), _assetType);\n\n        shares = SiloMathLib.convertToShares(\n            _assets,\n            totalSiloAssets,\n            totalShares,\n            _assetType == AssetType.Debt ? Rounding.BORROW_TO_SHARES : Rounding.DEPOSIT_TO_SHARES,\n            _assetType\n        );\n    }\n\n    function _deposit(\n        uint256 _assets,\n        uint256 _shares,\n        address _receiver,\n        ISilo.CollateralType _collateralType\n    )\n        internal\n        virtual\n        returns (uint256 assets, uint256 shares)\n    {\n        (\n            assets, shares\n        ) = Actions.deposit(_assets, _shares, _receiver, _collateralType);\n\n        if (_collateralType == CollateralType.Collateral) {\n            emit Deposit(msg.sender, _receiver, assets, shares);\n        } else {\n            emit DepositProtected(msg.sender, _receiver, assets, shares);\n        }\n    }\n\n    function _withdraw(\n        uint256 _assets,\n        uint256 _shares,\n        address _receiver,\n        address _owner,\n        address _spender,\n        ISilo.CollateralType _collateralType\n    )\n        internal\n        virtual\n        returns (uint256 assets, uint256 shares)\n    {\n        (assets, shares) = Actions.withdraw(\n            WithdrawArgs({\n                assets: _assets,\n                shares: _shares,\n                receiver: _receiver,\n                owner: _owner,\n                spender: _spender,\n                collateralType: _collateralType\n            })\n        );\n\n        if (_collateralType == CollateralType.Collateral) {\n            emit Withdraw(msg.sender, _receiver, _owner, assets, shares);\n        } else {\n            emit WithdrawProtected(msg.sender, _receiver, _owner, assets, shares);\n        }\n    }\n\n    function _previewMint(uint256 _shares, CollateralType _collateralType)\n        internal\n        view\n        virtual\n        returns (uint256 assets)\n    {\n        ISilo.AssetType assetType = AssetType(uint256(_collateralType));\n\n        (\n            uint256 totalSiloAssets, uint256 totalShares\n        ) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(ShareTokenLib.getConfig(), assetType);\n\n        return SiloMathLib.convertToAssets(\n            _shares, totalSiloAssets, totalShares, Rounding.DEPOSIT_TO_ASSETS, assetType\n        );\n    }\n\n    function _previewDeposit(uint256 _assets, CollateralType _collateralType)\n        internal\n        view\n        virtual\n        returns (uint256 shares)\n    {\n        ISilo.AssetType assetType = AssetType(uint256(_collateralType));\n\n        (uint256 totalSiloAssets, uint256 totalShares) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(\n            ShareTokenLib.getConfig(),\n            assetType\n        );\n\n        return SiloMathLib.convertToShares(\n            _assets, totalSiloAssets, totalShares, Rounding.DEPOSIT_TO_SHARES, assetType\n        );\n    }\n\n    function _previewRedeem(\n        uint256 _shares,\n        CollateralType _collateralType\n    ) internal view virtual returns (uint256 assets) {\n        ISilo.AssetType assetType = AssetType(uint256(_collateralType));\n\n        (uint256 totalSiloAssets, uint256 totalShares) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(\n            ShareTokenLib.getConfig(),\n            assetType\n        );\n\n        return SiloMathLib.convertToAssets(\n            _shares, totalSiloAssets, totalShares, Rounding.WITHDRAW_TO_ASSETS, assetType\n        );\n    }\n\n    function _previewWithdraw(\n        uint256 _assets,\n        ISilo.CollateralType _collateralType\n    ) internal view virtual returns (uint256 shares) {\n        ISilo.AssetType assetType = AssetType(uint256(_collateralType));\n\n        (uint256 totalSiloAssets, uint256 totalShares) = SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(\n            ShareTokenLib.getConfig(),\n            assetType\n        );\n\n        return SiloMathLib.convertToShares(\n            _assets, totalSiloAssets, totalShares, Rounding.WITHDRAW_TO_SHARES, assetType\n        );\n    }\n\n    function _maxWithdraw(address _owner, ISilo.CollateralType _collateralType)\n        internal\n        view\n        virtual\n        returns (uint256 assets, uint256 shares)\n    {\n        return Views.maxWithdraw(_owner, _collateralType);\n    }\n\n    function _accrueInterest() internal virtual returns (uint256 accruedInterest) {\n        ISiloConfig.ConfigData memory cfg = ShareTokenLib.getConfig();\n        accruedInterest = _accrueInterestForAsset(cfg.interestRateModel, cfg.daoFee, cfg.deployerFee);\n    }\n\n    function _accrueInterestForAsset(\n        address _interestRateModel,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    ) internal virtual returns (uint256 accruedInterest) {\n        accruedInterest = SiloLendingLib.accrueInterestForAsset(_interestRateModel, _daoFee, _deployerFee);\n        if (accruedInterest != 0) emit AccruedInterest(accruedInterest);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "silo-core/contracts/interfaces/ISilo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC4626, IERC20, IERC20Metadata} from \"openzeppelin5/interfaces/IERC4626.sol\";\n\nimport {IERC3156FlashLender} from \"./IERC3156FlashLender.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\nimport {ISiloFactory} from \"./ISiloFactory.sol\";\n\nimport {IHookReceiver} from \"./IHookReceiver.sol\";\n\n// solhint-disable ordering\ninterface ISilo is IERC20, IERC4626, IERC3156FlashLender {\n    /// @dev Interest accrual happens on each deposit/withdraw/borrow/repay. View methods work on storage that might be\n    ///      outdate. Some calculations require accrued interest to return current state of Silo. This struct is used\n    ///      to make a decision inside functions if interest should be accrued in memory to work on updated values.\n    enum AccrueInterestInMemory {\n        No,\n        Yes\n    }\n\n    /// @dev Silo has two separate oracles for solvency and maxLtv calculations. MaxLtv oracle is optional. Solvency\n    ///      oracle can also be optional if asset is used as denominator in Silo config. For example, in ETH/USDC Silo\n    ///      one could setup only solvency oracle for ETH that returns price in USDC. Then USDC does not need an oracle\n    ///      because it's used as denominator for ETH and it's \"price\" can be assume as 1.\n    enum OracleType {\n        Solvency,\n        MaxLtv\n    }\n\n    /// @dev There are 3 types of accounting in the system: for non-borrowable collateral deposit called \"protected\",\n    ///      for borrowable collateral deposit called \"collateral\" and for borrowed tokens called \"debt\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum AssetType {\n        Protected, // default\n        Collateral,\n        Debt\n    }\n\n    /// @dev There are 2 types of accounting in the system: for non-borrowable collateral deposit called \"protected\" and\n    ///      for borrowable collateral deposit called \"collateral\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum CollateralType {\n        Protected, // default\n        Collateral\n    }\n\n    /// @dev Types of calls that can be made by the hook receiver on behalf of Silo via `callOnBehalfOfSilo` fn\n    enum CallType {\n        Call, // default\n        Delegatecall\n    }\n\n    /// @param _assets Amount of assets the user wishes to withdraw. Use 0 if shares are provided.\n    /// @param _shares Shares the user wishes to burn in exchange for the withdrawal. Use 0 if assets are provided.\n    /// @param _receiver Address receiving the withdrawn assets\n    /// @param _owner Address of the owner of the shares being burned\n    /// @param _spender Address executing the withdrawal; may be different than `_owner` if an allowance was set\n    /// @param _collateralType Type of the asset being withdrawn (Collateral or Protected)\n    struct WithdrawArgs {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        ISilo.CollateralType collateralType;\n    }\n\n    /// @param assets Number of assets the borrower intends to borrow. Use 0 if shares are provided.\n    /// @param shares Number of shares corresponding to the assets that the borrower intends to borrow. Use 0 if\n    /// assets are provided.\n    /// @param receiver Address that will receive the borrowed assets\n    /// @param borrower The user who is borrowing the assets\n    struct BorrowArgs {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n    }\n\n    /// @param shares Amount of shares the user wishes to transit.\n    /// @param owner owner of the shares after transition.\n    /// @param transitionFrom type of collateral that will be transitioned.\n    struct TransitionCollateralArgs {\n        uint256 shares;\n        address owner;\n        ISilo.CollateralType transitionFrom;\n    }\n\n    struct UtilizationData {\n        /// @dev COLLATERAL: Amount of asset token that has been deposited to Silo plus interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        uint256 collateralAssets;\n        /// @dev DEBT: Amount of asset token that has been borrowed plus accrued interest.\n        uint256 debtAssets;\n        /// @dev timestamp of the last interest accrual\n        uint64 interestRateTimestamp;\n    }\n\n    /// @dev Interest and revenue may be rounded down to zero if the underlying token's decimal is low.\n    /// Because of that, we need to store fractions for further calculation to minimize losses.\n    struct Fractions {\n        /// @dev interest value that we could not convert to full token in 36 decimals, max value for it is 1e18.\n        /// this value was not yet apply as interest for borrowers\n        uint64 interest;\n        /// @dev revenue value that we could not convert to full token in 36 decimals, max value for it is 1e18.\n        uint64 revenue;\n    }\n\n    struct SiloStorage {\n        /// @param daoAndDeployerRevenue Current amount of assets (fees) accrued by DAO and Deployer\n        /// but not yet withdrawn\n        uint192 daoAndDeployerRevenue;\n        /// @dev timestamp of the last interest accrual\n        uint64 interestRateTimestamp;\n        /// @dev Interest and revenue fractions for more precise calculations\n        Fractions fractions;\n\n        /// @dev silo is just for one asset,\n        /// but this one asset can be of three types: mapping key is uint256(AssetType), so we store `assets` by type.\n        /// Assets based on type:\n        /// - PROTECTED COLLATERAL: Amount of asset token that has been deposited to Silo that can be ONLY used\n        /// as collateral. These deposits do NOT earn interest and CANNOT be borrowed.\n        /// - COLLATERAL: Amount of asset token that has been deposited to Silo plus interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        /// - DEBT: Amount of asset token that has been borrowed plus accrued interest.\n        /// `totalAssets` can have outdated value (without interest), if you doing view call (of off-chain call)\n        /// please use getters eg `getCollateralAssets()` to fetch value that includes interest.\n        mapping(AssetType assetType => uint256 assets) totalAssets;\n    }\n\n    /// @notice Emitted on protected deposit\n    /// @param sender wallet address that deposited asset\n    /// @param owner wallet address that received shares in Silo\n    /// @param assets amount of asset that was deposited\n    /// @param shares amount of shares that was minted\n    event DepositProtected(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @notice Emitted on protected withdraw\n    /// @param sender wallet address that sent transaction\n    /// @param receiver wallet address that received asset\n    /// @param owner wallet address that owned asset\n    /// @param assets amount of asset that was withdrew\n    /// @param shares amount of shares that was burn\n    event WithdrawProtected(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Emitted on borrow\n    /// @param sender wallet address that sent transaction\n    /// @param receiver wallet address that received asset\n    /// @param owner wallet address that owes assets\n    /// @param assets amount of asset that was borrowed\n    /// @param shares amount of shares that was minted\n    event Borrow(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Emitted on repayment\n    /// @param sender wallet address that repaid asset\n    /// @param owner wallet address that owed asset\n    /// @param assets amount of asset that was repaid\n    /// @param shares amount of shares that was burn\n    event Repay(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @notice emitted only when collateral has been switched to other one\n    event CollateralTypeChanged(address indexed borrower);\n\n    event HooksUpdated(uint24 hooksBefore, uint24 hooksAfter);\n\n    event AccruedInterest(uint256 hooksBefore);\n\n    event FlashLoan(uint256 amount);\n\n    event WithdrawnFees(uint256 daoFees, uint256 deployerFees, bool redirectedDeployerFees);\n\n    event DeployerFeesRedirected(uint256 deployerFees);\n\n    error UnsupportedFlashloanToken();\n    error FlashloanAmountTooBig();\n    error NothingToWithdraw();\n    error ProtectedProtection();\n    error NotEnoughLiquidity();\n    error NotSolvent();\n    error BorrowNotPossible();\n    error EarnedZero();\n    error FlashloanFailed();\n    error AboveMaxLtv();\n    error SiloInitialized();\n    error OnlyHookReceiver();\n    error NoLiquidity();\n    error InputCanBeAssetsOrShares();\n    error CollateralSiloAlreadySet();\n    error RepayTooHigh();\n    error ZeroAmount();\n    error InputZeroShares();\n    error ReturnZeroAssets();\n    error ReturnZeroShares();\n    error Deprecated();\n\n    /// @return siloFactory The associated factory of the silo\n    function factory() external view returns (ISiloFactory siloFactory);\n\n    /// @notice Method for HookReceiver only to call on behalf of Silo\n    /// @param _target address of the contract to call\n    /// @param _value amount of ETH to send\n    /// @param _callType type of the call (Call or Delegatecall)\n    /// @param _input calldata for the call\n    function callOnBehalfOfSilo(address _target, uint256 _value, CallType _callType, bytes calldata _input)\n        external\n        payable\n        returns (bool success, bytes memory result);\n\n    /// @notice Initialize Silo\n    /// @param _siloConfig address of ISiloConfig with full config for this Silo\n    function initialize(ISiloConfig _siloConfig) external;\n\n    /// @notice Update hooks configuration for Silo\n    /// @dev This function must be called after the hooks configuration is changed in the hook receiver\n    function updateHooks() external;\n\n    /// @notice Fetches the silo configuration contract\n    /// @return siloConfig Address of the configuration contract associated with the silo\n    function config() external view returns (ISiloConfig siloConfig);\n\n    /// @notice Fetches the utilization data of the silo used by IRM\n    function utilizationData() external view returns (UtilizationData memory utilizationData);\n\n    /// @notice Fetches the real (available to borrow) liquidity in the silo, it does include interest\n    /// @return liquidity The amount of liquidity\n    function getLiquidity() external view returns (uint256 liquidity);\n\n    /// @notice Determines if a borrower is solvent\n    /// @param _borrower Address of the borrower to check for solvency\n    /// @return True if the borrower is solvent, otherwise false\n    function isSolvent(address _borrower) external view returns (bool);\n\n    /// @notice Retrieves the raw total amount of assets based on provided type (direct storage access)\n    function getTotalAssetsStorage(AssetType _assetType) external view returns (uint256);\n\n    /// @notice Direct storage access to silo storage\n    /// @dev See struct `SiloStorage` for more details\n    function getSiloStorage()\n        external\n        view\n        returns (\n            uint192 daoAndDeployerRevenue,\n            uint64 interestRateTimestamp,\n            uint256 protectedAssets,\n            uint256 collateralAssets,\n            uint256 debtAssets\n        );\n\n    /// @notice Direct access to silo storage fractions variables\n    function getFractionsStorage() external view returns (Fractions memory fractions);\n\n    /// @notice Retrieves the total amount of collateral (borrowable) assets with interest\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    function getCollateralAssets() external view returns (uint256 totalCollateralAssets);\n\n    /// @notice Retrieves the total amount of debt assets with interest\n    /// @return totalDebtAssets The total amount of assets of type 'Debt'\n    function getDebtAssets() external view returns (uint256 totalDebtAssets);\n\n    /// @notice Retrieves the total amounts of collateral and protected (non-borrowable) assets\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    /// @return totalProtectedAssets The total amount of protected (non-borrowable) assets\n    function getCollateralAndProtectedTotalsStorage()\n        external\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalProtectedAssets);\n\n    /// @notice Retrieves the total amounts of collateral and debt assets\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    /// @return totalDebtAssets The total amount of debt assets of type 'Debt'\n    function getCollateralAndDebtTotalsStorage()\n        external\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalDebtAssets);\n\n    /// @notice Implements IERC4626.convertToShares for each asset type\n    function convertToShares(uint256 _assets, AssetType _assetType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.convertToAssets for each asset type\n    function convertToAssets(uint256 _shares, AssetType _assetType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.previewDeposit for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewDeposit(uint256 _assets, CollateralType _collateralType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.deposit for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function deposit(uint256 _assets, address _receiver, CollateralType _collateralType)\n        external\n        returns (uint256 shares);\n\n    /// @notice Implements IERC4626.previewMint for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewMint(uint256 _shares, CollateralType _collateralType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.mint for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function mint(uint256 _shares, address _receiver, CollateralType _collateralType) external returns (uint256 assets);\n\n    /// @notice Implements IERC4626.maxWithdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function maxWithdraw(address _owner, CollateralType _collateralType) external view returns (uint256 maxAssets);\n\n    /// @notice Implements IERC4626.previewWithdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewWithdraw(uint256 _assets, CollateralType _collateralType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.withdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function withdraw(uint256 _assets, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        returns (uint256 shares);\n\n    /// @notice Implements IERC4626.maxRedeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function maxRedeem(address _owner, CollateralType _collateralType) external view returns (uint256 maxShares);\n\n    /// @notice Implements IERC4626.previewRedeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewRedeem(uint256 _shares, CollateralType _collateralType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.redeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function redeem(uint256 _shares, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        returns (uint256 assets);\n\n    /// @notice Calculates the maximum amount of assets that can be borrowed by the given address\n    /// @param _borrower Address of the potential borrower\n    /// @return maxAssets Maximum amount of assets that the borrower can borrow, this value is underestimated\n    /// That means, in some cases when you borrow maxAssets, you will be able to borrow again eg. up to 2wei\n    /// Reason for underestimation is to return value that will not cause borrow revert\n    function maxBorrow(address _borrower) external view returns (uint256 maxAssets);\n\n    /// @notice Previews the amount of shares equivalent to the given asset amount for borrowing\n    /// @param _assets Amount of assets to preview the equivalent shares for\n    /// @return shares Amount of shares equivalent to the provided asset amount\n    function previewBorrow(uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Allows an address to borrow a specified amount of assets\n    /// @param _assets Amount of assets to borrow\n    /// @param _receiver Address receiving the borrowed assets\n    /// @param _borrower Address responsible for the borrowed assets\n    /// @return shares Amount of shares equivalent to the borrowed assets\n    function borrow(uint256 _assets, address _receiver, address _borrower)\n        external returns (uint256 shares);\n\n    /// @notice Calculates the maximum amount of shares that can be borrowed by the given address\n    /// @param _borrower Address of the potential borrower\n    /// @return maxShares Maximum number of shares that the borrower can borrow\n    function maxBorrowShares(address _borrower) external view returns (uint256 maxShares);\n\n    /// @notice Previews the amount of assets equivalent to the given share amount for borrowing\n    /// @param _shares Amount of shares to preview the equivalent assets for\n    /// @return assets Amount of assets equivalent to the provided share amount\n    function previewBorrowShares(uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice deprecated\n    function maxBorrowSameAsset(address _borrower) external view returns (uint256 maxAssets);\n\n    /// @notice deprecated\n    function borrowSameAsset(uint256 _assets, address _receiver, address _borrower)\n        external returns (uint256 shares);\n\n    /// @notice Allows a user to borrow assets based on the provided share amount\n    /// @param _shares Amount of shares to borrow against\n    /// @param _receiver Address to receive the borrowed assets\n    /// @param _borrower Address responsible for the borrowed assets\n    /// @return assets Amount of assets borrowed\n    function borrowShares(uint256 _shares, address _receiver, address _borrower)\n        external\n        returns (uint256 assets);\n\n    /// @notice Calculates the maximum amount an address can repay based on their debt shares\n    /// @param _borrower Address of the borrower\n    /// @return assets Maximum amount of assets the borrower can repay\n    function maxRepay(address _borrower) external view returns (uint256 assets);\n\n    /// @notice Provides an estimation of the number of shares equivalent to a given asset amount for repayment\n    /// @param _assets Amount of assets to be repaid\n    /// @return shares Estimated number of shares equivalent to the provided asset amount\n    function previewRepay(uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Repays a given asset amount and returns the equivalent number of shares\n    /// @param _assets Amount of assets to be repaid\n    /// @param _borrower Address of the borrower whose debt is being repaid\n    /// @return shares The equivalent number of shares for the provided asset amount\n    function repay(uint256 _assets, address _borrower) external returns (uint256 shares);\n\n    /// @notice Calculates the maximum number of shares that can be repaid for a given borrower\n    /// @param _borrower Address of the borrower\n    /// @return shares The maximum number of shares that can be repaid for the borrower\n    function maxRepayShares(address _borrower) external view returns (uint256 shares);\n\n    /// @notice Provides a preview of the equivalent assets for a given number of shares to repay\n    /// @param _shares Number of shares to preview repayment for\n    /// @return assets Equivalent assets for the provided shares\n    function previewRepayShares(uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice Allows a user to repay a loan using shares instead of assets\n    /// @param _shares The number of shares the borrower wants to repay with\n    /// @param _borrower The address of the borrower for whom to repay the loan\n    /// @return assets The equivalent assets amount for the provided shares\n    function repayShares(uint256 _shares, address _borrower) external returns (uint256 assets);\n\n    /// @notice Transitions assets between borrowable (collateral) and non-borrowable (protected) states\n    /// @dev This function allows assets to move between collateral and protected (non-borrowable) states without\n    /// leaving the protocol\n    /// @param _shares Amount of shares to be transitioned\n    /// @param _owner Owner of the assets being transitioned\n    /// @param _transitionFrom Specifies if the transition is from collateral or protected assets\n    /// @return assets Amount of assets transitioned\n    function transitionCollateral(uint256 _shares, address _owner, CollateralType _transitionFrom)\n        external\n        returns (uint256 assets);\n\n    /// @notice deprecated\n    function switchCollateralToThisSilo() external;\n\n    /// @notice Accrues interest for the asset and returns the accrued interest amount\n    /// @return accruedInterest The total interest accrued during this operation\n    function accrueInterest() external returns (uint256 accruedInterest);\n\n    /// @notice only for SiloConfig\n    function accrueInterestForConfig(\n        address _interestRateModel,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    ) external;\n\n    /// @notice Withdraws earned fees and distributes them to the DAO and deployer fee receivers\n    function withdrawFees() external;\n}\n"
    },
    "silo-core/contracts/interfaces/IShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\nimport {ISilo} from \"./ISilo.sol\";\n\ninterface IShareToken is IERC20Metadata {\n    struct HookSetup {\n        /// @param this is the same as in siloConfig\n        address hookReceiver;\n        /// @param hooks bitmap\n        uint24 hooksBefore;\n        /// @param hooks bitmap\n        uint24 hooksAfter;\n        /// @param tokenType must be one of this hooks values: COLLATERAL_TOKEN, PROTECTED_TOKEN, DEBT_TOKEN\n        uint24 tokenType;\n    }\n\n    struct ShareTokenStorage {\n        /// @notice Silo address for which tokens was deployed\n        ISilo silo;\n\n        /// @dev cached silo config address\n        ISiloConfig siloConfig;\n\n        /// @notice Copy of hooks setup from SiloConfig for optimisation purposes\n        HookSetup hookSetup;\n\n        bool transferWithChecks;\n    }\n\n    /// @notice Emitted every time receiver is notified about token transfer\n    /// @param notificationReceiver receiver address\n    /// @param success false if TX reverted on `notificationReceiver` side, otherwise true\n    event NotificationSent(address indexed notificationReceiver, bool success);\n\n    error OnlySilo();\n    error OnlySiloConfig();\n    error OwnerIsZero();\n    error RecipientIsZero();\n    error AmountExceedsAllowance();\n    error RecipientNotSolventAfterTransfer();\n    error SenderNotSolventAfterTransfer();\n    error ZeroTransfer();\n\n    /// @notice method for SiloConfig to synchronize hooks\n    /// @param _hooksBefore hooks bitmap to trigger hooks BEFORE action\n    /// @param _hooksAfter hooks bitmap to trigger hooks AFTER action\n    function synchronizeHooks(uint24 _hooksBefore, uint24 _hooksAfter) external;\n\n    /// @notice Mint method for Silo to create debt\n    /// @param _owner wallet for which to mint token\n    /// @param _spender wallet that asks for mint\n    /// @param _amount amount of token to be minted\n    function mint(address _owner, address _spender, uint256 _amount) external;\n\n    /// @notice Burn method for Silo to close debt\n    /// @param _owner wallet for which to burn token\n    /// @param _spender wallet that asks for burn\n    /// @param _amount amount of token to be burned\n    function burn(address _owner, address _spender, uint256 _amount) external;\n\n    /// @notice TransferFrom method for liquidation\n    /// @param _from wallet from which we transferring tokens\n    /// @param _to wallet that will get tokens\n    /// @param _amount amount of token to transfer\n    function forwardTransferFromNoChecks(address _from, address _to, uint256 _amount) external;\n\n    /// @dev Returns the amount of tokens owned by `account`.\n    /// @param _account address for which to return data\n    /// @return balance of the _account\n    /// @return totalSupply total supply of the token\n    function balanceOfAndTotalSupply(address _account) external view returns (uint256 balance, uint256 totalSupply);\n\n    /// @notice Returns silo address for which token was deployed\n    /// @return silo address\n    function silo() external view returns (ISilo silo);\n\n    function siloConfig() external view returns (ISiloConfig silo);\n\n    /// @notice Returns hook setup\n    function hookSetup() external view returns (HookSetup memory);\n\n    /// @notice Returns hook receiver address\n    function hookReceiver() external view returns (address);\n\n    /// @dev offset value uses by vaults to calculate the conversion rate between assets and shares\n    /// it determines how many shares are minted for 1 asset eg. with offset 3, 1 asset = 1000 shares\n    /// notice, that 1:1000 ratio can change for collateral shares when shares value changes eg due to interest accrual.\n    /// see openzeppelin contract: contracts/token/ERC20/extensions/ERC4626.sol for more details about offset\n    /// @notice this method is available since Silo Core v4.0.0\n    function decimalsOffset() external view returns (uint256);\n}\n"
    },
    "silo-core/contracts/interfaces/IVersioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IVersioned {\n    /// @notice Returns the version of the contract\n    /// @return version The version of the contract in format \"SiloLens v3.17.0\"\n    function VERSION() external pure returns (string memory version); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "silo-core/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IERC3156FlashBorrower {\n    /// @notice During the execution of the flashloan, Silo methods are not taking into consideration the fact,\n    /// that some (or all) tokens were transferred as flashloan, therefore some methods can return invalid state\n    /// eg. maxWithdraw can return amount that are not available to withdraw during flashlon.\n    /// @dev Receive a flash loan.\n    /// @param _initiator The initiator of the loan.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _fee The additional amount of tokens to repay.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    /// @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n    function onFlashLoan(address _initiator, address _token, uint256 _amount, uint256 _fee, bytes calldata _data)\n        external\n        returns (bytes32);\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISilo} from \"./ISilo.sol\";\nimport {ICrossReentrancyGuard} from \"./ICrossReentrancyGuard.sol\";\n\ninterface ISiloConfig is ICrossReentrancyGuard {\n    struct InitData {\n        /// @notice Can be address zero if deployer fees are not to be collected. If deployer address is zero then\n        /// deployer fee must be zero as well. Deployer will be minted an NFT that gives the right to claim deployer\n        /// fees. NFT can be transferred with the right to claim.\n        address deployer;\n\n        /// @notice Address of the hook receiver called on every before/after action on Silo. Hook contract also\n        /// implements liquidation logic and veSilo gauge connection.\n        address hookReceiver;\n\n        /// @notice Deployer's fee in 18 decimals points. Deployer will earn this fee based on the interest earned\n        /// by the Silo. Max deployer fee is set by the DAO. At deployment it is 15%.\n        uint256 deployerFee;\n\n        /// @notice DAO's fee in 18 decimals points. DAO will earn this fee based on the interest earned\n        /// by the Silo. Acceptable fee range fee is set by the DAO. Default at deployment is 5% - 50%.\n        uint256 daoFee;\n\n        /// @notice Address of the first token\n        address token0;\n\n        /// @notice Address of the solvency oracle. Solvency oracle is used to calculate LTV when deciding if borrower\n        /// is solvent or should be liquidated. Solvency oracle is optional and if not set price of 1 will be assumed.\n        address solvencyOracle0;\n\n        /// @notice Address of the maxLtv oracle. Max LTV oracle is used to calculate LTV when deciding if borrower\n        /// can borrow given amount of assets. Max LTV oracle is optional and if not set it defaults to solvency\n        /// oracle. If neither is set price of 1 will be assumed.\n        address maxLtvOracle0;\n\n        /// @notice Address of the interest rate model\n        address interestRateModel0;\n\n        /// @notice Maximum LTV for first token. maxLTV is in 18 decimals points and is used to determine, if borrower\n        /// can borrow given amount of assets. MaxLtv is in 18 decimals points. MaxLtv must be lower or equal to LT.\n        uint256 maxLtv0;\n\n        /// @notice Liquidation threshold for first token. LT is used to calculate solvency. LT is in 18 decimals\n        /// points. LT must not be lower than maxLTV.\n        uint256 lt0;\n\n        /// @notice minimal acceptable LTV after liquidation, in 18 decimals points\n        uint256 liquidationTargetLtv0;\n\n        /// @notice Liquidation fee for the first token in 18 decimals points. Liquidation fee is what liquidator earns\n        /// for repaying insolvent loan.\n        uint256 liquidationFee0;\n\n        /// @notice Flashloan fee sets the cost of taking a flashloan in 18 decimals points\n        uint256 flashloanFee0;\n\n        /// @notice Indicates if a beforeQuote on oracle contract should be called before quoting price\n        bool callBeforeQuote0;\n\n        /// @notice Address of the second token\n        address token1;\n\n        /// @notice Address of the solvency oracle. Solvency oracle is used to calculate LTV when deciding if borrower\n        /// is solvent or should be liquidated. Solvency oracle is optional and if not set price of 1 will be assumed.\n        address solvencyOracle1;\n\n        /// @notice Address of the maxLtv oracle. Max LTV oracle is used to calculate LTV when deciding if borrower\n        /// can borrow given amount of assets. Max LTV oracle is optional and if not set it defaults to solvency\n        /// oracle. If neither is set price of 1 will be assumed.\n        address maxLtvOracle1;\n\n        /// @notice Address of the interest rate model\n        address interestRateModel1;\n\n        /// @notice Maximum LTV for first token. maxLTV is in 18 decimals points and is used to determine,\n        /// if borrower can borrow given amount of assets. maxLtv is in 18 decimals points\n        uint256 maxLtv1;\n\n        /// @notice Liquidation threshold for first token. LT is used to calculate solvency. LT is in 18 decimals points\n        uint256 lt1;\n\n        /// @notice minimal acceptable LTV after liquidation, in 18 decimals points\n        uint256 liquidationTargetLtv1;\n\n        /// @notice Liquidation fee is what liquidator earns for repaying insolvent loan.\n        uint256 liquidationFee1;\n\n        /// @notice Flashloan fee sets the cost of taking a flashloan in 18 decimals points\n        uint256 flashloanFee1;\n\n        /// @notice Indicates if a beforeQuote on oracle contract should be called before quoting price\n        bool callBeforeQuote1;\n    }\n\n    struct ConfigData {\n        uint256 daoFee;\n        uint256 deployerFee;\n        address silo;\n        address token;\n        address protectedShareToken;\n        address collateralShareToken;\n        address debtShareToken;\n        address solvencyOracle;\n        address maxLtvOracle;\n        address interestRateModel;\n        uint256 maxLtv;\n        uint256 lt;\n        uint256 liquidationTargetLtv;\n        uint256 liquidationFee;\n        uint256 flashloanFee;\n        address hookReceiver;\n        bool callBeforeQuote;\n    }\n\n    struct DepositConfig {\n        address silo;\n        address token;\n        address collateralShareToken;\n        address protectedShareToken;\n        uint256 daoFee;\n        uint256 deployerFee;\n        address interestRateModel;\n    }\n\n    error OnlySilo();\n    error OnlySiloOrTokenOrHookReceiver();\n    error WrongSilo();\n    error OnlyDebtShareToken();\n    error DebtExistInOtherSilo();\n    error FeeTooHigh();\n    error Deprecated();\n\n    /// @dev It should be called on debt transfer (debt share token transfer).\n    /// In the case if the`_recipient` doesn't have configured a collateral silo,\n    /// it will be set to the collateral silo of the `_sender`.\n    /// @param _sender sender address\n    /// @param _recipient recipient address\n    function onDebtTransfer(address _sender, address _recipient) external;\n\n    /// @notice deprecated\n    function setThisSiloAsCollateralSilo(address _borrower) external returns (bool collateralSiloChanged);\n\n    /// @notice Set collateral silo\n    /// @dev Revert if msg.sender is not a SILO_0 or SILO_1.\n    /// @dev Always set collateral silo opposite to the msg.sender.\n    /// @param _borrower borrower address\n    /// @return collateralSiloChanged TRUE if collateral silo changed\n    function setOtherSiloAsCollateralSilo(address _borrower) external returns (bool collateralSiloChanged);\n\n    /// @notice Accrue interest for the silo\n    /// @param _silo silo for which accrue interest\n    function accrueInterestForSilo(address _silo) external;\n\n    /// @notice Accrue interest for both silos (SILO_0 and SILO_1 in a config)\n    function accrueInterestForBothSilos() external;\n\n    /// @notice Retrieves the collateral silo for a specific borrower.\n    /// @dev As a user can deposit into `Silo0` and `Silo1`, this property specifies which Silo\n    /// will be used as collateral for the debt. Later on, it will be used for max LTV and solvency checks.\n    /// After being set, the collateral silo is never set to `address(0)` again but such getters as\n    /// `getConfigsForSolvency`, `getConfigsForBorrow`, `getConfigsForWithdraw` will return empty\n    /// collateral silo config if borrower doesn't have debt.\n    ///\n    /// In the SiloConfig collateral silo is set by the following functions:\n    /// `onDebtTransfer` - only if the recipient doesn't have collateral silo set (inherits it from the sender)\n    /// This function is called on debt share token transfer (debt transfer).\n    /// `setOtherSiloAsCollateralSilo` - sets the opposite silo as collateral from the one that calls the function.\n    ///\n    /// In the Silo collateral silo is set by the following functions:\n    /// `borrow` - always sets opposite silo as collateral.\n    /// If Silo0 borrows, then Silo1 will be collateral and vice versa.\n    /// @param _borrower The address of the borrower for which the collateral silo is being retrieved\n    /// @return collateralSilo The address of the collateral silo for the specified borrower\n    function borrowerCollateralSilo(address _borrower) external view returns (address collateralSilo);\n\n    /// @notice Retrieves the silo ID\n    /// @dev Each silo is assigned a unique ID. ERC-721 token is minted with identical ID to deployer.\n    /// An owner of that token receives the deployer fees.\n    /// @return siloId The ID of the silo\n    function SILO_ID() external view returns (uint256 siloId); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Retrieves the addresses of the two silos\n    /// @return silo0 The address of the first silo\n    /// @return silo1 The address of the second silo\n    function getSilos() external view returns (address silo0, address silo1);\n\n    /// @notice Retrieves the asset associated with a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which the associated asset is being retrieved\n    /// @return asset The address of the asset associated with the specified silo\n    function getAssetForSilo(address _silo) external view returns (address asset);\n\n    /// @notice Verifies if the borrower has debt in other silo by checking the debt share token balance\n    /// @param _thisSilo The address of the silo in respect of which the debt is checked\n    /// @param _borrower The address of the borrower for which the debt is checked\n    /// @return hasDebt true if the borrower has debt in other silo\n    function hasDebtInOtherSilo(address _thisSilo, address _borrower) external view returns (bool hasDebt);\n\n    /// @notice Retrieves the debt silo associated with a specific borrower\n    /// @dev This function reverts if debt present in two silo (should not happen)\n    /// @param _borrower The address of the borrower for which the debt silo is being retrieved\n    function getDebtSilo(address _borrower) external view returns (address debtSilo);\n\n    /// @notice Retrieves configuration data for both silos. First config is for the silo that is asking for configs.\n    /// @param borrower borrower address for which debtConfig will be returned\n    /// @return collateralConfig The configuration data for collateral silo (empty if there is no debt).\n    /// @return debtConfig The configuration data for debt silo (empty if there is no debt).\n    function getConfigsForSolvency(address borrower)\n        external\n        view\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig);\n\n    /// @notice Retrieves configuration data for a specific silo\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _silo The address of the silo for which configuration data is being retrieved\n    /// @return config The configuration data for the specified silo\n    function getConfig(address _silo) external view returns (ConfigData memory config);\n\n    /// @notice Retrieves configuration data for a specific silo for withdraw fn.\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _silo The address of the silo for which configuration data is being retrieved\n    /// @return depositConfig The configuration data for the specified silo (always config for `_silo`)\n    /// @return collateralConfig The configuration data for the collateral silo (empty if there is no debt)\n    /// @return debtConfig The configuration data for the debt silo (empty if there is no debt)\n    function getConfigsForWithdraw(address _silo, address _borrower) external view returns (\n        DepositConfig memory depositConfig,\n        ConfigData memory collateralConfig,\n        ConfigData memory debtConfig\n    );\n\n    /// @notice Retrieves configuration data for a specific silo for borrow fn.\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _debtSilo The address of the silo for which configuration data is being retrieved\n    /// @return collateralConfig The configuration data for the collateral silo (always other than `_debtSilo`)\n    /// @return debtConfig The configuration data for the debt silo (always config for `_debtSilo`)\n    function getConfigsForBorrow(address _debtSilo)\n        external\n        view\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig);\n\n    /// @notice Retrieves fee-related information for a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which fee-related information is being retrieved.\n    /// @return daoFee The DAO fee percentage in 18 decimals points.\n    /// @return deployerFee The deployer fee percentage in 18 decimals points.\n    /// @return flashloanFee The flashloan fee percentage in 18 decimals points.\n    /// @return asset The address of the asset associated with the specified silo.\n    function getFeesWithAsset(address _silo)\n        external\n        view\n        returns (uint256 daoFee, uint256 deployerFee, uint256 flashloanFee, address asset);\n\n    /// @notice Retrieves share tokens associated with a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which share tokens are being retrieved\n    /// @return protectedShareToken The address of the protected (non-borrowable) share token\n    /// @return collateralShareToken The address of the collateral share token\n    /// @return debtShareToken The address of the debt share token\n    function getShareTokens(address _silo)\n        external\n        view\n        returns (address protectedShareToken, address collateralShareToken, address debtShareToken);\n\n    /// @notice Retrieves the share token and the silo token associated with a specific silo\n    /// @param _silo The address of the silo for which the share token and silo token are being retrieved\n    /// @param _collateralType The type of collateral\n    /// @return shareToken The address of the share token (collateral or protected collateral)\n    /// @return asset The address of the silo token\n    function getCollateralShareTokenAndAsset(address _silo, ISilo.CollateralType _collateralType)\n        external\n        view\n        returns (address shareToken, address asset);\n\n    /// @notice Retrieves the share token and the silo token associated with a specific silo\n    /// @param _silo The address of the silo for which the share token and silo token are being retrieved\n    /// @return shareToken The address of the share token (debt)\n    /// @return asset The address of the silo token\n    function getDebtShareTokenAndAsset(address _silo)\n        external\n        view\n        returns (address shareToken, address asset);\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC721} from \"openzeppelin5/interfaces/IERC721.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\ninterface ISiloFactory is IERC721 {\n    struct Range {\n        uint128 min;\n        uint128 max;\n    }\n\n    /// @notice Emitted on the creation of a Silo.\n    /// @param implementation Address of the Silo implementation.\n    /// @param token0 Address of the first Silo token.\n    /// @param token1 Address of the second Silo token.\n    /// @param silo0 Address of the first Silo.\n    /// @param silo1 Address of the second Silo.\n    /// @param siloConfig Address of the SiloConfig.\n    event NewSilo(\n        address indexed implementation,\n        address indexed token0,\n        address indexed token1,\n        address silo0,\n        address silo1,\n        address siloConfig\n    );\n\n    /// @notice Emitted on the creation of a Silo, note that collateral share token == silo\n    event NewSiloShareTokens(\n        address indexed protectedShareToken, \n        address indexed collateralShareToken,\n        address indexed debtShareToken\n    );\n\n    event NewSiloHook(address indexed silo, address indexed hook);\n\n    event BaseURI(string newBaseURI);\n\n    /// @notice Emitted on the update of DAO fee.\n    /// @param minDaoFee Value of the new minimal DAO fee.\n    /// @param maxDaoFee Value of the new maximal DAO fee.\n    event DaoFeeChanged(uint128 minDaoFee, uint128 maxDaoFee);\n\n    /// @notice Emitted on the update of max deployer fee.\n    /// @param maxDeployerFee Value of the new max deployer fee.\n    event MaxDeployerFeeChanged(uint256 maxDeployerFee);\n\n    /// @notice Emitted on the update of max flashloan fee.\n    /// @param maxFlashloanFee Value of the new max flashloan fee.\n    event MaxFlashloanFeeChanged(uint256 maxFlashloanFee);\n\n    /// @notice Emitted on the update of max liquidation fee.\n    /// @param maxLiquidationFee Value of the new max liquidation fee.\n    event MaxLiquidationFeeChanged(uint256 maxLiquidationFee);\n\n    /// @notice Emitted on the change of DAO fee receiver.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChanged(address daoFeeReceiver);\n\n    /// @notice Emitted on the change of DAO fee receiver for particular silo\n    /// @param silo Address for which new DAO fee receiver is set.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChangedForSilo(address silo, address daoFeeReceiver);\n\n    /// @notice Emitted on the change of DAO fee receiver for particular asset\n    /// @param asset Address for which new DAO fee receiver is set.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChangedForAsset(address asset, address daoFeeReceiver);\n\n    error MissingHookReceiver();\n    error ZeroAddress();\n    error DaoFeeReceiverZeroAddress();\n    error SameDaoFeeReceiver();\n    error EmptyToken0();\n    error EmptyToken1();\n    error MaxFeeExceeded();\n    error InvalidFeeRange();\n    error SameAsset();\n    error SameRange();\n    error InvalidIrm();\n    error InvalidMaxLtv();\n    error InvalidLt();\n    error InvalidDeployer();\n    error DaoMinRangeExceeded();\n    error DaoMaxRangeExceeded();\n    error MaxDeployerFeeExceeded();\n    error MaxFlashloanFeeExceeded();\n    error MaxLiquidationFeeExceeded();\n    error InvalidCallBeforeQuote();\n    error OracleMisconfiguration();\n    error InvalidQuoteToken();\n    error HookIsZeroAddress();\n    error LiquidationTargetLtvTooHigh();\n    error NotYourSilo();\n    error ConfigMismatchSilo();\n    error ConfigMismatchShareProtectedToken();\n    error ConfigMismatchShareDebtToken();\n    error ConfigMismatchShareCollateralToken();\n\n    /// @notice Create a new Silo.\n    /// @param _siloConfig Silo configuration.\n    /// @param _siloImpl Address of the `Silo` implementation.\n    /// @param _shareProtectedCollateralTokenImpl Address of the `ShareProtectedCollateralToken` implementation.\n    /// @param _shareDebtTokenImpl Address of the `ShareDebtToken` implementation.\n    /// @param _deployer Address of the deployer.\n    /// @param _creator Address of the creator.\n    function createSilo(\n        ISiloConfig _siloConfig,\n        address _siloImpl,\n        address _shareProtectedCollateralTokenImpl,\n        address _shareDebtTokenImpl,\n        address _deployer,\n        address _creator\n    )\n        external;\n\n    /// @notice NFT ownership represents the deployer fee receiver for the each Silo ID.  After burning, \n    /// the deployer fee is sent to the DAO. Burning doesn't affect Silo's behavior. It is only about fee distribution.\n    /// @param _siloIdToBurn silo ID to burn.\n    function burn(uint256 _siloIdToBurn) external;\n\n    /// @notice Update the value of DAO fee. Updated value will be used only for a new Silos.\n    /// Previously deployed SiloConfigs are immutable.\n    /// @param _minFee Value of the new DAO minimal fee.\n    /// @param _maxFee Value of the new DAO maximal fee.\n    function setDaoFee(uint128 _minFee, uint128 _maxFee) external;\n\n    /// @notice Set the default DAO fee receiver.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiver(address _newDaoFeeReceiver) external;\n\n    /// @notice Set the new DAO fee receiver for asset, this setup will be used when fee receiver for silo is empty.\n    /// @param _asset Address for which new DAO fee receiver is set.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiverForAsset(address _asset, address _newDaoFeeReceiver) external;\n\n    /// @notice Set the new DAO fee receiver for silo. This setup has highest priority.\n    /// @param _silo Address for which new DAO fee receiver is set.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiverForSilo(address _silo, address _newDaoFeeReceiver) external;\n\n    /// @notice Update the value of max deployer fee. Updated value will be used only for a new Silos max deployer\n    /// fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxDeployerFee Value of the new max deployer fee.\n    function setMaxDeployerFee(uint256 _newMaxDeployerFee) external;\n\n    /// @notice Update the value of max flashloan fee. Updated value will be used only for a new Silos max flashloan\n    /// fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxFlashloanFee Value of the new max flashloan fee.\n    function setMaxFlashloanFee(uint256 _newMaxFlashloanFee) external;\n\n    /// @notice Update the value of max liquidation fee. Updated value will be used only for a new Silos max\n    /// liquidation fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxLiquidationFee Value of the new max liquidation fee.\n    function setMaxLiquidationFee(uint256 _newMaxLiquidationFee) external;\n   \n    /// @notice Update the base URI.\n    /// @param _newBaseURI Value of the new base URI.\n    function setBaseURI(string calldata _newBaseURI) external;\n\n    /// @notice Acceptable DAO fee range for new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function daoFeeRange() external view returns (Range memory);\n\n    /// @notice Max deployer fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxDeployerFee() external view returns (uint256);\n\n    /// @notice Max flashloan fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxFlashloanFee() external view returns (uint256);\n\n    /// @notice Max liquidation fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxLiquidationFee() external view returns (uint256);\n\n    /// @notice The recipient of DAO fees.\n    function daoFeeReceiver() external view returns (address);\n\n    /// @notice Get SiloConfig address by Silo id.\n    function idToSiloConfig(uint256 _id) external view returns (address);\n\n    /// @notice Get the counter of silos created by the wallet.\n    function creatorSiloCounter(address _creator) external view returns (uint256);\n\n    /// @notice Do not use this method to check if silo is secure. Anyone can deploy silo with any configuration\n    /// and implementation. Most critical part of verification would be to check who deployed it.\n    /// @dev True if the address was deployed using SiloFactory.\n    function isSilo(address _silo) external view returns (bool);\n\n    /// @notice Id of a next Silo to be deployed. This is an ID of non-existing Silo outside of createSilo\n    /// function call. ID of a first Silo is 1.\n    function getNextSiloId() external view returns (uint256);\n\n    /// @notice Get the DAO and deployer fee receivers for a particular Silo address.\n    /// @param _silo Silo address.\n    /// @return dao DAO fee receiver.\n    /// @return deployer Deployer fee receiver.\n    function getFeeReceivers(address _silo) external view returns (address dao, address deployer);\n\n    /// @notice Validate InitData for a new Silo. Config will be checked for the fee limits, missing parameters.\n    /// @param _initData Silo init data.\n    function validateSiloInitData(ISiloConfig.InitData memory _initData) external view returns (bool);\n}\n"
    },
    "silo-core/contracts/utils/ShareCollateralToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {ShareTokenLib} from \"../lib/ShareTokenLib.sol\";\nimport {SiloMathLib} from \"../lib/SiloMathLib.sol\";\nimport {ShareCollateralTokenLib} from \"../lib/ShareCollateralTokenLib.sol\";\nimport {IShareToken, ShareToken, ISilo} from \"./ShareToken.sol\";\nimport {IVersioned} from \"../interfaces/IVersioned.sol\";\n\n/// @title ShareCollateralToken\n/// @notice ERC20 compatible token representing collateral in Silo\n/// @custom:security-contact security@silo.finance\nabstract contract ShareCollateralToken is ShareToken {\n    /// @inheritdoc IShareToken\n    function mint(address _owner, address /* _spender */, uint256 _amount) external virtual override onlySilo {\n        _mint(_owner, _amount);\n    }\n\n    /// @inheritdoc IShareToken\n    function burn(address _owner, address _spender, uint256 _amount) external virtual override onlySilo {\n        if (_owner != _spender) _spendAllowance(_owner, _spender, _amount);\n        _burn(_owner, _amount);\n    }\n\n    /// @inheritdoc IVersioned\n    function VERSION() external pure virtual returns (string memory) { // solhint-disable-line func-name-mixedcase\n        return \"ShareCollateralToken 4.0.0\";\n    }\n\n    /// @dev Check if sender is solvent after the transfer\n    function _afterTokenTransfer(address _sender, address _recipient, uint256 _amount) internal virtual override {\n        IShareToken.ShareTokenStorage storage $ = ShareTokenLib.getShareTokenStorage();\n\n        // for minting or burning, Silo is responsible to check all necessary conditions\n        // for transfer make sure that _sender is solvent after transfer\n        if (ShareTokenLib.isTransfer(_sender, _recipient) && $.transferWithChecks) {\n            bool senderIsSolvent = ShareCollateralTokenLib.isSolventAfterCollateralTransfer(_sender);\n            require(senderIsSolvent, IShareToken.SenderNotSolventAfterTransfer());\n        }\n\n        ShareToken._afterTokenTransfer(_sender, _recipient, _amount);\n    }\n}\n"
    },
    "silo-core/contracts/lib/Actions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.28;\n\n// solhint-disable ordering\n\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"openzeppelin5/utils/Address.sol\";\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {IInterestRateModelV2} from \"../interfaces/IInterestRateModelV2.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {IERC3156FlashBorrower} from \"../interfaces/IERC3156FlashBorrower.sol\";\nimport {IHookReceiver} from \"../interfaces/IHookReceiver.sol\";\n\nimport {SiloERC4626Lib} from \"./SiloERC4626Lib.sol\";\nimport {SiloSolvencyLib} from \"./SiloSolvencyLib.sol\";\nimport {SiloLendingLib} from \"./SiloLendingLib.sol\";\nimport {SiloStdLib} from \"./SiloStdLib.sol\";\nimport {Hook} from \"./Hook.sol\";\nimport {CallBeforeQuoteLib} from \"./CallBeforeQuoteLib.sol\";\nimport {NonReentrantLib} from \"./NonReentrantLib.sol\";\nimport {ShareTokenLib} from \"./ShareTokenLib.sol\";\nimport {SiloStorageLib} from \"./SiloStorageLib.sol\";\nimport {Views} from \"./Views.sol\";\nimport {Rounding} from \"./Rounding.sol\";\n\nlibrary Actions {\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using Hook for uint256;\n    using Hook for uint24;\n    using CallBeforeQuoteLib for ISiloConfig.ConfigData;\n\n    bytes32 internal constant _FLASHLOAN_CALLBACK = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    error FeeOverflow();\n    error FlashLoanNotPossible();\n\n    /// @notice Initialize Silo\n    /// @param _siloConfig Address of ISiloConfig with full configuration for this Silo\n    /// @return hookReceiver Address of the hook receiver for the silo\n    function initialize(ISiloConfig _siloConfig) external returns (address hookReceiver) {\n        IShareToken.ShareTokenStorage storage _sharedStorage = ShareTokenLib.getShareTokenStorage();\n\n        require(address(_sharedStorage.siloConfig) == address(0), ISilo.SiloInitialized());\n\n        ISiloConfig.ConfigData memory configData = _siloConfig.getConfig(address(this));\n\n        _sharedStorage.siloConfig = _siloConfig;\n\n        return configData.hookReceiver;\n    }\n\n    /// @notice Implements IERC4626.deposit for protected (non-borrowable) and borrowable collateral\n    /// @dev Reverts for debt asset type\n    /// @param _assets Amount of assets to deposit (0 if `_shares` specified)\n    /// @param _shares shares expected for the deposit  (0 if `_assets` specified)\n    /// @param _receiver Address to receive the deposit shares\n    /// @param _collateralType Type of collateral (Protected or Collateral)\n    /// @return assets Amount of assets deposited\n    /// @return shares Amount of shares minted due to deposit\n    function deposit(\n        uint256 _assets,\n        uint256 _shares,\n        address _receiver,\n        ISilo.CollateralType _collateralType\n    )\n        external\n        returns (uint256 assets, uint256 shares)\n    {\n        _hookCallBeforeDeposit(_collateralType, _assets, _shares, _receiver);\n\n        ISiloConfig siloConfig = ShareTokenLib.siloConfig();\n\n        siloConfig.turnOnReentrancyProtection();\n        siloConfig.accrueInterestForSilo(address(this));\n\n        (\n            address shareToken, address asset\n        ) = siloConfig.getCollateralShareTokenAndAsset(address(this), _collateralType);\n\n        (assets, shares) = SiloERC4626Lib.deposit({\n            _token: asset,\n            _depositor: msg.sender,\n            _assets: _assets,\n            _shares: _shares,\n            _receiver: _receiver,\n            _collateralShareToken: IShareToken(shareToken),\n            _collateralType: _collateralType\n        });\n\n        siloConfig.turnOffReentrancyProtection();\n\n        _hookCallAfterDeposit(_collateralType, _assets, _shares, _receiver, assets, shares);\n    }\n\n    /// @notice Implements IERC4626.withdraw for protected (non-borrowable) and borrowable collateral\n    /// @dev Reverts for debt asset type\n    /// @param _args Contains withdrawal parameters:\n    /// - `assets`: Amount of assets to withdraw (0 if `_shares` specified)\n    /// - `shares`: Amount of shares burnt for the withdrawal (0 if `_assets` specified)\n    /// - `receiver`: Address to receive withdrawn assets\n    /// - `owner`: Owner of the assets being withdrawn\n    /// - `spender`: Caller executing the withdrawal\n    /// - `collateralType`: Specifies whether withdrawal is protected or borrowable collateral\n    /// @return assets Amount of assets withdrawn\n    /// @return shares Amount of shares burnt during withdrawal\n    function withdraw(ISilo.WithdrawArgs calldata _args)\n        external\n        returns (uint256 assets, uint256 shares)\n    {\n        _hookCallBeforeWithdraw(_args);\n\n        ISiloConfig siloConfig = ShareTokenLib.siloConfig();\n\n        siloConfig.turnOnReentrancyProtection();\n        siloConfig.accrueInterestForBothSilos();\n\n        ISiloConfig.DepositConfig memory depositConfig;\n        ISiloConfig.ConfigData memory collateralConfig;\n        ISiloConfig.ConfigData memory debtConfig;\n\n        (depositConfig, collateralConfig, debtConfig) = siloConfig.getConfigsForWithdraw(address(this), _args.owner);\n\n        (assets, shares) = SiloERC4626Lib.withdraw(\n            depositConfig.token,\n            _args.collateralType == ISilo.CollateralType.Collateral\n                ? depositConfig.collateralShareToken\n                : depositConfig.protectedShareToken,\n            _args\n        );\n\n        if (depositConfig.silo == collateralConfig.silo) {\n            // If deposit is collateral, then check the solvency.\n            _checkSolvencyWithoutAccruingInterest(collateralConfig, debtConfig, _args.owner);\n        }\n\n        siloConfig.turnOffReentrancyProtection();\n\n        _hookCallAfterWithdraw(_args, assets, shares);\n    }\n\n    /// @notice Allows an address to borrow a specified amount of assets\n    /// @param _args Contains the borrowing parameters:\n    /// - `assets`: Number of assets the borrower intends to borrow (0 if `_shares` specified)\n    /// - `shares`: Number of shares corresponding to the assets being borrowed (0 if `_assets` specified)\n    /// - `receiver`: Address receiving the borrowed assets\n    /// - `borrower`: Address of the borrower\n    /// @return assets Amount of assets borrowed\n    /// @return shares Amount of shares minted for the borrowed assets\n    /// @return collateralTypeChanged TRUE if action changed collateral type\n    function borrow(ISilo.BorrowArgs memory _args)\n        external\n        returns (uint256 assets, uint256 shares, bool collateralTypeChanged)\n    {\n        _hookCallBeforeBorrow(_args, Hook.BORROW);\n\n        ISiloConfig siloConfig = ShareTokenLib.siloConfig();\n\n        require(!siloConfig.hasDebtInOtherSilo(address(this), _args.borrower), ISilo.BorrowNotPossible());\n\n        siloConfig.turnOnReentrancyProtection();\n        siloConfig.accrueInterestForBothSilos();\n        collateralTypeChanged = siloConfig.setOtherSiloAsCollateralSilo(_args.borrower);\n\n        ISiloConfig.ConfigData memory collateralConfig;\n        ISiloConfig.ConfigData memory debtConfig;\n\n        (collateralConfig, debtConfig) = siloConfig.getConfigsForBorrow({_debtSilo: address(this)});\n\n        (assets, shares) = SiloLendingLib.borrow(\n            debtConfig.debtShareToken,\n            debtConfig.token,\n            msg.sender,\n            _args\n        );\n\n        _checkLTVWithoutAccruingInterest(collateralConfig, debtConfig, _args.borrower);\n\n        siloConfig.turnOffReentrancyProtection();\n\n        _hookCallAfterBorrow(_args, Hook.BORROW, assets, shares);\n    }\n\n    /// @notice Repays a given asset amount and returns the equivalent number of shares\n    /// @param _assets Amount of assets to be repaid\n    /// @param _borrower Address of the borrower whose debt is being repaid\n    /// @param _repayer Address of the repayer who repay debt\n    /// @return assets number of assets that had been repay\n    /// @return shares number of shares that had been repay\n    // solhint-disable-next-line function-max-lines\n    function repay(\n        uint256 _assets,\n        uint256 _shares,\n        address _borrower,\n        address _repayer\n    )\n        external\n        returns (uint256 assets, uint256 shares)\n    {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n\n        if (_shareStorage.hookSetup.hooksBefore.matchAction(Hook.REPAY)) {\n            bytes memory data = abi.encodePacked(_assets, _shares, _borrower, _repayer);\n            IHookReceiver(_shareStorage.hookSetup.hookReceiver).beforeAction(address(this), Hook.REPAY, data);\n        }\n\n        ISiloConfig siloConfig = _shareStorage.siloConfig;\n\n        siloConfig.turnOnReentrancyProtection();\n        siloConfig.accrueInterestForSilo(address(this));\n\n        (address debtShareToken, address debtAsset) = siloConfig.getDebtShareTokenAndAsset(address(this));\n\n        (assets, shares) = SiloLendingLib.repay(\n            IShareToken(debtShareToken), debtAsset, _assets, _shares, _borrower, _repayer\n        );\n\n        siloConfig.turnOffReentrancyProtection();\n\n        if (_shareStorage.hookSetup.hooksAfter.matchAction(Hook.REPAY)) {\n            bytes memory data = abi.encodePacked(_assets, _shares, _borrower, _repayer, assets, shares);\n            IHookReceiver(_shareStorage.hookSetup.hookReceiver).afterAction(address(this), Hook.REPAY, data);\n        }\n    }\n    /// @notice Transitions assets between collateral (borrowable) and protected (non-borrowable) states\n    /// @dev This method allows assets to switch states without leaving the protocol\n    /// @param _args Contains the transition parameters:\n    /// - `shares`: Amount of shares to transition\n    /// - `owner`: Owner of the assets being transitioned\n    /// - `transitionFrom`: Specifies whether transitioning from collateral or protected\n    /// @return assets Amount of assets transitioned\n    /// @return toShares Equivalent shares gained from the transition\n    // solhint-disable-next-line function-max-lines\n    function transitionCollateral(ISilo.TransitionCollateralArgs memory _args)\n        external\n        returns (uint256 assets, uint256 toShares)\n    {\n        _hookCallBeforeTransitionCollateral(_args);\n\n        ISiloConfig siloConfig = ShareTokenLib.siloConfig();\n\n        siloConfig.turnOnReentrancyProtection();\n        siloConfig.accrueInterestForBothSilos();\n\n        (\n            ISiloConfig.DepositConfig memory depositConfig,\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        ) = siloConfig.getConfigsForWithdraw(address(this), _args.owner);\n\n        uint256 shares;\n\n        // transition collateral withdraw\n        address shareTokenFrom = _args.transitionFrom == ISilo.CollateralType.Collateral\n            ? depositConfig.collateralShareToken\n            : depositConfig.protectedShareToken;\n\n        (assets, shares) = SiloERC4626Lib.withdraw({\n            _asset: address(0), // empty token because we don't want to transfer\n            _shareToken: shareTokenFrom,\n            _args: ISilo.WithdrawArgs({\n                assets: 0,\n                shares: _args.shares,\n                owner: _args.owner,\n                receiver: _args.owner,\n                spender: msg.sender,\n                collateralType: _args.transitionFrom\n            })\n        });\n\n        // transition collateral deposit\n        (ISilo.CollateralType depositType, address shareTokenTo) =\n            _args.transitionFrom == ISilo.CollateralType.Collateral\n                ? (ISilo.CollateralType.Protected, depositConfig.protectedShareToken)\n                : (ISilo.CollateralType.Collateral, depositConfig.collateralShareToken);\n\n        (assets, toShares) = SiloERC4626Lib.deposit({\n            _token: address(0), // empty token because we don't want to transfer\n            _depositor: msg.sender,\n            _assets: assets,\n            _shares: 0,\n            _receiver: _args.owner,\n            _collateralShareToken: IShareToken(shareTokenTo),\n            _collateralType: depositType\n        });\n\n        // If deposit is collateral, then check the solvency.\n        if (depositConfig.silo == collateralConfig.silo) {\n            _checkSolvencyWithoutAccruingInterest(collateralConfig, debtConfig, _args.owner);\n        }\n\n        siloConfig.turnOffReentrancyProtection();\n\n        _hookCallAfterTransitionCollateral(_args, toShares, assets);\n    }\n\n    /// @notice Executes a flash loan, sending the requested amount to the receiver and expecting it back with a fee\n    /// @param _receiver The entity that will receive the flash loan and is expected to return it with a fee\n    /// @param _token The token that is being borrowed in the flash loan\n    /// @param _amount The amount of tokens to be borrowed\n    /// @param _data Additional data to be passed to the flash loan receiver\n    /// @return success A boolean indicating if the flash loan was successful\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    )\n        external\n        returns (bool success)\n    {\n        require(_amount != 0, ISilo.ZeroAmount());\n\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n\n        if (_shareStorage.hookSetup.hooksBefore.matchAction(Hook.FLASH_LOAN)) {\n            bytes memory data = abi.encodePacked(_receiver, _token, _amount);\n            IHookReceiver(_shareStorage.hookSetup.hookReceiver).beforeAction(address(this), Hook.FLASH_LOAN, data);\n        }\n\n        // flashFee will revert for wrong token\n        uint256 fee = SiloStdLib.flashFee(_shareStorage.siloConfig, _token, _amount);\n\n        require(fee <= type(uint192).max, FeeOverflow());\n        // this check also verify if token is correct\n        require(_amount <= Views.maxFlashLoan(_token), FlashLoanNotPossible());\n\n        // cast safe, because we checked `fee > type(uint192).max`\n        SiloStorageLib.getSiloStorage().daoAndDeployerRevenue += uint192(fee);\n\n        IERC20(_token).safeTransfer(address(_receiver), _amount);\n\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) == _FLASHLOAN_CALLBACK,\n            ISilo.FlashloanFailed()\n        );\n\n        IERC20(_token).safeTransferFrom(address(_receiver), address(this), _amount + fee);\n\n        if (_shareStorage.hookSetup.hooksAfter.matchAction(Hook.FLASH_LOAN)) {\n            bytes memory data = abi.encodePacked(_receiver, _token, _amount, fee);\n            IHookReceiver(_shareStorage.hookSetup.hookReceiver).afterAction(address(this), Hook.FLASH_LOAN, data);\n        }\n\n        success = true;\n    }\n\n    /// @notice Withdraws accumulated fees and distributes them proportionally to the DAO and deployer\n    /// @dev This function takes into account scenarios where either the DAO or deployer may not be set, distributing\n    /// accordingly\n    /// @param _silo Silo address\n    // solhint-disable-next-line function-max-lines\n    function withdrawFees(ISilo _silo)\n        external\n        returns (uint256 daoRevenue, uint256 deployerRevenue, bool redirectedDeployerFees)\n    {\n        ISiloConfig siloConfig = ShareTokenLib.siloConfig();\n        siloConfig.turnOnReentrancyProtection();\n\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        uint256 earnedFees = $.daoAndDeployerRevenue;\n        require(earnedFees != 0, ISilo.EarnedZero());\n\n        (\n            address daoFeeReceiver,\n            address deployerFeeReceiver,\n            uint256 daoFee,\n            uint256 deployerFee,\n            address asset\n        ) = SiloStdLib.getFeesAndFeeReceiversWithAsset(_silo);\n\n        uint256 availableLiquidity;\n        uint256 siloBalance = IERC20(asset).balanceOf(address(this));\n\n        uint256 protectedAssets = $.totalAssets[ISilo.AssetType.Protected];\n\n        // we will never underflow because `_protectedAssets` is always less/equal `siloBalance`\n        unchecked { availableLiquidity = protectedAssets > siloBalance ? 0 : siloBalance - protectedAssets; }\n\n        require(availableLiquidity != 0, ISilo.NoLiquidity());\n\n        if (earnedFees > availableLiquidity) earnedFees = availableLiquidity;\n\n        // we will never underflow because earnedFees max value is `daoAndDeployerRevenue`\n        unchecked { $.daoAndDeployerRevenue -= uint192(earnedFees); }\n\n        daoRevenue = earnedFees;\n\n        if (deployerFeeReceiver != address(0)) {\n            // split fees proportionally\n            unchecked {\n                // fees are % in decimal point so safe to uncheck\n                // we prioritizing DAO fee that's why Rounding.Ceil (UP)\n                daoRevenue = Math.mulDiv(daoRevenue, daoFee, daoFee + deployerFee, Rounding.DAO_REVENUE);\n                // `daoRevenue` is chunk of `earnedFees`, so safe to uncheck\n                deployerRevenue = earnedFees - daoRevenue;\n            }\n\n            // trying to transfer to deployer (it might fail)\n            // if transfer to deployer fails, send their portion to the DAO instead\n            redirectedDeployerFees = !_safeTransferInternal(IERC20(asset), deployerFeeReceiver, deployerRevenue);\n        }\n\n        IERC20(asset).safeTransfer(daoFeeReceiver, redirectedDeployerFees ? earnedFees : daoRevenue);\n\n        siloConfig.turnOffReentrancyProtection();\n    }\n\n    /// @notice Update hooks configuration for Silo\n    /// @dev This function must be called after the hooks configuration is changed in the hook receiver\n    function updateHooks() external returns (uint24 hooksBefore, uint24 hooksAfter) {\n        ISiloConfig siloConfig = ShareTokenLib.siloConfig();\n\n        NonReentrantLib.nonReentrant(siloConfig);\n\n        ISiloConfig.ConfigData memory cfg = siloConfig.getConfig(address(this));\n\n        if (cfg.hookReceiver == address(0)) return (0, 0);\n\n        (hooksBefore, hooksAfter) = IHookReceiver(cfg.hookReceiver).hookReceiverConfig(address(this));\n\n        IShareToken(cfg.collateralShareToken).synchronizeHooks(hooksBefore, hooksAfter);\n        IShareToken(cfg.protectedShareToken).synchronizeHooks(hooksBefore, hooksAfter);\n        IShareToken(cfg.debtShareToken).synchronizeHooks(hooksBefore, hooksAfter);\n    }\n\n    /// @notice Method for HookReceiver only to call on behalf of Silo\n    /// @param _target address of the contract to call\n    /// @param _value amount of ETH to send\n    /// @param _callType type of the call (Call or Delegatecall)\n    /// @param _input calldata for the call\n    function callOnBehalfOfSilo(address _target, uint256 _value, ISilo.CallType _callType, bytes calldata _input)\n        internal\n        returns (bool success, bytes memory result)\n    {\n        require(\n            msg.sender == address(ShareTokenLib.getShareTokenStorage().hookSetup.hookReceiver),\n            ISilo.OnlyHookReceiver()\n        );\n\n        // Silo will not send back any ether leftovers after the call.\n        // The hook receiver should request the ether if needed in a separate call.\n        if (_callType == ISilo.CallType.Delegatecall) {\n            (success, result) = _target.delegatecall(_input); // solhint-disable-line avoid-low-level-calls\n        } else {\n            (success, result) = _target.call{value: _value}(_input); // solhint-disable-line avoid-low-level-calls\n        }\n    }\n\n    // this method expect interest to be already accrued\n    function _checkSolvencyWithoutAccruingInterest(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _user\n    ) private {\n        if (_debtConfig.silo != _collateralConfig.silo) {\n            _collateralConfig.callSolvencyOracleBeforeQuote();\n            _debtConfig.callSolvencyOracleBeforeQuote();\n        }\n\n        bool userIsSolvent = SiloSolvencyLib.isSolvent(\n            _collateralConfig, _debtConfig, _user, ISilo.AccrueInterestInMemory.No\n        );\n\n        require(userIsSolvent, ISilo.NotSolvent());\n    }\n\n    // this method expect interest to be already accrued\n    function _checkLTVWithoutAccruingInterest(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower\n    ) private {\n        if (_collateralConfig.silo != _debtConfig.silo) {\n            _collateralConfig.callMaxLtvOracleBeforeQuote();\n            _debtConfig.callMaxLtvOracleBeforeQuote();\n        }\n\n        bool borrowerIsBelowMaxLtv = SiloSolvencyLib.isBelowMaxLtv(\n            _collateralConfig, _debtConfig, _borrower, ISilo.AccrueInterestInMemory.No\n        );\n\n        require(borrowerIsBelowMaxLtv, ISilo.AboveMaxLtv());\n    }\n\n    function _hookCallBeforeWithdraw(\n        ISilo.WithdrawArgs calldata _args\n    ) private {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n\n        uint256 action = Hook.withdrawAction(_args.collateralType);\n\n        if (!_shareStorage.hookSetup.hooksBefore.matchAction(action)) return;\n\n        bytes memory data =\n            abi.encodePacked(_args.assets, _args.shares, _args.receiver, _args.owner, _args.spender);\n\n        IHookReceiver(_shareStorage.hookSetup.hookReceiver).beforeAction(address(this), action, data);\n    }\n\n    function _hookCallAfterWithdraw(\n        ISilo.WithdrawArgs calldata _args,\n        uint256 assets,\n        uint256 shares\n    ) private {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n\n        uint256 action = Hook.withdrawAction(_args.collateralType);\n\n        if (!_shareStorage.hookSetup.hooksAfter.matchAction(action)) return;\n\n        bytes memory data =\n            abi.encodePacked(_args.assets, _args.shares, _args.receiver, _args.owner, _args.spender, assets, shares);\n\n        IHookReceiver(_shareStorage.hookSetup.hookReceiver).afterAction(address(this), action, data);\n    }\n\n    function _hookCallBeforeBorrow(ISilo.BorrowArgs memory _args, uint256 action) private {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n\n        if (!_shareStorage.hookSetup.hooksBefore.matchAction(action)) return;\n\n        bytes memory data = abi.encodePacked(\n            _args.assets,\n            _args.shares,\n            _args.receiver,\n            _args.borrower,\n            msg.sender // spender\n        );\n\n        IHookReceiver(_shareStorage.hookSetup.hookReceiver).beforeAction(address(this), action, data);\n    }\n\n    function _hookCallAfterBorrow(\n        ISilo.BorrowArgs memory _args,\n        uint256 action,\n        uint256 assets,\n        uint256 shares\n    ) private {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n\n        if (!_shareStorage.hookSetup.hooksAfter.matchAction(action)) return;\n\n        bytes memory data = abi.encodePacked(\n            _args.assets,\n            _args.shares,\n            _args.receiver,\n            _args.borrower,\n            msg.sender, // spender\n            assets,\n            shares\n        );\n\n        IHookReceiver(_shareStorage.hookSetup.hookReceiver).afterAction(address(this), action, data);\n    }\n\n    function _hookCallBeforeTransitionCollateral(ISilo.TransitionCollateralArgs memory _args) private {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n        \n        uint256 action = Hook.transitionCollateralAction(_args.transitionFrom);\n\n        if (!_shareStorage.hookSetup.hooksBefore.matchAction(action)) return;\n\n        bytes memory data = abi.encodePacked(_args.shares, _args.owner);\n\n        IHookReceiver(_shareStorage.hookSetup.hookReceiver).beforeAction(address(this), action, data);\n    }\n\n    function _hookCallAfterTransitionCollateral(\n        ISilo.TransitionCollateralArgs memory _args,\n        uint256 _shares,\n        uint256 _assets\n    ) private {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n        uint256 action = Hook.transitionCollateralAction(_args.transitionFrom);\n\n        if (!_shareStorage.hookSetup.hooksAfter.matchAction(action)) return;\n\n        bytes memory data = abi.encodePacked(_shares, _args.owner, _assets);\n\n        IHookReceiver(_shareStorage.hookSetup.hookReceiver).afterAction(address(this), action, data);\n    }\n\n    function _hookCallBeforeDeposit(\n        ISilo.CollateralType _collateralType,\n        uint256 _assets,\n        uint256 _shares,\n        address _receiver\n    ) private {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n        uint256 action = Hook.depositAction(_collateralType);\n\n        if (!_shareStorage.hookSetup.hooksBefore.matchAction(action)) return;\n\n        bytes memory data = abi.encodePacked(_assets, _shares, _receiver);\n\n        IHookReceiver(_shareStorage.hookSetup.hookReceiver).beforeAction(address(this), action, data);\n    }\n\n    function _hookCallAfterDeposit(\n        ISilo.CollateralType _collateralType,\n        uint256 _assets,\n        uint256 _shares,\n        address _receiver,\n        uint256 _exactAssets,\n        uint256 _exactShare\n    ) private {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n        uint256 action = Hook.depositAction(_collateralType);\n\n        if (!_shareStorage.hookSetup.hooksAfter.matchAction(action)) return;\n\n        bytes memory data = abi.encodePacked(_assets, _shares, _receiver, _exactAssets, _exactShare);\n\n        IHookReceiver(_shareStorage.hookSetup.hookReceiver).afterAction(address(this), action, data);\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    function _safeTransferInternal(IERC20 _token, address _to, uint256 _value) internal returns (bool result) {\n        bytes memory data = abi.encodeCall(_token.transfer, (_to, _value));\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(_token).call(data);\n        if (!success) return false;\n\n        result = returndata.length == 0 || abi.decode(returndata, (bool));\n    }\n}\n"
    },
    "silo-core/contracts/lib/Views.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {ISiloFactory} from \"../interfaces/ISiloFactory.sol\";\n\nimport {SiloERC4626Lib} from \"./SiloERC4626Lib.sol\";\nimport {SiloSolvencyLib} from \"./SiloSolvencyLib.sol\";\nimport {SiloLendingLib} from \"./SiloLendingLib.sol\";\nimport {SiloStdLib} from \"./SiloStdLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\nimport {ShareTokenLib} from \"./ShareTokenLib.sol\";\nimport {SiloStorageLib} from \"./SiloStorageLib.sol\";\n\n// solhint-disable ordering\n\nlibrary Views {\n    uint256 internal constant _100_PERCENT = 1e18;\n\n    bytes32 internal constant _FLASHLOAN_CALLBACK = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    function isSolvent(address _borrower) external view returns (bool) {\n        (\n            ISiloConfig.ConfigData memory collateral,\n            ISiloConfig.ConfigData memory debt\n        ) = ShareTokenLib.siloConfig().getConfigsForSolvency(_borrower);\n\n        return SiloSolvencyLib.isSolvent(collateral, debt, _borrower, ISilo.AccrueInterestInMemory.Yes);\n    }\n\n    /// @notice Returns flash fee amount\n    /// @param _token for which fee is calculated\n    /// @param _amount for which fee is calculated\n    /// @return fee flash fee amount\n    function flashFee(address _token, uint256 _amount) external view returns (uint256 fee) {\n        fee = SiloStdLib.flashFee(ShareTokenLib.siloConfig(), _token, _amount);\n    }\n\n    function maxFlashLoan(address _token) internal view returns (uint256 maxLoan) {\n        if (_token != ShareTokenLib.siloConfig().getAssetForSilo(address(this))) return 0;\n\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n        uint256 protectedAssets = $.totalAssets[ISilo.AssetType.Protected];\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        unchecked {\n            // we check underflow ourself\n            return balance > protectedAssets ? balance - protectedAssets : 0;\n        }\n    }\n\n    function maxBorrow(address _borrower)\n        external\n        view\n        returns (uint256 maxAssets, uint256 maxShares)\n    {\n        return SiloLendingLib.maxBorrow(_borrower);\n    }\n\n    function maxWithdraw(address _owner, ISilo.CollateralType _collateralType)\n        external\n        view\n        returns (uint256 assets, uint256 shares)\n    {\n        return SiloERC4626Lib.maxWithdraw(\n            _owner,\n            _collateralType,\n            // 0 for CollateralType.Collateral because it will be calculated internally\n            _collateralType == ISilo.CollateralType.Protected\n                ? SiloStorageLib.getSiloStorage().totalAssets[ISilo.AssetType.Protected]\n                : 0\n        );\n    }\n\n    function maxRepay(address _borrower) external view returns (uint256 assets) {\n        ISiloConfig.ConfigData memory configData = ShareTokenLib.getConfig();\n        uint256 shares = IShareToken(configData.debtShareToken).balanceOf(_borrower);\n\n        (uint256 totalSiloAssets, uint256 totalShares) =\n            SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(configData, ISilo.AssetType.Debt);\n\n        return SiloMathLib.convertToAssets(\n            shares, totalSiloAssets, totalShares, Rounding.MAX_REPAY_TO_ASSETS, ISilo.AssetType.Debt\n        );\n    }\n\n    function getSiloStorage()\n        internal\n        view\n        returns (\n            uint192 daoAndDeployerRevenue,\n            uint64 interestRateTimestamp,\n            uint256 protectedAssets,\n            uint256 collateralAssets,\n            uint256 debtAssets\n        )\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        daoAndDeployerRevenue = $.daoAndDeployerRevenue;\n        interestRateTimestamp = $.interestRateTimestamp;\n        protectedAssets = $.totalAssets[ISilo.AssetType.Protected];\n        collateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n        debtAssets = $.totalAssets[ISilo.AssetType.Debt];\n    }\n\n    function getFractionsStorage() internal view returns (ISilo.Fractions memory fractions) {\n        fractions = SiloStorageLib.getSiloStorage().fractions;\n    }\n\n    function utilizationData() internal view returns (ISilo.UtilizationData memory) {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        return ISilo.UtilizationData({\n            collateralAssets: $.totalAssets[ISilo.AssetType.Collateral],\n            debtAssets: $.totalAssets[ISilo.AssetType.Debt],\n            interestRateTimestamp: $.interestRateTimestamp\n        });\n    }\n\n    function getDebtAssets() internal view returns (uint256 totalDebtAssets) {\n        ISiloConfig.ConfigData memory thisSiloConfig = ShareTokenLib.getConfig();\n\n        totalDebtAssets = SiloStdLib.getTotalDebtAssetsWithInterest(\n            thisSiloConfig.silo, thisSiloConfig.interestRateModel\n        );\n    }\n\n    function getCollateralAndProtectedAssets()\n        internal\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalProtectedAssets)\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n        totalProtectedAssets = $.totalAssets[ISilo.AssetType.Protected];\n    }\n\n    function getCollateralAndDebtAssets()\n        internal\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalDebtAssets)\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n        totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n    }\n\n    function copySiloConfig(\n        ISiloConfig.InitData memory _initData,\n        ISiloFactory.Range memory _daoFeeRange,\n        uint256 _maxDeployerFee,\n        uint256 _maxFlashloanFee,\n        uint256 _maxLiquidationFee\n    )\n        internal\n        view\n        returns (ISiloConfig.ConfigData memory configData0, ISiloConfig.ConfigData memory configData1)\n    {\n        validateSiloInitData(_initData, _daoFeeRange, _maxDeployerFee, _maxFlashloanFee, _maxLiquidationFee);\n\n        configData0.hookReceiver = _initData.hookReceiver;\n        configData0.token = _initData.token0;\n        configData0.solvencyOracle = _initData.solvencyOracle0;\n        // If maxLtv oracle is not set, fallback to solvency oracle\n        configData0.maxLtvOracle = _initData.maxLtvOracle0 == address(0)\n            ? _initData.solvencyOracle0\n            : _initData.maxLtvOracle0;\n        configData0.interestRateModel = _initData.interestRateModel0;\n        configData0.maxLtv = _initData.maxLtv0;\n        configData0.lt = _initData.lt0;\n        configData0.liquidationTargetLtv = _initData.liquidationTargetLtv0;\n        configData0.deployerFee = _initData.deployerFee;\n        configData0.daoFee = _initData.daoFee;\n        configData0.liquidationFee = _initData.liquidationFee0;\n        configData0.flashloanFee = _initData.flashloanFee0;\n        configData0.callBeforeQuote = _initData.callBeforeQuote0;\n\n        configData1.hookReceiver = _initData.hookReceiver;\n        configData1.token = _initData.token1;\n        configData1.solvencyOracle = _initData.solvencyOracle1;\n        // If maxLtv oracle is not set, fallback to solvency oracle\n        configData1.maxLtvOracle = _initData.maxLtvOracle1 == address(0)\n            ? _initData.solvencyOracle1\n            : _initData.maxLtvOracle1;\n        configData1.interestRateModel = _initData.interestRateModel1;\n        configData1.maxLtv = _initData.maxLtv1;\n        configData1.lt = _initData.lt1;\n        configData1.liquidationTargetLtv = _initData.liquidationTargetLtv1;\n        configData1.deployerFee = _initData.deployerFee;\n        configData1.daoFee = _initData.daoFee;\n        configData1.liquidationFee = _initData.liquidationFee1;\n        configData1.flashloanFee = _initData.flashloanFee1;\n        configData1.callBeforeQuote = _initData.callBeforeQuote1;\n    }\n\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function validateSiloInitData(\n        ISiloConfig.InitData memory _initData,\n        ISiloFactory.Range memory _daoFeeRange,\n        uint256 _maxDeployerFee,\n        uint256 _maxFlashloanFee,\n        uint256 _maxLiquidationFee\n    ) internal view returns (bool) {\n        require(_initData.hookReceiver != address(0), ISiloFactory.MissingHookReceiver());\n\n        require(_initData.token0 != address(0), ISiloFactory.EmptyToken0());\n        require(_initData.token1 != address(0), ISiloFactory.EmptyToken1());\n\n        require(_initData.token0 != _initData.token1, ISiloFactory.SameAsset());\n        require(_initData.maxLtv0 != 0 || _initData.maxLtv1 != 0, ISiloFactory.InvalidMaxLtv());\n        require(_initData.maxLtv0 <= _initData.lt0, ISiloFactory.InvalidMaxLtv());\n        require(_initData.maxLtv1 <= _initData.lt1, ISiloFactory.InvalidMaxLtv());\n        require(_initData.liquidationFee0 <= _maxLiquidationFee, ISiloFactory.MaxLiquidationFeeExceeded());\n        require(_initData.liquidationFee1 <= _maxLiquidationFee, ISiloFactory.MaxLiquidationFeeExceeded());\n        require(_initData.lt0 + _initData.liquidationFee0 <= _100_PERCENT, ISiloFactory.InvalidLt());\n        require(_initData.lt1 + _initData.liquidationFee1 <= _100_PERCENT, ISiloFactory.InvalidLt());\n\n        require(\n            _initData.maxLtvOracle0 == address(0) || _initData.solvencyOracle0 != address(0),\n            ISiloFactory.OracleMisconfiguration()\n        );\n\n        require(\n            !_initData.callBeforeQuote0 || _initData.solvencyOracle0 != address(0),\n            ISiloFactory.InvalidCallBeforeQuote()\n        );\n\n        require(\n            _initData.maxLtvOracle1 == address(0) || _initData.solvencyOracle1 != address(0),\n            ISiloFactory.OracleMisconfiguration()\n        );\n\n        require(\n            !_initData.callBeforeQuote1 || _initData.solvencyOracle1 != address(0),\n            ISiloFactory.InvalidCallBeforeQuote()\n        );\n\n        verifyQuoteTokens(_initData);\n\n        require(_initData.deployerFee == 0 || _initData.deployer != address(0), ISiloFactory.InvalidDeployer());\n        require(_initData.deployerFee <= _maxDeployerFee, ISiloFactory.MaxDeployerFeeExceeded());\n        require(_daoFeeRange.min <= _initData.daoFee, ISiloFactory.DaoMinRangeExceeded());\n        require(_initData.daoFee <= _daoFeeRange.max, ISiloFactory.DaoMaxRangeExceeded());\n        require(_initData.flashloanFee0 <= _maxFlashloanFee, ISiloFactory.MaxFlashloanFeeExceeded());\n        require(_initData.flashloanFee1 <= _maxFlashloanFee, ISiloFactory.MaxFlashloanFeeExceeded());\n        require(_initData.liquidationTargetLtv0 <= _initData.lt0, ISiloFactory.LiquidationTargetLtvTooHigh());\n        require(_initData.liquidationTargetLtv1 <= _initData.lt1, ISiloFactory.LiquidationTargetLtvTooHigh());\n\n        require(\n            _initData.interestRateModel0 != address(0) && _initData.interestRateModel1 != address(0),\n            ISiloFactory.InvalidIrm()\n        );\n\n        return true;\n    }\n\n    function verifyQuoteTokens(ISiloConfig.InitData memory _initData) internal view {\n        address expectedQuoteToken;\n\n        expectedQuoteToken = verifyQuoteToken(expectedQuoteToken, _initData.solvencyOracle0);\n        expectedQuoteToken = verifyQuoteToken(expectedQuoteToken, _initData.maxLtvOracle0);\n        expectedQuoteToken = verifyQuoteToken(expectedQuoteToken, _initData.solvencyOracle1);\n        expectedQuoteToken = verifyQuoteToken(expectedQuoteToken, _initData.maxLtvOracle1);\n    }\n\n    function verifyQuoteToken(address _expectedQuoteToken, address _oracle)\n        internal\n        view\n        returns (address quoteToken)\n    {\n        if (_oracle == address(0)) return _expectedQuoteToken;\n\n        quoteToken = ISiloOracle(_oracle).quoteToken();\n\n        if (_expectedQuoteToken == address(0)) return quoteToken;\n        require(_expectedQuoteToken == quoteToken, ISiloFactory.InvalidQuoteToken());\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloStdLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\n\nlibrary SiloStdLib {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    /// @notice Returns flash fee amount\n    /// @param _config address of config contract for Silo\n    /// @param _token for which fee is calculated\n    /// @param _amount for which fee is calculated\n    /// @return fee flash fee amount\n    function flashFee(ISiloConfig _config, address _token, uint256 _amount) internal view returns (uint256 fee) {\n        if (_amount == 0) return 0;\n\n        // all user set fees are in 18 decimals points\n        (,, uint256 flashloanFee, address asset) = _config.getFeesWithAsset(address(this));\n        require(_token == asset, ISilo.UnsupportedFlashloanToken());\n        if (flashloanFee == 0) return 0;\n\n        require(type(uint256).max / _amount >= flashloanFee, ISilo.FlashloanAmountTooBig());\n        fee = _amount * flashloanFee / _PRECISION_DECIMALS;\n\n        // round up\n        if (fee == 0) return 1;\n    }\n\n    /// @notice Returns totalAssets and totalShares for conversion math (convertToAssets and convertToShares)\n    /// @dev This is useful for view functions that do not accrue interest before doing calculations. To work on\n    ///      updated numbers, interest should be added on the fly.\n    /// @param _configData for a single token for which to do calculations\n    /// @param _assetType used to read proper storage data\n    /// @return totalAssets total assets in Silo with interest for given asset type\n    /// @return totalShares total shares in Silo for given asset type\n    function getTotalAssetsAndTotalSharesWithInterest(\n        ISiloConfig.ConfigData memory _configData,\n        ISilo.AssetType _assetType\n    )\n        internal\n        view\n        returns (uint256 totalAssets, uint256 totalShares)\n    {\n        if (_assetType == ISilo.AssetType.Protected) {\n            totalAssets = ISilo(_configData.silo).getTotalAssetsStorage(ISilo.AssetType.Protected);\n            totalShares = IShareToken(_configData.protectedShareToken).totalSupply();\n        } else if (_assetType == ISilo.AssetType.Collateral) {\n            totalAssets = getTotalCollateralAssetsWithInterest(\n                _configData.silo,\n                _configData.interestRateModel,\n                _configData.daoFee,\n                _configData.deployerFee\n            );\n\n            totalShares = IShareToken(_configData.collateralShareToken).totalSupply();\n        } else { // ISilo.AssetType.Debt\n            totalAssets = getTotalDebtAssetsWithInterest(_configData.silo, _configData.interestRateModel);\n            totalShares = IShareToken(_configData.debtShareToken).totalSupply();\n        }\n    }\n\n    /// @notice Retrieves fee amounts in 18 decimals points and their respective receivers along with the asset\n    /// @param _silo Silo address\n    /// @return daoFeeReceiver Address of the DAO fee receiver\n    /// @return deployerFeeReceiver Address of the deployer fee receiver\n    /// @return daoFee DAO fee amount in 18 decimals points\n    /// @return deployerFee Deployer fee amount in 18 decimals points\n    /// @return asset Address of the associated asset\n    function getFeesAndFeeReceiversWithAsset(ISilo _silo)\n        internal\n        view\n        returns (\n            address daoFeeReceiver,\n            address deployerFeeReceiver,\n            uint256 daoFee,\n            uint256 deployerFee,\n            address asset\n        )\n    {\n        (daoFee, deployerFee,, asset) = _silo.config().getFeesWithAsset(address(_silo));\n        (daoFeeReceiver, deployerFeeReceiver) = _silo.factory().getFeeReceivers(address(_silo));\n    }\n\n    /// @notice Calculates the total collateral assets with accrued interest\n    /// @dev Do not use this method when accrueInterest were executed already, in that case total does not change\n    /// @param _silo Address of the silo contract\n    /// @param _interestRateModel Interest rate model to fetch compound interest rates\n    /// @param _daoFee DAO fee in 18 decimals points\n    /// @param _deployerFee Deployer fee in 18 decimals points\n    /// @return totalCollateralAssetsWithInterest Accumulated collateral amount with interest\n    function getTotalCollateralAssetsWithInterest(\n        address _silo,\n        address _interestRateModel,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    ) internal view returns (uint256 totalCollateralAssetsWithInterest) {\n        uint256 rcomp;\n\n        try IInterestRateModel(_interestRateModel).getCompoundInterestRate(_silo, block.timestamp) returns (uint256 r) {\n            rcomp = r;\n        } catch {\n            // do not lock silo\n        }\n\n        (uint256 collateralAssets, uint256 debtAssets) = ISilo(_silo).getCollateralAndDebtTotalsStorage();\n\n        (totalCollateralAssetsWithInterest,,,) = SiloMathLib.getCollateralAmountsWithInterest({\n            _collateralAssets: collateralAssets,\n            _debtAssets: debtAssets,\n            _rcomp: rcomp,\n            _daoFee: _daoFee,\n            _deployerFee: _deployerFee\n        });\n    }\n\n    /// @param _balanceCached if balance of `_owner` is unknown beforehand, then pass `0`\n    function getSharesAndTotalSupply(address _shareToken, address _owner, uint256 _balanceCached)\n        internal\n        view\n        returns (uint256 shares, uint256 totalSupply)\n    {\n        if (_balanceCached == 0) {\n            (shares, totalSupply) = IShareToken(_shareToken).balanceOfAndTotalSupply(_owner);\n        } else {\n            shares = _balanceCached;\n            totalSupply = IShareToken(_shareToken).totalSupply();\n        }\n    }\n\n    /// @notice Calculates the total debt assets with accrued interest\n    /// @param _silo Address of the silo contract\n    /// @param _interestRateModel Interest rate model to fetch compound interest rates\n    /// @return totalDebtAssetsWithInterest Accumulated debt amount with interest\n    function getTotalDebtAssetsWithInterest(address _silo, address _interestRateModel)\n        internal\n        view\n        returns (uint256 totalDebtAssetsWithInterest)\n    {\n        uint256 rcomp;\n\n        try IInterestRateModel(_interestRateModel).getCompoundInterestRate(_silo, block.timestamp) returns (uint256 r) {\n            rcomp = r;\n        } catch {\n            // do not lock silo\n        }\n\n        (\n            totalDebtAssetsWithInterest,\n        ) = SiloMathLib.getDebtAmountsWithInterest(ISilo(_silo).getTotalAssetsStorage(ISilo.AssetType.Debt), rcomp);\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloLendingLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.28;\n\n// solhint-disable ordering\n\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {SiloSolvencyLib} from \"./SiloSolvencyLib.sol\";\nimport {SiloStdLib} from \"./SiloStdLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\nimport {ShareTokenLib} from \"./ShareTokenLib.sol\";\nimport {SiloStorageLib} from \"./SiloStorageLib.sol\";\n\nlibrary SiloLendingLib {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n    /// @dev If SILO has low total debt, interest might be lost to rounding for low deposits.\n    /// Value is based on minimal deposit needed to accrue two digit wei interest for 1 second at 0.01% APR.\n    /// Example of calculations for 1 second at 0.01% APR and totalDebtAssets 1e13:\n    /// 1e13 * (0.0001/365/24/3600*1e18) * 1 / 1e18 = 31.70979198376459\n    uint256 internal constant _ROUNDING_THRESHOLD = 1e13;\n\n    /// @notice Allows repaying borrowed assets either partially or in full\n    /// @param _debtShareToken debt share token address\n    /// @param _debtAsset underlying debt asset address\n    /// @param _assets The amount of assets to repay. Use 0 if shares are used.\n    /// @param _shares The number of corresponding shares associated with the debt. Use 0 if assets are used.\n    /// @param _borrower The account that has the debt\n    /// @param _repayer The account that is repaying the debt\n    /// @return assets The amount of assets that was repaid\n    /// @return shares The corresponding number of debt shares that were repaid\n    function repay(\n        IShareToken _debtShareToken,\n        address _debtAsset,\n        uint256 _assets,\n        uint256 _shares,\n        address _borrower,\n        address _repayer\n    ) internal returns (uint256 assets, uint256 shares) {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        uint256 totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n        (uint256 debtSharesBalance, uint256 totalDebtShares) = _debtShareToken.balanceOfAndTotalSupply(_borrower);\n\n        (assets, shares) = SiloMathLib.convertToAssetsOrToShares({\n            _assets: _assets,\n            _shares: _shares,\n            _totalAssets: totalDebtAssets,\n            _totalShares: totalDebtShares,\n            _roundingToAssets: Rounding.REPAY_TO_ASSETS,\n            _roundingToShares: Rounding.REPAY_TO_SHARES,\n            _assetType: ISilo.AssetType.Debt\n        });\n\n        if (shares > debtSharesBalance) {\n            shares = debtSharesBalance;\n\n            (assets, shares) = SiloMathLib.convertToAssetsOrToShares({\n                _assets: 0,\n                _shares: shares,\n                _totalAssets: totalDebtAssets,\n                _totalShares: totalDebtShares,\n                _roundingToAssets: Rounding.REPAY_TO_ASSETS,\n                _roundingToShares: Rounding.REPAY_TO_SHARES,\n                _assetType: ISilo.AssetType.Debt\n            });\n        }\n\n        require(totalDebtAssets >= assets, ISilo.RepayTooHigh());\n\n        // subtract repayment from debt, save to unchecked because of above `totalDebtAssets < assets`\n        unchecked { $.totalAssets[ISilo.AssetType.Debt] = totalDebtAssets - assets; }\n\n        // Anyone can repay anyone's debt so no approval check is needed.\n        _debtShareToken.burn(_borrower, _repayer, shares);\n        // fee-on-transfer is ignored\n        // Reentrancy is possible only for view methods (read-only reentrancy),\n        // so no harm can be done as the state is already updated.\n        // We do not expect the silo to work with any malicious token that will not send tokens back.\n        IERC20(_debtAsset).safeTransferFrom(_repayer, address(this), assets);\n    }\n\n    /// @notice Accrues interest on assets, updating the collateral and debt balances\n    /// @dev This method will accrue interest for ONE asset ONLY, to calculate for both silos you have to call it twice\n    /// with `_configData` for each token\n    /// @param _interestRateModel The address of the interest rate model to calculate the compound interest rate\n    /// @param _daoFee DAO's fee in 18 decimals points\n    /// @param _deployerFee Deployer's fee in 18 decimals points\n    /// @return accruedInterest The total amount of interest accrued\n    // solhint-disable-next-line function-max-lines\n    function accrueInterestForAsset(address _interestRateModel, uint256 _daoFee, uint256 _deployerFee)\n        external\n        returns (uint256 accruedInterest)\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        uint64 lastTimestamp = $.interestRateTimestamp;\n\n        // Interest has already been accrued this block\n        if (lastTimestamp == block.timestamp) {\n            return 0;\n        }\n\n        // This is the first time, so we can return early and save some gas\n        if (lastTimestamp == 0) {\n            $.interestRateTimestamp = uint64(block.timestamp);\n            return 0;\n        }\n\n        uint256 totalFees;\n        uint256 totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n        uint256 totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n\n        uint256 rcomp = getCompoundInterestRate({\n            _interestRateModel: _interestRateModel,\n            _totalCollateralAssets: totalCollateralAssets,\n            _totalDebtAssets: totalDebtAssets,\n            _lastTimestamp: lastTimestamp\n        });\n\n        if (rcomp == 0) {\n            $.interestRateTimestamp = uint64(block.timestamp);\n            return 0;\n        }\n\n        (\n            $.totalAssets[ISilo.AssetType.Collateral], $.totalAssets[ISilo.AssetType.Debt], totalFees, accruedInterest\n        ) = SiloMathLib.getCollateralAmountsWithInterest({\n            _collateralAssets: totalCollateralAssets,\n            _debtAssets: totalDebtAssets,\n            _rcomp: rcomp,\n            _daoFee: _daoFee,\n            _deployerFee: _deployerFee\n        });\n\n        (accruedInterest, totalFees) = applyFractions({\n            _totalDebtAssets: totalDebtAssets,\n            _rcomp: rcomp,\n            _accruedInterest: accruedInterest,\n            _fees: _daoFee + _deployerFee,\n            _totalFees: totalFees\n        });\n\n        // update remaining contract state\n        $.interestRateTimestamp = uint64(block.timestamp);\n\n        // we operating on chunks (fees) of real tokens, so overflow should not happen\n        // fee is simply too small to overflow on cast to uint192, even if, we will get lower fee\n        unchecked { $.daoAndDeployerRevenue += uint192(totalFees); }\n    }\n\n    /// @notice Allows a user or a delegate to borrow assets against their collateral\n    /// @dev The function checks for necessary conditions such as borrow possibility, enough liquidity, and zero\n    /// values\n    /// @param _debtShareToken address of debt share token\n    /// @param _token address of underlying debt token\n    /// @param _spender Address which initiates the borrowing action on behalf of the borrower\n    /// @return borrowedAssets Actual number of assets that the user has borrowed\n    /// @return borrowedShares Number of debt share tokens corresponding to the borrowed assets\n    function borrow(\n        address _debtShareToken,\n        address _token,\n        address _spender,\n        ISilo.BorrowArgs memory _args\n    )\n        internal\n        returns (uint256 borrowedAssets, uint256 borrowedShares)\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        uint256 totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n\n        (borrowedAssets, borrowedShares) = SiloMathLib.convertToAssetsOrToShares(\n            _args.assets,\n            _args.shares,\n            totalDebtAssets,\n            IShareToken(_debtShareToken).totalSupply(),\n            Rounding.BORROW_TO_ASSETS,\n            Rounding.BORROW_TO_SHARES,\n            ISilo.AssetType.Debt\n        );\n\n        uint256 totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n\n        require(\n            _token == address(0) || borrowedAssets <= SiloMathLib.liquidity(totalCollateralAssets, totalDebtAssets),\n            ISilo.NotEnoughLiquidity()\n        );\n\n        // add new debt\n        $.totalAssets[ISilo.AssetType.Debt] = totalDebtAssets + borrowedAssets;\n\n        // `mint` checks if _spender is allowed to borrow on the account of _borrower.\n        IShareToken(_debtShareToken).mint(_args.borrower, _spender, borrowedShares);\n\n        if (_token != address(0)) {\n            // fee-on-transfer is ignored.\n            IERC20(_token).safeTransfer(_args.receiver, borrowedAssets);\n        }\n    }\n\n    /// @notice Determines the maximum amount (both in assets and shares) that a borrower can borrow\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower The address of the borrower whose maximum borrow limit is being queried\n    /// @param _totalDebtAssets The total debt assets in the system\n    /// @param _totalDebtShares The total debt shares in the system\n    /// @param _siloConfig address of SiloConfig contract\n    /// @return assets The maximum amount in assets that can be borrowed\n    /// @return shares The equivalent amount in shares for the maximum assets that can be borrowed\n    function calculateMaxBorrow( // solhint-disable-line function-max-lines\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        uint256 _totalDebtAssets,\n        uint256 _totalDebtShares,\n        ISiloConfig _siloConfig\n    )\n        internal\n        view\n        returns (uint256 assets, uint256 shares)\n    {\n        SiloSolvencyLib.LtvData memory ltvData = SiloSolvencyLib.getAssetsDataForLtvCalculations({\n            _collateralConfig: _collateralConfig,\n            _debtConfig: _debtConfig,\n            _borrower: _borrower,\n            _oracleType: ISilo.OracleType.MaxLtv,\n            _accrueInMemory: ISilo.AccrueInterestInMemory.Yes,\n            _debtShareBalanceCached: 0 /* no cache */\n        });\n\n        // Workaround for fractions. We assume the worst case scenario that we will have integral revenue\n        // that will be subtracted from collateral and integral interest that will be added to debt.\n        {\n            // We need to decrease borrowerCollateralAssets\n            // since we cannot access totalCollateralAssets before calculations.\n            if (ltvData.borrowerCollateralAssets != 0) ltvData.borrowerCollateralAssets--;\n\n            // We need to increase borrowerDebtAssets since we cannot access totalDebtAssets before calculations.\n            // If borrowerDebtAssets is 0 then we have no interest\n            if (ltvData.borrowerDebtAssets != 0) ltvData.borrowerDebtAssets++;\n\n            // It _totalDebtAssets is 0 then we have no interest\n            if (_totalDebtAssets != 0) _totalDebtAssets++;\n        }\n\n        (\n            uint256 sumOfBorrowerCollateralValue, uint256 borrowerDebtValue\n        ) = SiloSolvencyLib.getPositionValues(ltvData, _collateralConfig.token, _debtConfig.token);\n\n        uint256 maxBorrowValue = SiloMathLib.calculateMaxBorrowValue(\n            _collateralConfig.maxLtv,\n            sumOfBorrowerCollateralValue,\n            borrowerDebtValue\n        );\n\n        (assets, shares) = maxBorrowValueToAssetsAndShares({\n            _maxBorrowValue: maxBorrowValue,\n            _debtAsset: _debtConfig.token,\n            _debtOracle: ltvData.debtOracle,\n            _totalDebtAssets: _totalDebtAssets,\n            _totalDebtShares: _totalDebtShares\n        });\n\n        if (assets == 0 || shares == 0) return (0, 0);\n\n        uint256 liquidityWithInterest = getLiquidity(_siloConfig);\n\n        if (liquidityWithInterest != 0) {\n            // We need to count for fractions, when fractions are applied liquidity may be decreased\n            unchecked { liquidityWithInterest -= 1; }\n        }\n\n        if (assets > liquidityWithInterest) {\n            assets = liquidityWithInterest;\n\n            // rounding must follow same flow as in `maxBorrowValueToAssetsAndShares()`\n            shares = SiloMathLib.convertToShares(\n                assets,\n                _totalDebtAssets,\n                _totalDebtShares,\n                Rounding.MAX_BORROW_TO_SHARES,\n                ISilo.AssetType.Debt\n            );\n        }\n    }\n\n    function maxBorrow(address _borrower)\n        internal\n        view\n        returns (uint256 maxAssets, uint256 maxShares)\n    {\n        ISiloConfig siloConfig = ShareTokenLib.siloConfig();\n        if (siloConfig.hasDebtInOtherSilo(address(this), _borrower)) return (0, 0);\n\n        ISiloConfig.ConfigData memory collateralConfig;\n        ISiloConfig.ConfigData memory debtConfig;\n\n        (collateralConfig, debtConfig) = siloConfig.getConfigsForBorrow({_debtSilo: address(this)});\n\n        (uint256 totalDebtAssets, uint256 totalDebtShares) =\n            SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(debtConfig, ISilo.AssetType.Debt);\n\n        return calculateMaxBorrow(\n            collateralConfig,\n            debtConfig,\n            _borrower,\n            totalDebtAssets,\n            totalDebtShares,\n            siloConfig\n        );\n    }\n\n    function getLiquidity(ISiloConfig _siloConfig) internal view returns (uint256 liquidity) {\n        ISiloConfig.ConfigData memory config = _siloConfig.getConfig(address(this));\n        (liquidity,,) = getLiquidityAndAssetsWithInterest(config.interestRateModel, config.daoFee, config.deployerFee);\n    }\n\n    function getLiquidityAndAssetsWithInterest(address _interestRateModel, uint256 _daoFee, uint256 _deployerFee)\n        internal\n        view\n        returns (uint256 liquidity, uint256 totalCollateralAssets, uint256 totalDebtAssets)\n    {\n        totalCollateralAssets = SiloStdLib.getTotalCollateralAssetsWithInterest(\n            address(this),\n            _interestRateModel,\n            _daoFee,\n            _deployerFee\n        );\n\n        totalDebtAssets = SiloStdLib.getTotalDebtAssetsWithInterest(\n            address(this),\n            _interestRateModel\n        );\n\n        liquidity = SiloMathLib.liquidity(totalCollateralAssets, totalDebtAssets);\n    }\n\n    /// @notice Calculates the maximum borrowable assets and shares\n    /// @param _maxBorrowValue The maximum value that can be borrowed by the user\n    /// @param _debtAsset Address of the debt token\n    /// @param _debtOracle Oracle used to get the value of the debt token\n    /// @param _totalDebtAssets Total assets of the debt\n    /// @param _totalDebtShares Total shares of the debt\n    /// @return assets Maximum borrowable assets\n    /// @return shares Maximum borrowable shares\n    // solhint-disable-next-line function-max-lines\n    function maxBorrowValueToAssetsAndShares(\n        uint256 _maxBorrowValue,\n        address _debtAsset,\n        ISiloOracle _debtOracle,\n        uint256 _totalDebtAssets,\n        uint256 _totalDebtShares\n    )\n        internal\n        view\n        returns (uint256 assets, uint256 shares)\n    {\n        if (_maxBorrowValue == 0) {\n            return (0, 0);\n        }\n\n        uint256 debtTokenSample = _PRECISION_DECIMALS;\n\n        uint256 debtSampleValue = address(_debtOracle) == address(0)\n            ? debtTokenSample\n            : _debtOracle.quote(debtTokenSample, _debtAsset);\n\n        assets = _maxBorrowValue.mulDiv(debtTokenSample, debtSampleValue, Rounding.MAX_BORROW_TO_ASSETS);\n\n        // when we borrow, we convertToShares with rounding.Up, to create higher debt, however here,\n        // when we want to calculate \"max borrow\", we can not round.Up, because it can create issue with max ltv,\n        // because we not creating debt here, we calculating max assets/shares, so we need to round.Down here\n        shares = SiloMathLib.convertToShares(\n            assets, _totalDebtAssets, _totalDebtShares, Rounding.MAX_BORROW_TO_SHARES, ISilo.AssetType.Debt\n        );\n\n        {\n            /*\n            This is a workaround for handling fractions:\n\n            - Fractions are not applied in view methods, so we need to account for them manually.\n            - `_totalDebtAssets` is incremented earlier to compensate for these fractions.\n\n            Due to this, increasing `_totalDebtAssets` raises the debt share price. As a result, converting\n            assets to shares yields fewer shares, and this same reduced ratio is applied\n            to the next conversion (shown below). Ultimately, this means we receive fewer shares for the same amount\n            of assets.\n\n            When we call `borrow(assets)` and there are no fractions to apply, `_totalDebtAssets` is not incremented.\n            A lower `_totalDebtAssets` means a lower share price, so the same amount of assets\n            (as calculated by `maxBorrow()`) will result in more shares. At the final step, when checking maxLtv,\n            having more shares translates to more assets—exceeding the allowed maximum LTV.\n\n            Solution:\n            Having fewer shares is acceptable because it underestimates the value due to missing fractions.\n            When recalculating assets (due to the issue described above), we want a lower share price\n            (which occurs when there are no fractions), as this leads to fewer assets and keeps us within the LTV limit.\n\n            Therefore, we decrement `_totalDebtAssets` with `_totalDebtAssets--`\n            to offset the earlier `_totalDebtAssets++`.\n            */\n            if (_totalDebtAssets != 0) {\n                unchecked { _totalDebtAssets--; }\n            }\n        }\n\n        // we need to recalculate assets, because what we did above is assets => shares with rounding down, but when\n        // we input assets, they will generate more shares, so we need to calculate assets based on final shares\n        // not based on borrow value\n        assets = SiloMathLib.convertToAssets(\n            shares, _totalDebtAssets, _totalDebtShares, Rounding.MAX_BORROW_TO_ASSETS, ISilo.AssetType.Debt\n        );\n    }\n\n    function getCompoundInterestRate(\n        address _interestRateModel,\n        uint256 _totalCollateralAssets,\n        uint256 _totalDebtAssets,\n        uint64 _lastTimestamp\n    ) internal returns (uint256 rcomp) {\n        try\n            IInterestRateModel(_interestRateModel).getCompoundInterestRateAndUpdate(\n                _totalCollateralAssets,\n                _totalDebtAssets,\n                _lastTimestamp\n            )\n            returns (uint256 interestRate)\n        {\n            rcomp = interestRate;\n        } catch {\n            // do not lock silo on interest calculation\n            emit IInterestRateModel.InterestRateModelError();\n        }\n    }\n\n    function applyFractions(\n        uint256 _totalDebtAssets,\n        uint256 _rcomp,\n        uint256 _accruedInterest,\n        uint256 _fees,\n        uint256 _totalFees\n    )\n        internal returns (uint256 accruedInterest, uint256 totalFees)\n    {\n        // if _totalDebtAssets is greater than _ROUNDING_THRESHOLD then we don't need to worry\n        // about precision because there is enough amount of debt to generate double wei digit\n        // of interest per second so we can safely ignore fractions\n        if (_totalDebtAssets >= _ROUNDING_THRESHOLD) return (_accruedInterest, _totalFees);\n\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n        uint256 totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n\n        // `accrueInterestForAsset` should never revert,\n        // so we check edge cases for revert and do early return\n        // instead of checking each calculation individually for underflow/overflow\n        if (totalCollateralAssets == type(uint256).max || totalCollateralAssets == 0) {\n            return (_accruedInterest, _totalFees);\n        }\n\n        ISilo.Fractions memory fractions = $.fractions;\n\n        uint256 integralInterest;\n        uint256 integralRevenue;\n\n        (\n            integralInterest, fractions.interest\n        ) = SiloMathLib.calculateFraction(_totalDebtAssets, _rcomp, fractions.interest);\n\n        accruedInterest = _accruedInterest + integralInterest;\n\n        (\n            integralRevenue, fractions.revenue\n        ) = SiloMathLib.calculateFraction(accruedInterest, _fees, fractions.revenue);\n\n        totalFees = _totalFees + integralRevenue;\n\n        $.fractions = fractions;\n        $.totalAssets[ISilo.AssetType.Debt] += integralInterest;\n        $.totalAssets[ISilo.AssetType.Collateral] = totalCollateralAssets + integralInterest - integralRevenue;\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloERC4626Lib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.28;\n\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {SiloSolvencyLib} from \"./SiloSolvencyLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {SiloStdLib} from \"./SiloStdLib.sol\";\nimport {SiloLendingLib} from \"./SiloLendingLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\nimport {Hook} from \"./Hook.sol\";\nimport {ShareTokenLib} from \"./ShareTokenLib.sol\";\nimport {SiloStorageLib} from \"./SiloStorageLib.sol\";\n\n// solhint-disable function-max-lines\n\nlibrary SiloERC4626Lib {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    /// @dev ERC4626: MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be\n    ///      deposited. In our case, we want to limit this value in a way, that after max deposit we can do borrow.\n    uint256 internal constant _VIRTUAL_DEPOSIT_LIMIT = type(uint256).max;\n\n    /// @notice Deposit assets into the silo\n    /// @param _token The ERC20 token address being deposited; 0 means tokens will not be transferred. Useful for\n    /// transition of collateral.\n    /// @param _depositor Address of the user depositing the assets\n    /// @param _assets Amount of assets being deposited. Use 0 if shares are provided.\n    /// @param _shares Shares being exchanged for the deposit; used for precise calculations. Use 0 if assets are\n    /// provided.\n    /// @param _receiver The address that will receive the collateral shares\n    /// @param _collateralShareToken The collateral share token\n    /// @param _collateralType The type of collateral being deposited\n    /// @return assets The exact amount of assets being deposited\n    /// @return shares The exact number of collateral shares being minted in exchange for the deposited assets\n    function deposit(\n        address _token,\n        address _depositor,\n        uint256 _assets,\n        uint256 _shares,\n        address _receiver,\n        IShareToken _collateralShareToken,\n        ISilo.CollateralType _collateralType\n    ) internal returns (uint256 assets, uint256 shares) {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n        ISilo.AssetType collateralType = ISilo.AssetType(uint256(_collateralType));\n\n        uint256 totalAssets = $.totalAssets[collateralType];\n\n        (assets, shares) = SiloMathLib.convertToAssetsOrToShares(\n            _assets,\n            _shares,\n            totalAssets,\n            _collateralShareToken.totalSupply(),\n            Rounding.DEPOSIT_TO_ASSETS,\n            Rounding.DEPOSIT_TO_SHARES,\n            collateralType\n        );\n\n        $.totalAssets[collateralType] = totalAssets + assets;\n\n        // Hook receiver is called after `mint` and can reentry but state changes are completed already,\n        // and reentrancy protection is still enabled.\n        _collateralShareToken.mint(_receiver, _depositor, shares);\n\n        if (_token != address(0)) {\n            // Reentrancy is possible only for view methods (read-only reentrancy),\n            // so no harm can be done as the state is already updated.\n            // We do not expect the silo to work with any malicious token that will not send tokens to silo.\n            IERC20(_token).safeTransferFrom(_depositor, address(this), assets);\n        }\n    }\n\n    /// @notice Withdraw assets from the silo\n    /// @dev Asset type is not verified here, make sure you revert before when type == Debt\n    /// @param _asset The ERC20 token address to withdraw; 0 means tokens will not be transferred. Useful for\n    /// transition of collateral.\n    /// @param _shareToken Address of the share token being burned for withdrawal\n    /// @param _args ISilo.WithdrawArgs\n    /// @return assets The exact amount of assets withdrawn\n    /// @return shares The exact number of shares burned in exchange for the withdrawn assets\n    function withdraw(\n        address _asset,\n        address _shareToken,\n        ISilo.WithdrawArgs memory _args\n    ) internal returns (uint256 assets, uint256 shares) {\n        uint256 shareTotalSupply = IShareToken(_shareToken).totalSupply();\n        require(shareTotalSupply != 0, ISilo.NothingToWithdraw());\n\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        ISilo.AssetType collateralType = ISilo.AssetType(uint256(_args.collateralType));\n\n        { // Stack too deep\n            uint256 totalAssets = $.totalAssets[collateralType];\n\n            (assets, shares) = SiloMathLib.convertToAssetsOrToShares(\n                _args.assets,\n                _args.shares,\n                totalAssets,\n                shareTotalSupply,\n                Rounding.WITHDRAW_TO_ASSETS,\n                Rounding.WITHDRAW_TO_SHARES,\n                collateralType\n            );\n\n            uint256 liquidity = _args.collateralType == ISilo.CollateralType.Collateral\n                ? SiloMathLib.liquidity($.totalAssets[ISilo.AssetType.Collateral], $.totalAssets[ISilo.AssetType.Debt])\n                : $.totalAssets[ISilo.AssetType.Protected];\n\n            // check liquidity\n            require(assets <= liquidity, ISilo.NotEnoughLiquidity());\n\n            $.totalAssets[collateralType] = totalAssets - assets;\n        }\n\n        // `burn` checks if `_spender` is allowed to withdraw `_owner` assets. `burn` calls hook receiver\n        // after tokens transfer and can potentially reenter, but state changes are already completed,\n        // and reentrancy protection is still enabled.\n        IShareToken(_shareToken).burn(_args.owner, _args.spender, shares);\n\n        if (_asset != address(0)) {\n            // does not matter what is the type of transfer, we can not go below protected balance\n            uint256 protectedBalance = $.totalAssets[ISilo.AssetType.Protected];\n\n            require(\n                protectedBalance == 0 || IERC20(_asset).balanceOf(address(this)) - assets >= protectedBalance,\n                ISilo.ProtectedProtection()\n            );\n\n            // fee-on-transfer is ignored\n            IERC20(_asset).safeTransfer(_args.receiver, assets);\n        }\n    }\n\n    /// @notice Determines the maximum amount a user can withdraw, either in terms of assets or shares\n    /// @dev The function computes the maximum withdrawable assets and shares, considering user's collateral, debt,\n    /// and the liquidity in the silo.\n    /// Debt withdrawals are not allowed, resulting in a revert if such an attempt is made.\n    /// @param _owner Address of the user for which the maximum withdrawal amount is calculated\n    /// @param _collateralType The type of asset being considered for withdrawal\n    /// @param _totalAssets The total PROTECTED assets in the silo. In case of collateral use `0`, total\n    /// collateral will be calculated internally with interest\n    /// @return assets The maximum assets that the user can withdraw\n    /// @return shares The maximum shares that the user can withdraw\n    function maxWithdraw(\n        address _owner,\n        ISilo.CollateralType _collateralType,\n        uint256 _totalAssets\n    ) internal view returns (uint256 assets, uint256 shares) {\n        (\n            ISiloConfig.DepositConfig memory depositConfig,\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        ) = ShareTokenLib.siloConfig().getConfigsForWithdraw(address(this), _owner);\n\n        uint256 shareTokenTotalSupply;\n        uint256 liquidity;\n\n        if (_collateralType == ISilo.CollateralType.Collateral) {\n            shareTokenTotalSupply = IShareToken(depositConfig.collateralShareToken).totalSupply();\n            (liquidity, _totalAssets, ) = SiloLendingLib.getLiquidityAndAssetsWithInterest(\n                depositConfig.interestRateModel,\n                depositConfig.daoFee,\n                depositConfig.deployerFee\n            );\n\n            if (liquidity != 0) {\n                // We need to count for fractions. When fractions are applied, liquidity may be decreased.\n                unchecked { liquidity -= 1; _totalAssets -= 1; }\n            }\n        } else {\n            shareTokenTotalSupply = IShareToken(depositConfig.protectedShareToken).totalSupply();\n            liquidity = _totalAssets;\n        }\n\n        // if deposit is not related to debt\n        if (depositConfig.silo != collateralConfig.silo) {\n            shares = _collateralType == ISilo.CollateralType.Protected\n                ? IShareToken(depositConfig.protectedShareToken).balanceOf(_owner)\n                : IShareToken(depositConfig.collateralShareToken).balanceOf(_owner);\n\n            assets = SiloMathLib.convertToAssets(\n                shares,\n                _totalAssets,\n                shareTokenTotalSupply,\n                Rounding.MAX_WITHDRAW_TO_ASSETS,\n                ISilo.AssetType(uint256(_collateralType))\n            );\n\n            if (_collateralType == ISilo.CollateralType.Collateral && assets > liquidity) {\n                assets = liquidity;\n\n                shares = SiloMathLib.convertToShares(\n                    assets,\n                    _totalAssets,\n                    shareTokenTotalSupply,\n                    // when we doing withdraw, we using Rounding.Ceil, because we want to burn as many shares\n                    // however here, we will be using shares as input to withdraw, if we round up, we can overflow\n                    // because we will want to withdraw too much, so we have to use Rounding.Floor\n                    Rounding.MAX_WITHDRAW_TO_SHARES,\n                    ISilo.AssetType.Collateral\n                );\n            }\n        } else {\n            (assets, shares) = maxWithdrawWhenDebt(\n                collateralConfig, debtConfig, _owner, liquidity, shareTokenTotalSupply, _collateralType, _totalAssets\n            );\n        }\n\n        /*\n        there might be a case where conversion from assets <=> shares is not returning same amounts eg:\n        convert to shares ==> 1 * (1002 + 1e3) / (2 + 1) = 667.3\n        convert to assets ==> 667 * (2 + 1) / (1002 + 1e3) = 0.9995\n        so when user will use 667 withdrawal will fail, this is why we have to cross check:\n        */\n        if (\n            SiloMathLib.convertToAssets({\n                _shares: shares,\n                _totalAssets: _totalAssets,\n                _totalShares: shareTokenTotalSupply,\n                _rounding: Rounding.MAX_WITHDRAW_TO_ASSETS,\n                _assetType: ISilo.AssetType(uint8(_collateralType))\n            }) == 0\n        ) {\n            return (0, 0);\n        }\n    }\n\n    function maxWithdrawWhenDebt(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _owner,\n        uint256 _liquidity,\n        uint256 _shareTokenTotalSupply,\n        ISilo.CollateralType _collateralType,\n        uint256 _totalAssets\n    ) internal view returns (uint256 assets, uint256 shares) {\n        SiloSolvencyLib.LtvData memory ltvData = SiloSolvencyLib.getAssetsDataForLtvCalculations(\n            _collateralConfig,\n            _debtConfig,\n            _owner,\n            ISilo.OracleType.Solvency,\n            ISilo.AccrueInterestInMemory.Yes,\n            IShareToken(_debtConfig.debtShareToken).balanceOf(_owner)\n        );\n\n        // Workaround for fractions. We assume the worst case scenario that we will have integral revenue\n        // that will be subtracted from collateral and integral interest that will be added to debt.\n        {\n            // We need to decrease borrowerCollateralAssets\n            // since we cannot access totalCollateralAssets before calculations.\n            if (ltvData.borrowerCollateralAssets != 0) ltvData.borrowerCollateralAssets--;\n\n            // We need to increase borrowerDebtAssets since we cannot access totalDebtAssets before calculations.\n            // If borrowerDebtAssets is 0 then we have no interest\n            if (ltvData.borrowerDebtAssets != 0) ltvData.borrowerDebtAssets++;\n        }\n\n        {\n            (uint256 collateralValue, uint256 debtValue) =\n                SiloSolvencyLib.getPositionValues(ltvData, _collateralConfig.token, _debtConfig.token);\n\n            assets = SiloMathLib.calculateMaxAssetsToWithdraw({\n                _sumOfCollateralsValue: collateralValue,\n                _debtValue: debtValue,\n                _lt: _collateralConfig.lt,\n                _borrowerCollateralAssets: ltvData.borrowerCollateralAssets,\n                _borrowerProtectedAssets: ltvData.borrowerProtectedAssets\n            });\n        }\n\n        (assets, shares) = SiloMathLib.maxWithdrawToAssetsAndShares({\n            _maxAssets: assets,\n            _borrowerCollateralAssets: ltvData.borrowerCollateralAssets,\n            _borrowerProtectedAssets: ltvData.borrowerProtectedAssets,\n            _collateralType: _collateralType,\n            _totalAssets: _totalAssets,\n            _assetTypeShareTokenTotalSupply: _shareTokenTotalSupply,\n            _liquidity: _liquidity\n        });\n\n        if (assets != 0) {\n            // recalculate assets due to rounding error that we have in convertToShares\n            assets = SiloMathLib.convertToAssets(\n                shares,\n                _totalAssets,\n                _shareTokenTotalSupply,\n                Rounding.MAX_WITHDRAW_TO_ASSETS,\n                ISilo.AssetType(uint256(_collateralType))\n            );\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloMathLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n// solhint-disable ordering\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\nimport {Rounding} from \"../lib/Rounding.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\n\nlibrary SiloMathLib {\n    using Math for uint256;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    uint256 internal constant _DECIMALS_OFFSET = 3;\n\n    /// @dev this is constant version of openzeppelin5/contracts/token/ERC20/extensions/ERC4626._decimalsOffset\n    uint256 internal constant _DECIMALS_OFFSET_POW = 10 ** _DECIMALS_OFFSET;\n\n    /// @notice Returns available liquidity to be borrowed\n    /// @dev Accrued interest is entirely added to `debtAssets` but only part of it is added to `collateralAssets`. The\n    ///      difference is DAO's and deployer's cut. That means DAO's and deployer's cut is not considered a borrowable\n    ///      liquidity.\n    function liquidity(uint256 _collateralAssets, uint256 _debtAssets) internal pure returns (uint256 liquidAssets) {\n        unchecked {\n            // we checked the underflow\n            liquidAssets = _debtAssets > _collateralAssets ? 0 : _collateralAssets - _debtAssets;\n        }\n    }\n\n    /// @notice Calculate collateral assets with accrued interest and associated fees\n    /// @param _collateralAssets The total amount of collateral assets\n    /// @param _debtAssets The total amount of debt assets\n    /// @param _rcomp Compound interest rate for debt\n    /// @param _daoFee The fee (in 18 decimals points) to be taken for the DAO\n    /// @param _deployerFee The fee (in 18 decimals points) to be taken for the deployer\n    /// @return collateralAssetsWithInterest The total collateral assets including the accrued interest\n    /// @return debtAssetsWithInterest The debt assets with accrued interest\n    /// @return daoAndDeployerRevenue Total fees amount to be split between DAO and deployer\n    /// @return accruedInterest The total accrued interest\n    function getCollateralAmountsWithInterest(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _rcomp,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    )\n        internal\n        pure\n        returns (\n            uint256 collateralAssetsWithInterest,\n            uint256 debtAssetsWithInterest,\n            uint256 daoAndDeployerRevenue,\n            uint256 accruedInterest\n        )\n    {\n        (debtAssetsWithInterest, accruedInterest) = getDebtAmountsWithInterest(_debtAssets, _rcomp);\n\n        uint256 fees;\n\n        // _daoFee and _deployerFee are expected to be less than 1e18, so we will not overflow\n        unchecked { fees = _daoFee + _deployerFee; }\n\n        daoAndDeployerRevenue = mulDivOverflow(accruedInterest, fees, _PRECISION_DECIMALS);\n\n        // we will not underflow because daoAndDeployerRevenue is chunk of accruedInterest\n        uint256 collateralInterest = accruedInterest - daoAndDeployerRevenue;\n\n        uint256 cap;\n        // save to uncheck because variable can not be more than max\n        unchecked { cap = type(uint256).max - _collateralAssets; }\n\n        if (cap < collateralInterest) {\n            // avoid overflow on interest\n            collateralInterest = cap;\n        }\n\n        // safe to uncheck because of cap\n        unchecked {  collateralAssetsWithInterest = _collateralAssets + collateralInterest; }\n    }\n\n    /// @notice Calculate the debt assets with accrued interest, it should never revert with over/under flow\n    /// @param _totalDebtAssets The total amount of debt assets before accrued interest\n    /// @param _rcomp Compound interest rate for the debt in 18 decimal precision\n    /// @return debtAssetsWithInterest The debt assets including the accrued interest\n    /// @return accruedInterest The total amount of interest accrued on the debt assets\n    function getDebtAmountsWithInterest(uint256 _totalDebtAssets, uint256 _rcomp)\n        internal\n        pure\n        returns (uint256 debtAssetsWithInterest, uint256 accruedInterest)\n    {\n        if (_totalDebtAssets == 0 || _rcomp == 0) {\n            return (_totalDebtAssets, 0);\n        }\n\n        accruedInterest = mulDivOverflow(_totalDebtAssets, _rcomp, _PRECISION_DECIMALS);\n\n        unchecked {\n            // We intentionally allow overflow here, to prevent transaction revert due to interest calculation.\n            debtAssetsWithInterest = _totalDebtAssets + accruedInterest;\n\n            // If overflow occurs, we skip accruing interest.\n            if (debtAssetsWithInterest < _totalDebtAssets) {\n                debtAssetsWithInterest = _totalDebtAssets;\n                accruedInterest = 0;\n            }\n        }\n    }\n\n    /// @notice Calculates fraction between borrowed and deposited amount of tokens denominated in percentage\n    /// @dev It assumes `_dp` = 100%.\n    /// @param _dp decimal points used by model\n    /// @param _collateralAssets current total deposits for assets\n    /// @param _debtAssets current total borrows for assets\n    /// @return utilization value, capped to 100%\n    /// Limiting utilization ratio by 100% max will allows us to perform better interest rate computations\n    /// and should not affect any other part of protocol. It is possible to go over 100% only when bad debt.\n    function calculateUtilization(uint256 _dp, uint256 _collateralAssets, uint256 _debtAssets)\n        internal\n        pure\n        returns (uint256 utilization)\n    {\n        if (_collateralAssets == 0 || _debtAssets == 0 || _dp == 0) return 0;\n\n        /*\n            how to prevent overflow on: _debtAssets.mulDiv(_dp, _collateralAssets, Rounding.ACCRUED_INTEREST):\n            1. max > _debtAssets * _dp / _collateralAssets\n            2. max / _dp > _debtAssets / _collateralAssets\n        */\n        if (type(uint256).max / _dp > _debtAssets / _collateralAssets) {\n            utilization = _debtAssets.mulDiv(_dp, _collateralAssets, Rounding.ACCRUED_INTEREST);\n            // cap at 100%\n            if (utilization > _dp) utilization = _dp;\n        } else {\n            // we have overflow\n            utilization = _dp;\n        }\n    }\n\n    function convertToAssetsOrToShares(\n        uint256 _assets,\n        uint256 _shares,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _roundingToAssets,\n        Math.Rounding _roundingToShares,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 assets, uint256 shares) {\n        if (_assets == 0) {\n            require(_shares != 0, ISilo.InputZeroShares());\n            shares = _shares;\n            assets = convertToAssets(_shares, _totalAssets, _totalShares, _roundingToAssets, _assetType);\n            require(assets != 0, ISilo.ReturnZeroAssets());\n        } else if (_shares == 0) {\n            shares = convertToShares(_assets, _totalAssets, _totalShares, _roundingToShares, _assetType);\n            assets = _assets;\n            require(shares != 0, ISilo.ReturnZeroShares());\n        } else {\n            revert ISilo.InputCanBeAssetsOrShares();\n        }\n    }\n\n    /// @dev Math for collateral is exact copy of\n    ///      openzeppelin5/contracts/token/ERC20/extensions/ERC4626._convertToShares\n    function convertToShares(\n        uint256 _assets,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _rounding,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 shares) {\n        (uint256 totalShares, uint256 totalAssets) = _commonConvertTo(_totalAssets, _totalShares, _assetType);\n\n        // initially, in case of debt, if silo is empty we return shares==assets\n        // for collateral, this will never be the case, because we are adding `+1` and offset in `_commonConvertTo`\n        if (totalShares == 0) return _assets;\n\n        shares = _assets.mulDiv(totalShares, totalAssets, _rounding);\n    }\n\n    /// @dev Math for collateral is exact copy of\n    ///      openzeppelin5/contracts/token/ERC20/extensions/ERC4626._convertToAssets\n    function convertToAssets(\n        uint256 _shares,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _rounding,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 assets) {\n        (uint256 totalShares, uint256 totalAssets) = _commonConvertTo(_totalAssets, _totalShares, _assetType);\n\n        // initially, in case of debt, if silo is empty we return shares==assets\n        // for collateral, this will never be the case, because of `+1` in line above\n        if (totalShares == 0) return _shares;\n\n        assets = _shares.mulDiv(totalAssets, totalShares, _rounding);\n    }\n\n    /// @param _collateralMaxLtv maxLTV in 18 decimals that is set for debt asset\n    /// @param _sumOfBorrowerCollateralValue borrower total collateral value (including protected)\n    /// @param _borrowerDebtValue total value of borrower debt\n    /// @return maxBorrowValue max borrow value yet available for borrower\n    function calculateMaxBorrowValue(\n        uint256 _collateralMaxLtv,\n        uint256 _sumOfBorrowerCollateralValue,\n        uint256 _borrowerDebtValue\n    ) internal pure returns (uint256 maxBorrowValue) {\n        if (_sumOfBorrowerCollateralValue == 0) {\n            return 0;\n        }\n\n        uint256 maxDebtValue = _sumOfBorrowerCollateralValue.mulDiv(\n            _collateralMaxLtv, _PRECISION_DECIMALS, Rounding.MAX_BORROW_VALUE\n        );\n\n        unchecked {\n            // we will not underflow because we checking `maxDebtValue > _borrowerDebtValue`\n            maxBorrowValue = maxDebtValue > _borrowerDebtValue ? maxDebtValue - _borrowerDebtValue : 0;\n        }\n    }\n\n    /// @notice Calculate the maximum assets a borrower can withdraw without breaching the liquidation threshold\n    /// @param _sumOfCollateralsValue The combined value of collateral and protected assets of the borrower\n    /// @param _debtValue The total debt value of the borrower\n    /// @param _lt The liquidation threshold in 18 decimal points\n    /// @param _borrowerCollateralAssets The borrower's collateral assets before the withdrawal\n    /// @param _borrowerProtectedAssets The borrower's protected assets before the withdrawal\n    /// @return maxAssets The maximum assets the borrower can safely withdraw\n    function calculateMaxAssetsToWithdraw(\n        uint256 _sumOfCollateralsValue,\n        uint256 _debtValue,\n        uint256 _lt,\n        uint256 _borrowerCollateralAssets,\n        uint256 _borrowerProtectedAssets\n    ) internal pure returns (uint256 maxAssets) {\n        if (_sumOfCollateralsValue == 0) return 0;\n        if (_debtValue == 0) return _sumOfCollateralsValue;\n        if (_lt == 0) return 0;\n\n        // using Rounding.LT (up) to have highest collateralValue that we have to leave for user to stay solvent\n        uint256 minimumCollateralValue = _debtValue.mulDiv(_PRECISION_DECIMALS, _lt, Rounding.LTV);\n\n        // if we over LT, we can not withdraw\n        if (_sumOfCollateralsValue <= minimumCollateralValue) {\n            return 0;\n        }\n\n        uint256 spareCollateralValue;\n        // safe because we checked `if (_sumOfCollateralsValue <= minimumCollateralValue)`\n        unchecked { spareCollateralValue = _sumOfCollateralsValue - minimumCollateralValue; }\n\n        maxAssets = (_borrowerProtectedAssets + _borrowerCollateralAssets)\n                .mulDiv(spareCollateralValue, _sumOfCollateralsValue, Rounding.MAX_WITHDRAW_TO_ASSETS);\n    }\n\n    /// @notice Determines the maximum number of assets and corresponding shares a borrower can safely withdraw\n    /// @param _maxAssets The calculated limit on how many assets can be withdrawn without breaching the liquidation\n    /// threshold\n    /// @param _borrowerCollateralAssets Amount of collateral assets currently held by the borrower\n    /// @param _borrowerProtectedAssets Amount of protected assets currently held by the borrower\n    /// @param _collateralType Specifies whether the asset is of type Collateral or Protected\n    /// @param _totalAssets The entire quantity of assets available in the system for withdrawal\n    /// @param _assetTypeShareTokenTotalSupply Total supply of share tokens for the specified asset type\n    /// @param _liquidity Current liquidity in the system for the asset type\n    /// @return assets Maximum assets the borrower can withdraw\n    /// @return shares Corresponding number of shares for the derived `assets` amount\n    function maxWithdrawToAssetsAndShares(\n        uint256 _maxAssets,\n        uint256 _borrowerCollateralAssets,\n        uint256 _borrowerProtectedAssets,\n        ISilo.CollateralType _collateralType,\n        uint256 _totalAssets,\n        uint256 _assetTypeShareTokenTotalSupply,\n        uint256 _liquidity\n    ) internal pure returns (uint256 assets, uint256 shares) {\n        if (_maxAssets == 0) return (0, 0);\n        if (_assetTypeShareTokenTotalSupply == 0) return (0, 0);\n\n        if (_collateralType == ISilo.CollateralType.Collateral) {\n            assets = _maxAssets > _borrowerCollateralAssets ? _borrowerCollateralAssets : _maxAssets;\n\n            if (assets > _liquidity) {\n                assets = _liquidity;\n            }\n        } else {\n            assets = _maxAssets > _borrowerProtectedAssets ? _borrowerProtectedAssets : _maxAssets;\n        }\n\n        shares = SiloMathLib.convertToShares(\n            assets,\n            _totalAssets,\n            _assetTypeShareTokenTotalSupply,\n            Rounding.MAX_WITHDRAW_TO_SHARES,\n            ISilo.AssetType(uint256(_collateralType))\n        );\n    }\n\n    /// @dev executed `_a * _b / _c`, reverts on _c == 0\n    /// @return mulDivResult on overflow returns 0\n    function mulDivOverflow(uint256 _a, uint256 _b, uint256 _c)\n        internal\n        pure\n        returns (uint256 mulDivResult)\n    {\n        if (_a == 0) return (0);\n\n        unchecked {\n            // we have to uncheck to detect overflow\n            mulDivResult = _a * _b;\n            if (mulDivResult / _a != _b) return 0;\n\n            mulDivResult /= _c;\n        }\n    }\n\n    /// @dev Debt calculations should not lower the result. Debt is a liability so protocol should not take any for\n    /// itself. It should return actual result and round it up.\n    function _commonConvertTo(\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        ISilo.AssetType _assetType\n    ) private pure returns (uint256 totalShares, uint256 totalAssets) {\n        if (_totalShares == 0) {\n            // silo is empty and we have dust to redistribute: this can only happen when everyone exits silo\n            // this case can happen only for collateral, because for collateral we rounding in favorite of protocol\n            // by resetting totalAssets, the dust that we have will go to first depositor and we starts from clean state\n            _totalAssets = 0;\n        }\n\n            (totalShares, totalAssets) = _assetType == ISilo.AssetType.Debt\n                ? (_totalShares, _totalAssets)\n                : (_totalShares + _DECIMALS_OFFSET_POW, _totalAssets + 1);\n    }\n\n    /// @dev Calculates the fraction of a given total and percentage\n    /// @param _total The total value to calculate the fraction from\n    /// @param _percent The percentage to calculate the fraction from\n    /// @param _currentFraction The current fraction to add to the result\n    /// @return integral The integral part of the fraction\n    /// @return fraction The fractional part of the fraction\n    function calculateFraction(\n        uint256 _total,\n        uint256 _percent,\n        uint64 _currentFraction\n    ) internal pure returns (uint256 integral, uint64 fraction) {\n        if (_total == 0) {\n            return (0, _currentFraction);\n        }\n\n        unchecked {\n            // safe to unchecked because: _currentFraction if never more than max uint256, div is safe\n            if (type(uint256).max / _total < _percent) {\n                // when overflow, reset `_currentFraction ` to zero as part of circuit breaker\n                return (0, 0);\n            }\n\n            // `_total * _percent` safe to unchecked because we checked for overflow in above `if`\n            // `% _PRECISION_DECIMALS` safe, because max value after modulo will be 1e18 - 1  (_PRECISION_DECIMALS - 1)\n            // and this is less than 2 ** 64\n            // calculate remainder for current interest\n            uint256 remainder = (_total * _percent) % _PRECISION_DECIMALS;\n            // integral is amount above 1e18 after adding _currentFraction and remainder\n            integral = (_currentFraction + remainder) / _PRECISION_DECIMALS;\n            // fraction is what we get below 1e18\n            fraction = uint64((_currentFraction + remainder) % _PRECISION_DECIMALS);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/Rounding.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\n// solhint-disable private-vars-leading-underscore\nlibrary Rounding {\n    Math.Rounding internal constant UP = Math.Rounding.Ceil;\n    Math.Rounding internal constant DOWN = Math.Rounding.Floor;\n    Math.Rounding internal constant DEBT_TO_ASSETS = Math.Rounding.Ceil;\n    // COLLATERAL_TO_ASSETS is used to calculate borrower collateral (so we want to round down)\n    Math.Rounding internal constant COLLATERAL_TO_ASSETS = Math.Rounding.Floor;\n    // why DEPOSIT_TO_ASSETS is Up if COLLATERAL_TO_ASSETS is Down?\n    // DEPOSIT_TO_ASSETS is used for preview deposit and deposit, based on provided shares we want to pull \"more\" tokens\n    // so we rounding up, \"token flow\" is in different direction than for COLLATERAL_TO_ASSETS, that's why\n    // different rounding policy\n    Math.Rounding internal constant DEPOSIT_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant DEPOSIT_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant BORROW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant BORROW_TO_SHARES = Math.Rounding.Ceil;\n    Math.Rounding internal constant MAX_BORROW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_BORROW_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_BORROW_VALUE = Math.Rounding.Floor;\n    Math.Rounding internal constant REPAY_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant REPAY_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_REPAY_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant WITHDRAW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant WITHDRAW_TO_SHARES = Math.Rounding.Ceil;\n    Math.Rounding internal constant MAX_WITHDRAW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_WITHDRAW_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant LIQUIDATE_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant LTV = Math.Rounding.Ceil;\n    Math.Rounding internal constant ACCRUED_INTEREST = Math.Rounding.Floor;\n    Math.Rounding internal constant DAO_REVENUE = Math.Rounding.Ceil;\n}\n"
    },
    "silo-core/contracts/lib/Hook.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.28;\n\nimport {ISilo} from \"../interfaces/ISilo.sol\";\n\n// solhint-disable private-vars-leading-underscore\nlibrary Hook {\n    /// @notice The data structure for the deposit hook\n    /// @param assets The amount of assets deposited\n    /// @param shares The amount of shares deposited\n    /// @param receiver The receiver of the deposit\n    struct BeforeDepositInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n    }\n\n    /// @notice The data structure for the deposit hook\n    /// @param assets The amount of assets deposited\n    /// @param shares The amount of shares deposited\n    /// @param receiver The receiver of the deposit\n    /// @param receivedAssets The exact amount of assets being deposited\n    /// @param mintedShares The exact amount of shares being minted\n    struct AfterDepositInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        uint256 receivedAssets;\n        uint256 mintedShares;\n    }\n\n    /// @notice The data structure for the withdraw hook\n    /// @param assets The amount of assets withdrawn\n    /// @param shares The amount of shares withdrawn\n    /// @param receiver The receiver of the withdrawal\n    /// @param owner The owner of the shares\n    /// @param spender The spender of the shares\n    struct BeforeWithdrawInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n    }\n\n    /// @notice The data structure for the withdraw hook\n    /// @param assets The amount of assets withdrawn\n    /// @param shares The amount of shares withdrawn\n    /// @param receiver The receiver of the withdrawal\n    /// @param owner The owner of the shares\n    /// @param spender The spender of the shares\n    /// @param withdrawnAssets The exact amount of assets being withdrawn\n    /// @param withdrawnShares The exact amount of shares being withdrawn\n    struct AfterWithdrawInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        uint256 withdrawnAssets;\n        uint256 withdrawnShares;\n    }\n\n    /// @notice The data structure for the share token transfer hook\n    /// @param sender The sender of the transfer (address(0) on mint)\n    /// @param recipient The recipient of the transfer (address(0) on burn)\n    /// @param amount The amount of tokens transferred/minted/burned\n    /// @param senderBalance The balance of the sender after the transfer (empty on mint)\n    /// @param recipientBalance The balance of the recipient after the transfer (empty on burn)\n    /// @param totalSupply The total supply of the share token\n    struct AfterTokenTransfer {\n        address sender;\n        address recipient;\n        uint256 amount;\n        uint256 senderBalance;\n        uint256 recipientBalance;\n        uint256 totalSupply;\n    }\n\n    /// @notice The data structure for the before borrow hook\n    /// @param assets The amount of assets to borrow\n    /// @param shares The amount of shares to borrow\n    /// @param receiver The receiver of the borrow\n    /// @param borrower The borrower of the assets\n    /// @param _spender Address which initiates the borrowing action on behalf of the borrower\n    struct BeforeBorrowInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n    }\n\n    /// @notice The data structure for the after borrow hook\n    /// @param assets The amount of assets borrowed\n    /// @param shares The amount of shares borrowed\n    /// @param receiver The receiver of the borrow\n    /// @param borrower The borrower of the assets\n    /// @param spender Address which initiates the borrowing action on behalf of the borrower\n    /// @param borrowedAssets The exact amount of assets being borrowed\n    /// @param borrowedShares The exact amount of shares being borrowed\n    struct AfterBorrowInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        uint256 borrowedAssets;\n        uint256 borrowedShares;\n    }\n\n    /// @notice The data structure for the before repay hook\n    /// @param assets The amount of assets to repay\n    /// @param shares The amount of shares to repay\n    /// @param borrower The borrower of the assets\n    /// @param repayer The repayer of the assets\n    struct BeforeRepayInput {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n    }\n\n    /// @notice The data structure for the after repay hook\n    /// @param assets The amount of assets to repay\n    /// @param shares The amount of shares to repay\n    /// @param borrower The borrower of the assets\n    /// @param repayer The repayer of the assets\n    /// @param repaidAssets The exact amount of assets being repaid\n    /// @param repaidShares The exact amount of shares being repaid\n    struct AfterRepayInput {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n        uint256 repaidAssets;\n        uint256 repaidShares;\n    }\n\n    /// @notice The data structure for the before flash loan hook\n    /// @param receiver The flash loan receiver\n    /// @param token The flash loan token\n    /// @param amount Requested amount of tokens\n    struct BeforeFlashLoanInput {\n        address receiver;\n        address token;\n        uint256 amount;\n    }\n\n    /// @notice The data structure for the after flash loan hook\n    /// @param receiver The flash loan receiver\n    /// @param token The flash loan token\n    /// @param amount Received amount of tokens\n    /// @param fee The flash loan fee\n    struct AfterFlashLoanInput {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint256 fee;\n    }\n\n    /// @notice The data structure for the before transition collateral hook\n    /// @param shares The amount of shares to transition\n    struct BeforeTransitionCollateralInput {\n        uint256 shares;\n        address owner;\n    }\n\n    /// @notice The data structure for the after transition collateral hook\n    /// @param shares The amount of shares to transition\n    struct AfterTransitionCollateralInput {\n        uint256 shares;\n        address owner;\n        uint256 assets;\n    }\n\n    /// @notice The data structure for the switch collateral hook\n    /// @param user The user switching collateral\n    struct SwitchCollateralInput {\n        address user;\n    }\n\n    /// @notice Supported hooks\n    /// @dev The hooks are stored as a bitmap and can be combined with bitwise OR\n    uint256 internal constant NONE = 0;\n    uint256 internal constant DEPOSIT = 2 ** 1;\n    uint256 internal constant BORROW = 2 ** 2;\n    uint256 internal constant BORROW_SAME_ASSET = 2 ** 3; // deprecated\n    uint256 internal constant REPAY = 2 ** 4;\n    uint256 internal constant WITHDRAW = 2 ** 5;\n    uint256 internal constant FLASH_LOAN = 2 ** 6;\n    uint256 internal constant TRANSITION_COLLATERAL = 2 ** 7;\n    uint256 internal constant SWITCH_COLLATERAL = 2 ** 8; // deprecated\n    uint256 internal constant SHARE_TOKEN_TRANSFER = 2 ** 10;\n    uint256 internal constant COLLATERAL_TOKEN = 2 ** 11;\n    uint256 internal constant PROTECTED_TOKEN = 2 ** 12;\n    uint256 internal constant DEBT_TOKEN = 2 ** 13;\n\n    // note: currently we can support hook value up to 2 ** 23,\n    // because for optimisation purposes, we storing hooks as uint24\n\n    // For decoding packed data\n    uint256 private constant PACKED_ADDRESS_LENGTH = 20;\n    uint256 private constant PACKED_FULL_LENGTH = 32;\n    uint256 private constant PACKED_ENUM_LENGTH = 1;\n    uint256 private constant PACKED_BOOL_LENGTH = 1;\n\n    error FailedToParseBoolean();\n    error InvalidTokenType();\n\n    /// @notice Checks if the action has a specific hook\n    /// @param _action The action\n    /// @param _expectedHook The expected hook\n    /// @dev The function returns true if the action has the expected hook.\n    /// As hooks actions can be combined with bitwise OR, the following examples are valid:\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, WITHDRAW) == true`\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, COLLATERAL_TOKEN) == true`\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, WITHDRAW | COLLATERAL_TOKEN) == true`\n    function matchAction(uint256 _action, uint256 _expectedHook) internal pure returns (bool) {\n        return (_action & _expectedHook) == _expectedHook;\n    }\n\n    /// @notice Adds a hook to an action\n    /// @param _action The action\n    /// @param _newAction The new hook to be added\n    function addAction(uint256 _action, uint256 _newAction) internal pure returns (uint256) {\n        return _action | _newAction;\n    }\n\n    /// @dev please be careful with removing actions, because other hooks might using them\n    /// eg when you have `_action = COLLATERAL_TOKEN | PROTECTED_TOKEN | SHARE_TOKEN_TRANSFER`\n    /// and you want to remove action on protected token transfer by doing\n    /// `remove(_action, PROTECTED_TOKEN | SHARE_TOKEN_TRANSFER)`, the result will be `_action=COLLATERAL_TOKEN`\n    /// and it will not trigger collateral token transfer. In this example you should do:\n    /// `remove(_action, PROTECTED_TOKEN)`\n    function removeAction(uint256 _action, uint256 _actionToRemove) internal pure returns (uint256) {\n        return _action & (~_actionToRemove);\n    }\n\n    /// @notice Returns the action for depositing a specific collateral type\n    /// @param _type The collateral type\n    function depositAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return DEPOSIT | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the action for withdrawing a specific collateral type\n    /// @param _type The collateral type\n    function withdrawAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return WITHDRAW | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the action for collateral transition\n    /// @param _type The collateral type\n    function transitionCollateralAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return TRANSITION_COLLATERAL | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the share token transfer action\n    /// @param _tokenType The token type (COLLATERAL_TOKEN || PROTECTED_TOKEN || DEBT_TOKEN)\n    function shareTokenTransfer(uint256 _tokenType) internal pure returns (uint256) {\n        require(\n            _tokenType == COLLATERAL_TOKEN || _tokenType == PROTECTED_TOKEN || _tokenType == DEBT_TOKEN,\n            InvalidTokenType()\n        );\n\n        return SHARE_TOKEN_TRANSFER | _tokenType;\n    }\n\n    /// @dev Decodes packed data from the share token after the transfer hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterTokenTransferDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterTokenTransfer memory input)\n    {\n        address sender;\n        address recipient;\n        uint256 amount;\n        uint256 senderBalance;\n        uint256 recipientBalance;\n        uint256 totalSupply;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            sender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            recipient := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            senderBalance := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            recipientBalance := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            totalSupply := mload(add(packed, pointer))\n        }\n\n        input = AfterTokenTransfer(sender, recipient, amount, senderBalance, recipientBalance, totalSupply);\n    }\n\n    /// @dev Decodes packed data from the deposit hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeDepositDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeDepositInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n        }\n\n        input = BeforeDepositInput(assets, shares, receiver);\n    }\n\n    /// @dev Decodes packed data from the deposit hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterDepositDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterDepositInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        uint256 receivedAssets;\n        uint256 mintedShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            receivedAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            mintedShares := mload(add(packed, pointer))\n        }\n\n        input = AfterDepositInput(assets, shares, receiver, receivedAssets, mintedShares);\n    }\n\n    /// @dev Decodes packed data from the withdraw hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeWithdrawDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeWithdrawInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n        }\n\n        input = BeforeWithdrawInput(assets, shares, receiver, owner, spender);\n    }\n\n    /// @dev Decodes packed data from the withdraw hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterWithdrawDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterWithdrawInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        uint256 withdrawnAssets;\n        uint256 withdrawnShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            withdrawnAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            withdrawnShares := mload(add(packed, pointer))\n        }\n\n        input = AfterWithdrawInput(assets, shares, receiver, owner, spender, withdrawnAssets, withdrawnShares);\n    }\n\n    /// @dev Decodes packed data from the before borrow hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeBorrowDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeBorrowInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n        }\n\n        input = BeforeBorrowInput(assets, shares, receiver, borrower, spender);\n    }\n\n    /// @dev Decodes packed data from the after borrow hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterBorrowDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterBorrowInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        uint256 borrowedAssets;\n        uint256 borrowedShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            borrowedAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            borrowedShares := mload(add(packed, pointer))\n        }\n\n        input = AfterBorrowInput(assets, shares, receiver, borrower, spender, borrowedAssets, borrowedShares);\n    }\n\n    /// @dev Decodes packed data from the before repay hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeRepayDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeRepayInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            repayer := mload(add(packed, pointer))\n        }\n\n        input = BeforeRepayInput(assets, shares, borrower, repayer);\n    }\n\n    /// @dev Decodes packed data from the after repay hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterRepayDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterRepayInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n        uint256 repaidAssets;\n        uint256 repaidShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            repayer := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            repaidAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            repaidShares := mload(add(packed, pointer))\n        }\n\n        input = AfterRepayInput(assets, shares, borrower, repayer, repaidAssets, repaidShares);\n    }\n\n    /// @dev Decodes packed data from the before flash loan hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeFlashLoanDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeFlashLoanInput memory input)\n    {\n        address receiver;\n        address token;\n        uint256 amount;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            token := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n        }\n\n        input = BeforeFlashLoanInput(receiver, token, amount);\n    }\n\n    /// @dev Decodes packed data from the before flash loan hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterFlashLoanDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterFlashLoanInput memory input)\n    {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint256 fee;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            token := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            fee := mload(add(packed, pointer))\n        }\n\n        input = AfterFlashLoanInput(receiver, token, amount, fee);\n    }\n\n    /// @dev Decodes packed data from the transition collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeTransitionCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeTransitionCollateralInput memory input)\n    {\n        uint256 shares;\n        address owner;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n        }\n\n        input = BeforeTransitionCollateralInput(shares, owner);\n    }\n\n    /// @dev Decodes packed data from the transition collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterTransitionCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterTransitionCollateralInput memory input)\n    {\n        uint256 shares;\n        address owner;\n        uint256 assets;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            assets := mload(add(packed, pointer))\n        }\n\n        input = AfterTransitionCollateralInput(shares, owner, assets);\n    }\n\n    /// @dev Decodes packed data from the switch collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function switchCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (SwitchCollateralInput memory input)\n    {\n        address user;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            user := mload(add(packed, pointer))\n        }\n\n        input = SwitchCollateralInput(user);\n    }\n\n    /// @dev Converts a uint8 to a boolean\n    function _toBoolean(uint8 _value) internal pure returns (bool result) {\n        if (_value == 0) {\n            result = false;\n        } else if (_value == 1) {\n            result = true;\n        } else {\n            revert FailedToParseBoolean();\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/ShareTokenLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Strings} from \"openzeppelin5/utils/Strings.sol\";\n\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\n\nimport {TokenHelper} from \"../lib/TokenHelper.sol\";\nimport {CallBeforeQuoteLib} from \"../lib/CallBeforeQuoteLib.sol\";\nimport {Hook} from \"../lib/Hook.sol\";\n\n// solhint-disable ordering\n\nlibrary ShareTokenLib {\n    using Hook for uint24;\n    using CallBeforeQuoteLib for ISiloConfig.ConfigData;\n\n    // keccak256(abi.encode(uint256(keccak256(\"silo.storage.ShareToken\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _STORAGE_LOCATION = 0x01b0b3f9d6e360167e522fa2b18ba597ad7b2b35841fec7e1ca4dbb0adea1200;\n\n    function getShareTokenStorage() internal pure returns (IShareToken.ShareTokenStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, private-vars-leading-underscore\n    function __ShareToken_init(ISilo _silo, address _hookReceiver, uint24 _tokenType) external {\n        IShareToken.ShareTokenStorage storage $ = ShareTokenLib.getShareTokenStorage();\n\n        $.silo = _silo;\n        $.siloConfig = _silo.config();\n\n        $.hookSetup.hookReceiver = _hookReceiver;\n        $.hookSetup.tokenType = _tokenType;\n        $.transferWithChecks = true;\n    }\n\n    /// @dev decimals of share token\n    function decimals() external view returns (uint8) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        return uint8(TokenHelper.assertAndGetDecimals(configData.token));\n    }\n\n    /// @dev Name convention:\n    ///      NAME - asset name\n    ///      SILO_ID - unique silo id\n    ///\n    ///      Protected deposit: \"Silo Finance Non-borrowable NAME Deposit, SiloId: SILO_ID\"\n    ///      Borrowable deposit: \"Silo Finance Borrowable NAME Deposit, SiloId: SILO_ID\"\n    ///      Debt: \"Silo Finance NAME Debt, SiloId: SILO_ID\"\n    function name() external view returns (string memory) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        string memory siloIdAscii = Strings.toString($.siloConfig.SILO_ID());\n\n        string memory pre = \"\";\n        string memory post = \" Deposit\";\n\n        if (address(this) == configData.protectedShareToken) {\n            pre = \"Non-borrowable \";\n        } else if (address(this) == configData.collateralShareToken) {\n            pre = \"Borrowable \";\n        } else if (address(this) == configData.debtShareToken) {\n            post = \" Debt\";\n        }\n\n        string memory tokenSymbol = TokenHelper.symbol(configData.token);\n        return string.concat(\"Silo Finance \", pre, tokenSymbol, post, \", SiloId: \", siloIdAscii);\n    }\n\n    /// @dev Symbol convention:\n    ///      SYMBOL - asset symbol\n    ///      SILO_ID - unique silo id\n    ///\n    ///      Protected deposit: \"nbSYMBOL-SILO_ID\"\n    ///      Borrowable deposit: \"bSYMBOL-SILO_ID\"\n    ///      Debt: \"dSYMBOL-SILO_ID\"\n    function symbol() external view returns (string memory) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        string memory siloIdAscii = Strings.toString($.siloConfig.SILO_ID());\n\n        string memory pre;\n\n        if (address(this) == configData.protectedShareToken) {\n            pre = \"nb\";\n        } else if (address(this) == configData.collateralShareToken) {\n            pre = \"b\";\n        } else if (address(this) == configData.debtShareToken) {\n            pre = \"d\";\n        }\n\n        string memory tokenSymbol = TokenHelper.symbol(configData.token);\n        return string.concat(pre, tokenSymbol, \"-\", siloIdAscii);\n    }\n\n    /// @notice Call beforeQuote on solvency oracles\n    /// @param _user user address for which the solvent check is performed\n    function callOracleBeforeQuote(ISiloConfig _siloConfig, address _user) internal {\n        (\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        ) = _siloConfig.getConfigsForSolvency(_user);\n\n        collateralConfig.callSolvencyOracleBeforeQuote();\n        debtConfig.callSolvencyOracleBeforeQuote();\n    }\n\n    /// @dev Call on behalf of share token\n    /// @param _target target address to call\n    /// @param _value value to send\n    /// @param _callType call type\n    /// @param _input input data\n    /// @return success true if the call was successful, false otherwise\n    /// @return result bytes returned by the call\n    function callOnBehalfOfShareToken(address _target, uint256 _value, ISilo.CallType _callType, bytes calldata _input)\n        internal\n        returns (bool success, bytes memory result)\n    {\n        // Share token will not send back any ether leftovers after the call.\n        // The hook receiver should request the ether if needed in a separate call.\n        if (_callType == ISilo.CallType.Delegatecall) {\n            (success, result) = _target.delegatecall(_input); // solhint-disable-line avoid-low-level-calls\n        } else {\n            (success, result) = _target.call{value: _value}(_input); // solhint-disable-line avoid-low-level-calls\n        }\n    }\n\n    /// @dev checks if operation is \"real\" transfer\n    /// @param _sender sender address\n    /// @param _recipient recipient address\n    /// @return bool true if operation is real transfer, false if it is mint or burn\n    function isTransfer(address _sender, address _recipient) internal pure returns (bool) {\n        // in order this check to be true, it is required to have:\n        // require(sender != address(0), \"ERC20: transfer from the zero address\");\n        // require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        // on transfer. ERC20 has them, so we good.\n        return _sender != address(0) && _recipient != address(0);\n    }\n\n    function siloConfig() internal view returns (ISiloConfig thisSiloConfig) {\n        return ShareTokenLib.getShareTokenStorage().siloConfig;\n    }\n\n    function getConfig() internal view returns (ISiloConfig.ConfigData memory thisSiloConfigData) {\n        thisSiloConfigData = ShareTokenLib.getShareTokenStorage().siloConfig.getConfig(address(this));\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloStorageLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\n\nlibrary SiloStorageLib {\n    // keccak256(abi.encode(uint256(keccak256(\"silo.storage.SiloVault\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant _STORAGE_LOCATION = 0xd7513ffe3a01a9f6606089d1b67011bca35bec018ac0faa914e1c529408f8300;\n\n    function getSiloStorage() internal pure returns (ISilo.SiloStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "silo-core/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/// @notice https://eips.ethereum.org/EIPS/eip-3156\ninterface IERC3156FlashLender {\n    /// @notice Protected deposits are not available for a flash loan.\n    /// During the execution of the flashloan, Silo methods are not taking into consideration the fact,\n    /// that some (or all) tokens were transferred as flashloan, therefore some methods can return invalid state\n    /// eg. maxWithdraw can return amount that are not available to withdraw during flashlon.\n    /// @dev Initiate a flash loan.\n    /// @param _receiver The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)\n        external\n        returns (bool);\n\n    /// @dev The amount of currency available to be lent.\n    /// @param _token The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address _token) external view returns (uint256);\n\n    /// @dev The fee to be charged for a given loan.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address _token, uint256 _amount) external view returns (uint256);\n}\n"
    },
    "silo-core/contracts/interfaces/IHookReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\ninterface IHookReceiver {\n    struct HookConfig {\n        uint24 hooksBefore;\n        uint24 hooksAfter;\n    }\n\n    event HookConfigured(address silo, uint24 hooksBefore, uint24 hooksAfter);\n\n    /// @dev Revert if provided silo configuration during initialization is empty\n    error EmptySiloConfig();\n    /// @dev Revert if the hook receiver is already configured/initialized\n    error AlreadyConfigured();\n    /// @dev Revert if the caller is not a silo\n    error OnlySilo();\n    /// @dev Revert if the caller is not a silo or a share token\n    error OnlySiloOrShareToken();\n\n    /// @notice Initialize a hook receiver\n    /// @param _siloConfig Silo configuration with all the details about the silo\n    /// @param _data Data to initialize the hook receiver (if needed)\n    function initialize(ISiloConfig _siloConfig, bytes calldata _data) external;\n\n    /// @notice state of Silo before action, can be also without interest, if you need them, call silo.accrueInterest()\n    function beforeAction(address _silo, uint256 _action, bytes calldata _input) external;\n\n    function afterAction(address _silo, uint256 _action, bytes calldata _inputAndOutput) external;\n\n    /// @notice return hooksBefore and hooksAfter configuration\n    function hookReceiverConfig(address _silo) external view returns (uint24 hooksBefore, uint24 hooksAfter);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "silo-core/contracts/interfaces/ICrossReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ICrossReentrancyGuard {\n    error CrossReentrantCall();\n    error CrossReentrancyNotActive();\n\n    /// @notice only silo method for cross Silo reentrancy\n    function turnOnReentrancyProtection() external;\n\n    /// @notice only silo method for cross Silo reentrancy\n    function turnOffReentrancyProtection() external;\n\n    /// @notice view method for checking cross Silo reentrancy flag\n    /// @return entered true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n    /// `nonReentrant` function in the call stack.\n    function reentrancyGuardEntered() external view returns (bool entered);\n}"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "silo-core/contracts/lib/ShareCollateralTokenLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\n\nimport {ShareTokenLib} from \"./ShareTokenLib.sol\";\nimport {CallBeforeQuoteLib} from \"./CallBeforeQuoteLib.sol\";\nimport {SiloSolvencyLib} from \"./SiloSolvencyLib.sol\";\n\nlibrary ShareCollateralTokenLib {\n    using CallBeforeQuoteLib for ISiloConfig.ConfigData;\n\n    function isSolventAfterCollateralTransfer(address _sender) external returns (bool isSolvent) {\n        IShareToken.ShareTokenStorage storage $ = ShareTokenLib.getShareTokenStorage();\n        ISiloConfig siloConfig = $.siloConfig;\n\n        (\n            ISiloConfig.DepositConfig memory deposit,\n            ISiloConfig.ConfigData memory collateral,\n            ISiloConfig.ConfigData memory debt\n        ) = siloConfig.getConfigsForWithdraw(address($.silo), _sender);\n\n        // when deposit silo is collateral silo, that means this sToken is collateral for debt\n        if (collateral.silo != deposit.silo) return true;\n\n        siloConfig.accrueInterestForBothSilos();\n\n        ShareTokenLib.callOracleBeforeQuote(siloConfig, _sender);\n\n        isSolvent = SiloSolvencyLib.isSolvent(collateral, debt, _sender, ISilo.AccrueInterestInMemory.No);\n    }\n}\n"
    },
    "silo-core/contracts/utils/ShareToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {IERC20Permit} from \"openzeppelin5/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20PermitUpgradeable} from \"openzeppelin5-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin5-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {IERC20Metadata, IERC20} from \"openzeppelin5/token/ERC20/ERC20.sol\";\n\nimport {IHookReceiver} from \"../interfaces/IHookReceiver.sol\";\nimport {IShareToken, ISilo} from \"../interfaces/IShareToken.sol\";\nimport {ISiloConfig} from \"../SiloConfig.sol\";\nimport {Hook} from \"../lib/Hook.sol\";\nimport {CallBeforeQuoteLib} from \"../lib/CallBeforeQuoteLib.sol\";\nimport {NonReentrantLib} from \"../lib/NonReentrantLib.sol\";\nimport {ShareTokenLib} from \"../lib/ShareTokenLib.sol\";\nimport {SiloMathLib} from \"../lib/SiloMathLib.sol\";\nimport {IVersioned} from \"../interfaces/IVersioned.sol\";\n\n\n/// @title ShareToken\n/// @notice Implements common interface for Silo tokens representing debt or collateral.\n/// @dev Docs borrowed from https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v4.9.3\n///\n/// Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n/// https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n///\n/// This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n/// underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n/// the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n/// contract and not the \"assets\" token which is an independent contract.\n///\n/// [CAUTION]\n/// ====\n/// In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n/// with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or\n/// inflation attack and is essentially a problem of slippage. Vault deployers can protect against this attack by\n/// making an initial deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible.\n/// Withdrawals may similarly be affected by slippage. Users can protect against this attack as well as unexpected\n/// slippage in general by verifying the amount received is as expected, using a wrapper that performs these checks\n/// such as https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n///\n/// Since v4.9, this implementation uses virtual assets and shares to mitigate that risk. The `_decimalsOffset()`\n/// corresponds to an offset in the decimal representation between the underlying asset's decimals and the vault\n/// decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which itself\n/// determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default offset\n/// (0) makes it non-profitable, as a result of the value being captured by the virtual shares (out of the attacker's\n/// donation) matching the attacker's expected gains. With a larger offset, the attack becomes orders of magnitude more\n/// expensive than it is profitable. More details about the underlying math can be found\n/// xref:erc4626.adoc#inflation-attack[here].\n///\n/// The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n/// to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n/// will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n/// bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n/// `_convertToShares` and `_convertToAssets` functions.\n///\n/// To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n/// ====\n///\n/// _Available since v4.7._\n/// @custom:security-contact security@silo.finance\nabstract contract ShareToken is ERC20PermitUpgradeable, IShareToken, IVersioned {\n    using Hook for uint24;\n    using CallBeforeQuoteLib for ISiloConfig.ConfigData;\n\n    string private constant _NAME = \"SiloShareTokenEIP712Name\";\n\n    modifier onlySilo() {\n        require(msg.sender == address(_getSilo()), OnlySilo());\n\n        _;\n    }\n\n    modifier onlyHookReceiver() {\n        require(\n            msg.sender == address(ShareTokenLib.getShareTokenStorage().hookSetup.hookReceiver),\n            ISilo.OnlyHookReceiver()\n        );\n\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @inheritdoc IShareToken\n    function synchronizeHooks(uint24 _hooksBefore, uint24 _hooksAfter) external virtual onlySilo {\n        IShareToken.ShareTokenStorage storage $ = ShareTokenLib.getShareTokenStorage();\n\n        $.hookSetup.hooksBefore = _hooksBefore;\n        $.hookSetup.hooksAfter = _hooksAfter;\n    }\n\n    /// @inheritdoc IShareToken\n    function forwardTransferFromNoChecks(address _from, address _to, uint256 _amount)\n        external\n        virtual\n        onlyHookReceiver\n    {\n        IShareToken.ShareTokenStorage storage $ = ShareTokenLib.getShareTokenStorage();\n\n        $.transferWithChecks = false;\n        _transfer(_from, _to, _amount);\n        $.transferWithChecks = true;\n    }\n\n    /// @inheritdoc IShareToken\n    function decimalsOffset() external view virtual returns (uint256) {\n        return SiloMathLib._DECIMALS_OFFSET;\n    }\n\n    function silo() external view virtual returns (ISilo) {\n        return _getSilo();\n    }\n\n    function siloConfig() external view virtual returns (ISiloConfig) {\n        return _getSiloConfig();\n    }\n\n    function hookSetup() external view virtual returns (HookSetup memory) {\n        return ShareTokenLib.getShareTokenStorage().hookSetup;\n    }\n\n    function hookReceiver() external view virtual returns (address) {\n        return ShareTokenLib.getShareTokenStorage().hookSetup.hookReceiver;\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function transferFrom(address _from, address _to, uint256 _amount)\n        public\n        virtual\n        override(ERC20Upgradeable, IERC20)\n        returns (bool result)\n    {\n        ISiloConfig siloConfigCached = _crossNonReentrantBefore();\n\n        result = ERC20Upgradeable.transferFrom(_from, _to, _amount);\n\n        siloConfigCached.turnOffReentrancyProtection();\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function transfer(address _to, uint256 _amount)\n        public\n        virtual\n        override(ERC20Upgradeable, IERC20)\n        returns (bool result)\n    {\n        ISiloConfig siloConfigCached = _crossNonReentrantBefore();\n\n        result = ERC20Upgradeable.transfer(_to, _amount);\n\n        siloConfigCached.turnOffReentrancyProtection();\n    }\n\n    function approve(address spender, uint256 value)\n        public\n        virtual\n        override(ERC20Upgradeable, IERC20)\n        returns (bool result)\n    {\n        NonReentrantLib.nonReentrant(_getSiloConfig());\n\n        result = ERC20Upgradeable.approve(spender, value);\n    }\n\n    /// @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        NonReentrantLib.nonReentrant(_getSiloConfig());\n\n        ERC20PermitUpgradeable.permit(owner, spender, value, deadline, v, r, s);\n    }\n\n    /* solhint-disable */\n    /// @notice Decimals are the same as underlaying asset. Decimal offset is not accounted for in decimals.\n    /// @dev This does not imply a 1:1 ratio between shares and assets.\n    ///\n    /// Silo:\n    ///     decimals(): same as underlying asset\n    ///     offset: 3\n    ///     minted shares per 1 wei of asset deposited: 1000\n    /// ProtectedShareToken:\n    ///     decimals(): same as underlying asset\n    ///     offset: 3\n    ///     minted shares per 1 wei of asset deposited: 1000\n    /// DebtShareToken:\n    ///     decimals(): same as underlying asset\n    ///     offset: 0\n    ///     minted shares per 1 wei of asset borrowed: 1\n    ///\n    /// Learn more about the offset here:\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a7d38c7a3321e3832ca84f7ba1125dff9a91361e/contracts/token/ERC20/extensions/ERC4626.sol#L31\n    ///\n    /// The share-to-asset ratio may change over time due to interest accrual. As assets grow with interest\n    /// but the number of shares remains constant, the ratio will adjust dynamically.\n    ///\n    /// To determine the current conversion rate, use the vault’s `convertToShares(1 asset)` method.\n    function decimals() public view virtual override(ERC20Upgradeable, IERC20Metadata) returns (uint8) {\n        return ShareTokenLib.decimals();\n    }\n    /* solhint-enable */\n\n    /// @dev Name convention:\n    ///      NAME - asset name\n    ///      SILO_ID - unique silo id\n    ///\n    ///      Protected deposit: \"Silo Finance Non-borrowable NAME Deposit, SiloId: SILO_ID\"\n    ///      Borrowable deposit: \"Silo Finance Borrowable NAME Deposit, SiloId: SILO_ID\"\n    ///      Debt: \"Silo Finance NAME Debt, SiloId: SILO_ID\"\n    function name()\n        public\n        view\n        virtual\n        override(ERC20Upgradeable, IERC20Metadata)\n        returns (string memory)\n    {\n        return ShareTokenLib.name();\n    }\n\n    /// @dev Symbol convention:\n    ///      SYMBOL - asset symbol\n    ///      SILO_ID - unique silo id\n    ///\n    ///      Protected deposit: \"nbSYMBOL-SILO_ID\"\n    ///      Borrowable deposit: \"bSYMBOL-SILO_ID\"\n    ///      Debt: \"dSYMBOL-SILO_ID\"\n    function symbol()\n        public\n        view\n        virtual\n        override(ERC20Upgradeable, IERC20Metadata)\n        returns (string memory)\n    {\n        return ShareTokenLib.symbol();\n    }\n\n    function balanceOfAndTotalSupply(address _account) public view virtual returns (uint256, uint256) {\n        return (balanceOf(_account), totalSupply());\n    }\n\n    /// @dev Share token initialization\n    function _shareTokenInitialize(\n        ISilo _silo,\n        address _hookReceiver,\n        uint24 _tokenType\n    )\n        internal\n        virtual\n        initializer\n    {\n        __ERC20Permit_init(_NAME);\n\n        ShareTokenLib.__ShareToken_init(_silo, _hookReceiver, _tokenType);\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function _update(address from, address to, uint256 value) internal virtual override {\n        require(value != 0, ZeroTransfer());\n\n        _beforeTokenTransfer(from, to, value);\n\n        ERC20Upgradeable._update(from, to, value);\n\n        _afterTokenTransfer(from, to, value);\n    }\n\n    /// @dev By default, we do not have any hooks before token transfer. However,\n    /// derived contracts can override this function if they need to execute any logic before token transfer.\n    function _beforeTokenTransfer(address _sender, address _recipient, uint256 _amount) internal virtual {}\n\n    /// @dev Call an afterTokenTransfer hook if registered\n    function _afterTokenTransfer(address _sender, address _recipient, uint256 _amount) internal virtual {\n        IShareToken.ShareTokenStorage storage $ = ShareTokenLib.getShareTokenStorage();\n        HookSetup memory setup = $.hookSetup;\n\n        uint256 action = Hook.shareTokenTransfer(setup.tokenType);\n\n        if (!setup.hooksAfter.matchAction(action)) return;\n\n        // report mint, burn or transfer\n        // even if it is possible to leave silo in a middle of mint/burn, where we can have invalid state\n        // you can not enter any function because of cross reentrancy check\n        // invalid mid-state can be eg: in a middle of transitionCollateral, after burn but before mint\n        IHookReceiver(setup.hookReceiver).afterAction(\n            address($.silo),\n            action,\n            abi.encodePacked(_sender, _recipient, _amount, balanceOf(_sender), balanceOf(_recipient), totalSupply())\n        );\n    }\n\n    function _crossNonReentrantBefore()\n        internal\n        virtual\n        returns (ISiloConfig siloConfigCached)\n    {\n        siloConfigCached = _getSiloConfig();\n        siloConfigCached.turnOnReentrancyProtection();\n    }\n\n    function _getSiloConfig() internal view virtual returns (ISiloConfig) {\n        return ShareTokenLib.getShareTokenStorage().siloConfig;\n    }\n    \n    function _getSilo() internal view virtual returns (ISilo) {\n        return ShareTokenLib.getShareTokenStorage().silo;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return a == 0 ? 0 : (a - 1) / b + 1;\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.UNDER_OVERFLOW);\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, expect 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Ferma's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return x < 0 ? (n - uint256(-x)) : uint256(x); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked has failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/IInterestRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IInterestRateModelV2Config} from \"./IInterestRateModelV2Config.sol\";\n\ninterface IInterestRateModelV2 {\n    struct Config {\n        // uopt ∈ (0, 1) – optimal utilization;\n        int256 uopt;\n        // ucrit ∈ (uopt, 1) – threshold of large utilization;\n        int256 ucrit;\n        // ulow ∈ (0, uopt) – threshold of low utilization\n        int256 ulow;\n        // ki > 0 – integrator gain\n        int256 ki;\n        // kcrit > 0 – proportional gain for large utilization\n        int256 kcrit;\n        // klow ≥ 0 – proportional gain for low utilization\n        int256 klow;\n        // klin ≥ 0 – coefficient of the lower linear bound\n        int256 klin;\n        // beta ≥ 0 - a scaling factor\n        int256 beta;\n        // ri ≥ 0 – initial value of the integrator\n        int112 ri;\n        // Tcrit ≥ 0 - initial value of the time during which the utilization exceeds the critical value\n        int112 Tcrit;\n    }\n\n    struct Setup {\n        // ri ≥ 0 – the integrator\n        int112 ri;\n        // Tcrit ≥ 0 - the time during which the utilization exceeds the critical value\n        int112 Tcrit;\n        // flag that informs if setup is initialized\n        bool initialized;\n    }\n    /* solhint-enable */\n\n    error AddressZero();\n    error DeployConfigFirst();\n    error AlreadyInitialized();\n\n    error InvalidBeta();\n    error InvalidKcrit();\n    error InvalidKi();\n    error InvalidKlin();\n    error InvalidKlow();\n    error InvalidTcrit();\n    error InvalidTimestamps();\n    error InvalidUcrit();\n    error InvalidUlow();\n    error InvalidUopt();\n    error InvalidRi();\n\n    /// @dev Get config for given asset in a Silo.\n    /// @param _silo Silo address for which config should be set\n    /// @return Config struct for asset in Silo\n    function getConfig(address _silo) external view returns (Config memory);\n\n    /// @notice get the flag to detect rcomp restriction (zero current interest) due to overflow\n    /// overflow boolean flag to detect rcomp restriction\n    function overflowDetected(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (bool overflow);\n\n    /// @dev pure function that calculates current annual interest rate\n    /// @param _c configuration object, IInterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function calculateCurrentInterestRate(\n        Config calldata _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (uint256 rcur);\n\n    /// @dev pure function that calculates interest rate based on raw input data\n    /// @param _c configuration object, IInterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    /// @return ri current integral part of the rate\n    /// @return Tcrit time during which the utilization exceeds the critical value\n    /// @return overflow boolean flag to detect rcomp restriction\n    function calculateCompoundInterestRateWithOverflowDetection(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    )\n        external\n        pure\n        returns (\n            uint256 rcomp,\n            int256 ri,\n            int256 Tcrit,\n            bool overflow\n        );\n\n    /// @dev pure function that calculates interest rate based on raw input data\n    /// @param _c configuration object, IInterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    /// @return ri current integral part of the rate\n    /// @return Tcrit time during which the utilization exceeds the critical value\n    function calculateCompoundInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (uint256 rcomp, int256 ri, int256 Tcrit);\n}\n"
    },
    "silo-core/contracts/lib/SiloSolvencyLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\nimport {SiloStdLib, ISiloConfig, IShareToken, ISilo} from \"./SiloStdLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\n\nlibrary SiloSolvencyLib {\n    using Math for uint256;\n\n    struct LtvData {\n        ISiloOracle collateralOracle;\n        ISiloOracle debtOracle;\n        uint256 borrowerProtectedAssets;\n        uint256 borrowerCollateralAssets;\n        uint256 borrowerDebtAssets;\n    }\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n    uint256 internal constant _INFINITY = type(uint256).max;\n\n    /// @notice Determines if a borrower is solvent based on the Loan-to-Value (LTV) ratio\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower to check solvency for\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return True if the borrower is solvent, false otherwise\n    function isSolvent(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.AccrueInterestInMemory _accrueInMemory\n    ) internal view returns (bool) {\n        if (_debtConfig.silo == address(0)) return true; // no debt, so solvent\n\n        uint256 ltv = getLtv(\n            _collateralConfig,\n            _debtConfig,\n            _borrower,\n            ISilo.OracleType.Solvency,\n            _accrueInMemory,\n            IShareToken(_debtConfig.debtShareToken).balanceOf(_borrower)\n        );\n\n        return ltv <= _collateralConfig.lt;\n    }\n\n    /// @notice Determines if a borrower's Loan-to-Value (LTV) ratio is below the maximum allowed LTV\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower to check against max LTV\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return True if the borrower's LTV is below the maximum, false otherwise\n    function isBelowMaxLtv(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.AccrueInterestInMemory _accrueInMemory\n    ) internal view returns (bool) {\n        uint256 debtShareBalance = IShareToken(_debtConfig.debtShareToken).balanceOf(_borrower);\n        if (debtShareBalance == 0) return true;\n\n        uint256 ltv = getLtv(\n            _collateralConfig,\n            _debtConfig,\n            _borrower,\n            ISilo.OracleType.MaxLtv,\n            _accrueInMemory,\n            debtShareBalance\n        );\n\n        return ltv <= _collateralConfig.maxLtv;\n    }\n\n    /// @notice Retrieves assets data required for LTV calculations\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower whose LTV data is to be calculated\n    /// @param _oracleType Specifies whether to use the MaxLTV or Solvency oracle type for calculations\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @param _debtShareBalanceCached Cached value of debt share balance for the borrower. If debt shares of\n    /// `_borrower` is unknown, simply pass `0`.\n    /// @return ltvData Data structure containing necessary data to compute LTV\n    function getAssetsDataForLtvCalculations( // solhint-disable-line function-max-lines\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.OracleType _oracleType,\n        ISilo.AccrueInterestInMemory _accrueInMemory,\n        uint256 _debtShareBalanceCached\n    ) internal view returns (LtvData memory ltvData) {\n        if (_collateralConfig.token != _debtConfig.token) {\n            // When calculating maxLtv, use maxLtv oracle.\n            (ltvData.collateralOracle, ltvData.debtOracle) = _oracleType == ISilo.OracleType.MaxLtv\n                ? (ISiloOracle(_collateralConfig.maxLtvOracle), ISiloOracle(_debtConfig.maxLtvOracle))\n                : (ISiloOracle(_collateralConfig.solvencyOracle), ISiloOracle(_debtConfig.solvencyOracle));\n        }\n\n        uint256 totalShares;\n        uint256 shares;\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _collateralConfig.protectedShareToken, _borrower, 0 /* no cache */\n        );\n\n        (\n            uint256 totalCollateralAssets, uint256 totalProtectedAssets\n        ) = ISilo(_collateralConfig.silo).getCollateralAndProtectedTotalsStorage();\n\n        ltvData.borrowerProtectedAssets = SiloMathLib.convertToAssets(\n            shares, totalProtectedAssets, totalShares, Rounding.COLLATERAL_TO_ASSETS, ISilo.AssetType.Protected\n        );\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _collateralConfig.collateralShareToken, _borrower, 0 /* no cache */\n        );\n\n        totalCollateralAssets = _accrueInMemory == ISilo.AccrueInterestInMemory.Yes\n            ? SiloStdLib.getTotalCollateralAssetsWithInterest(\n                _collateralConfig.silo,\n                _collateralConfig.interestRateModel,\n                _collateralConfig.daoFee,\n                _collateralConfig.deployerFee\n            )\n            : totalCollateralAssets;\n\n        ltvData.borrowerCollateralAssets = SiloMathLib.convertToAssets(\n            shares, totalCollateralAssets, totalShares, Rounding.COLLATERAL_TO_ASSETS, ISilo.AssetType.Collateral\n        );\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _debtConfig.debtShareToken, _borrower, _debtShareBalanceCached\n        );\n\n        uint256 totalDebtAssets = _accrueInMemory == ISilo.AccrueInterestInMemory.Yes\n            ? SiloStdLib.getTotalDebtAssetsWithInterest(_debtConfig.silo, _debtConfig.interestRateModel)\n            : ISilo(_debtConfig.silo).getTotalAssetsStorage(ISilo.AssetType.Debt);\n\n        // BORROW value -> to assets -> UP\n        ltvData.borrowerDebtAssets = SiloMathLib.convertToAssets(\n            shares, totalDebtAssets, totalShares, Rounding.DEBT_TO_ASSETS, ISilo.AssetType.Debt\n        );\n    }\n\n    /// @notice Calculates the Loan-To-Value (LTV) ratio for a given borrower\n    /// @param _collateralConfig Configuration data related to the collateral asset\n    /// @param _debtConfig Configuration data related to the debt asset\n    /// @param _borrower Address of the borrower whose LTV is to be computed\n    /// @param _oracleType Oracle type to use for fetching the asset prices\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return ltvInDp The computed LTV ratio in 18 decimals precision\n    function getLtv(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.OracleType _oracleType,\n        ISilo.AccrueInterestInMemory _accrueInMemory,\n        uint256 _debtShareBalance\n    ) internal view returns (uint256 ltvInDp) {\n        if (_debtShareBalance == 0) return 0;\n\n        LtvData memory ltvData = getAssetsDataForLtvCalculations(\n            _collateralConfig, _debtConfig, _borrower, _oracleType, _accrueInMemory, _debtShareBalance\n        );\n\n        if (ltvData.borrowerDebtAssets == 0) return 0;\n\n        (,, ltvInDp) = calculateLtv(ltvData, _collateralConfig.token, _debtConfig.token);\n    }\n\n    /// @notice Calculates the Loan-to-Value (LTV) ratio based on provided collateral and debt data\n    /// @dev calculation never reverts, if there is revert, then it is because of oracle\n    /// @param _ltvData Data structure containing relevant information to calculate LTV\n    /// @param _collateralToken Address of the collateral token\n    /// @param _debtAsset Address of the debt token\n    /// @return sumOfBorrowerCollateralValue Total value of borrower's collateral\n    /// @return totalBorrowerDebtValue Total debt value for the borrower\n    /// @return ltvInDp Calculated LTV in 18 decimal precision\n    function calculateLtv(\n        SiloSolvencyLib.LtvData memory _ltvData, address _collateralToken, address _debtAsset)\n        internal\n        view\n        returns (uint256 sumOfBorrowerCollateralValue, uint256 totalBorrowerDebtValue, uint256 ltvInDp)\n    {\n        (\n            sumOfBorrowerCollateralValue, totalBorrowerDebtValue\n        ) = getPositionValues(_ltvData, _collateralToken, _debtAsset);\n\n        if (sumOfBorrowerCollateralValue == 0 && totalBorrowerDebtValue == 0) {\n            return (0, 0, 0);\n        } else if (sumOfBorrowerCollateralValue == 0) {\n            ltvInDp = _INFINITY;\n        } else {\n            ltvInDp = ltvMath(totalBorrowerDebtValue, sumOfBorrowerCollateralValue);\n        }\n    }\n\n    /// @notice Computes the value of collateral and debt based on given LTV data and asset addresses\n    /// @param _ltvData Data structure containing the assets data required for LTV calculations\n    /// @param _collateralAsset Address of the collateral asset\n    /// @param _debtAsset Address of the debt asset\n    /// @return sumOfCollateralValue Total value of collateral assets considering both protected and regular collateral\n    /// assets\n    /// @return debtValue Total value of debt assets\n    function getPositionValues(LtvData memory _ltvData, address _collateralAsset, address _debtAsset)\n        internal\n        view\n        returns (uint256 sumOfCollateralValue, uint256 debtValue)\n    {\n        uint256 sumOfCollateralAssets;\n        \n        sumOfCollateralAssets = _ltvData.borrowerProtectedAssets + _ltvData.borrowerCollateralAssets;\n\n        if (sumOfCollateralAssets != 0) {\n            // if no oracle is set, assume price 1, we should also not set oracle for quote token\n            sumOfCollateralValue = address(_ltvData.collateralOracle) != address(0)\n                ? _ltvData.collateralOracle.quote(sumOfCollateralAssets, _collateralAsset)\n                : sumOfCollateralAssets;\n        }\n\n        if (_ltvData.borrowerDebtAssets != 0) {\n            // if no oracle is set, assume price 1, we should also not set oracle for quote token\n            debtValue = address(_ltvData.debtOracle) != address(0)\n                ? _ltvData.debtOracle.quote(_ltvData.borrowerDebtAssets, _debtAsset)\n                : _ltvData.borrowerDebtAssets;\n        }\n    }\n\n    function ltvMath(uint256 _totalBorrowerDebtValue, uint256 _sumOfBorrowerCollateralValue)\n        internal\n        pure\n        returns (uint256 ltvInDp)\n    {\n        ltvInDp = _totalBorrowerDebtValue.mulDiv(_PRECISION_DECIMALS, _sumOfBorrowerCollateralValue, Rounding.LTV);\n    }\n}\n"
    },
    "silo-core/contracts/lib/CallBeforeQuoteLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\n\nlibrary CallBeforeQuoteLib {\n    /// @dev Call `beforeQuote` on the `solvencyOracle` oracle\n    /// @param _config Silo config data\n    function callSolvencyOracleBeforeQuote(ISiloConfig.ConfigData memory _config) internal {\n        if (_config.callBeforeQuote && _config.solvencyOracle != address(0)) {\n            ISiloOracle(_config.solvencyOracle).beforeQuote(_config.token);\n        }\n    }\n\n    /// @dev Call `beforeQuote` on the `maxLtvOracle` oracle\n    /// @param _config Silo config data\n    function callMaxLtvOracleBeforeQuote(ISiloConfig.ConfigData memory _config) internal {\n        if (_config.callBeforeQuote && _config.maxLtvOracle != address(0)) {\n            ISiloOracle(_config.maxLtvOracle).beforeQuote(_config.token);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/NonReentrantLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ICrossReentrancyGuard} from \"../interfaces/ICrossReentrancyGuard.sol\";\n\nlibrary NonReentrantLib {\n    function nonReentrant(ISiloConfig _config) internal view {\n        require(!_config.reentrancyGuardEntered(), ICrossReentrancyGuard.CrossReentrantCall());\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ISiloOracle {\n    /// @notice Hook function to call before `quote` function reads price\n    /// @dev This hook function can be used to change state right before the price is read. For example it can be used\n    ///      for curve read only reentrancy protection. In majority of implementations this will be an empty function.\n    ///      WARNING: reverts are propagated to Silo so if `beforeQuote` reverts, Silo reverts as well.\n    /// @param _baseToken Address of priced token\n    function beforeQuote(address _baseToken) external;\n\n    /// @return quoteAmount Returns quote price for _baseAmount of _baseToken\n    /// @param _baseAmount Amount of priced token\n    /// @param _baseToken Address of priced token\n    function quote(uint256 _baseAmount, address _baseToken) external view returns (uint256 quoteAmount);\n\n    /// @return address of token in which quote (price) is denominated\n    function quoteToken() external view returns (address);\n}\n"
    },
    "silo-core/contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IInterestRateModel {\n    event InterestRateModelError();\n\n    /// @dev Sets config address for all Silos that will use this model\n    /// @param _irmConfig address of IRM config contract\n    function initialize(address _irmConfig) external;\n\n    /// @dev get compound interest rate and update model storage for current block.timestamp\n    /// @param _collateralAssets total silo collateral assets\n    /// @param _debtAssets total silo debt assets\n    /// @param _interestRateTimestamp last IRM timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRateAndUpdate(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _interestRateTimestamp\n    )\n        external\n        returns (uint256 rcomp);\n\n    /// @dev get compound interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcomp);\n\n    /// @dev get current annual interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function getCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcur);\n\n    /// @dev returns decimal points used by model\n    function decimals() external view returns (uint256);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "silo-core/contracts/lib/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IsContract} from \"./IsContract.sol\";\n\nlibrary TokenHelper {\n    uint256 private constant _BYTES32_SIZE = 32;\n\n    error TokenIsNotAContract();\n\n    function assertAndGetDecimals(address _token) internal view returns (uint256) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.decimals, ()));\n\n        // decimals() is optional in the ERC20 standard, so if metadata is not accessible\n        // we assume there are no decimals and use 0.\n        if (!hasMetadata) {\n            return 0;\n        }\n\n        return abi.decode(data, (uint8));\n    }\n\n    /// @dev Returns the symbol for the provided ERC20 token.\n    /// An empty string is returned if the call to the token didn't succeed.\n    /// @param _token address of the token to get the symbol for\n    /// @return assetSymbol the token symbol\n    function symbol(address _token) internal view returns (string memory assetSymbol) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.symbol, ()));\n\n        if (!hasMetadata || data.length == 0) {\n            return \"?\";\n        } else if (data.length == _BYTES32_SIZE) {\n            return string(removeZeros(data));\n        } else {\n            return abi.decode(data, (string));\n        }\n    }\n\n    /// @dev Removes bytes with value equal to 0 from the provided byte array.\n    /// @param _data byte array from which to remove zeroes\n    /// @return result byte array with zeroes removed\n    function removeZeros(bytes memory _data) internal pure returns (bytes memory result) {\n        uint256 n = _data.length;\n\n        for (uint256 i; i < n; i++) {\n            if (_data[i] == 0) continue;\n\n            result = abi.encodePacked(result, _data[i]);\n        }\n    }\n\n    /// @dev Performs a staticcall to the token to get its metadata (symbol, decimals, name)\n    function _tokenMetadataCall(address _token, bytes memory _data) private view returns (bool, bytes memory) {\n        // We need to do this before the call, otherwise the call will succeed even for EOAs\n        require(IsContract.isContract(_token), TokenIsNotAContract());\n\n        (bool success, bytes memory result) = _token.staticcall(_data);\n\n        // If the call reverted we assume the token doesn't follow the metadata extension\n        if (!success) {\n            return (false, \"\");\n        }\n\n        return (true, result);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712Upgradeable} from \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../../utils/NoncesUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/contracts/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the ERC may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the ERC. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "silo-core/contracts/SiloConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\n\nimport {ISilo} from \"./interfaces/ISilo.sol\";\nimport {ISiloConfig} from \"./interfaces/ISiloConfig.sol\";\nimport {CrossReentrancyGuard} from \"./utils/CrossReentrancyGuard.sol\";\nimport {Hook} from \"./lib/Hook.sol\";\n\n/// @notice SiloConfig stores full configuration of Silo in immutable manner\n/// @dev Immutable contract is more expensive to deploy than minimal proxy however it provides nearly 10x cheaper\n/// data access using immutable variables.\ncontract SiloConfig is ISiloConfig, CrossReentrancyGuard {\n    using Hook for uint256;\n    \n    uint256 public immutable SILO_ID;\n\n    uint256 internal immutable _DAO_FEE;\n    uint256 internal immutable _DEPLOYER_FEE;\n    address internal immutable _HOOK_RECEIVER;\n\n    // TOKEN #0\n\n    address internal immutable _SILO0;\n\n    address internal immutable _TOKEN0;\n\n    /// @dev Token that represents a share in total protected deposits of Silo\n    address internal immutable _PROTECTED_COLLATERAL_SHARE_TOKEN0;\n    /// @dev Token that represents a share in total deposits of Silo\n    address internal immutable _COLLATERAL_SHARE_TOKEN0;\n    /// @dev Token that represents a share in total debt of Silo\n    address internal immutable _DEBT_SHARE_TOKEN0;\n\n    address internal immutable _SOLVENCY_ORACLE0;\n    address internal immutable _MAX_LTV_ORACLE0;\n\n    address internal immutable _INTEREST_RATE_MODEL0;\n\n    uint256 internal immutable _MAX_LTV0;\n    uint256 internal immutable _LT0;\n    /// @dev target LTV after liquidation\n    uint256 internal immutable _LIQUIDATION_TARGET_LTV0;\n    uint256 internal immutable _LIQUIDATION_FEE0;\n    uint256 internal immutable _FLASHLOAN_FEE0;\n\n    bool internal immutable _CALL_BEFORE_QUOTE0;\n\n    // TOKEN #1\n\n    address internal immutable _SILO1;\n\n    address internal immutable _TOKEN1;\n\n    /// @dev Token that represents a share in total protected deposits of Silo\n    address internal immutable _PROTECTED_COLLATERAL_SHARE_TOKEN1;\n    /// @dev Token that represents a share in total deposits of Silo\n    address internal immutable _COLLATERAL_SHARE_TOKEN1;\n    /// @dev Token that represents a share in total debt of Silo\n    address internal immutable _DEBT_SHARE_TOKEN1;\n\n    address internal immutable _SOLVENCY_ORACLE1;\n    address internal immutable _MAX_LTV_ORACLE1;\n\n    address internal immutable _INTEREST_RATE_MODEL1;\n\n    uint256 internal immutable _MAX_LTV1;\n    uint256 internal immutable _LT1;\n    /// @dev target LTV after liquidation\n    uint256 internal immutable _LIQUIDATION_TARGET_LTV1;\n    uint256 internal immutable _LIQUIDATION_FEE1;\n    uint256 internal immutable _FLASHLOAN_FEE1;\n\n    bool internal immutable _CALL_BEFORE_QUOTE1;\n    \n    /// @inheritdoc ISiloConfig\n    mapping (address borrower => address collateralSilo) public borrowerCollateralSilo;\n    \n    /// @param _siloId ID of this pool assigned by factory\n    /// @param _configData0 silo configuration data for token0\n    /// @param _configData1 silo configuration data for token1\n    constructor( // solhint-disable-line function-max-lines\n        uint256 _siloId,\n        ConfigData memory _configData0,\n        ConfigData memory _configData1\n    ) {\n        SILO_ID = _siloId;\n\n        // To make further computations in the Silo secure require DAO and deployer fees to be less than 100%\n        require(_configData0.daoFee + _configData0.deployerFee < 1e18, FeeTooHigh());\n\n        _DAO_FEE = _configData0.daoFee;\n        _DEPLOYER_FEE = _configData0.deployerFee;\n        _HOOK_RECEIVER = _configData0.hookReceiver;\n\n        // TOKEN #0\n\n        _SILO0 = _configData0.silo;\n        _TOKEN0 = _configData0.token;\n\n        _PROTECTED_COLLATERAL_SHARE_TOKEN0 = _configData0.protectedShareToken;\n        _COLLATERAL_SHARE_TOKEN0 = _configData0.silo;\n        _DEBT_SHARE_TOKEN0 = _configData0.debtShareToken;\n\n        _SOLVENCY_ORACLE0 = _configData0.solvencyOracle;\n        _MAX_LTV_ORACLE0 = _configData0.maxLtvOracle;\n\n        _INTEREST_RATE_MODEL0 = _configData0.interestRateModel;\n\n        _MAX_LTV0 = _configData0.maxLtv;\n        _LT0 = _configData0.lt;\n        _LIQUIDATION_TARGET_LTV0 = _configData0.liquidationTargetLtv;\n        _LIQUIDATION_FEE0 = _configData0.liquidationFee;\n        _FLASHLOAN_FEE0 = _configData0.flashloanFee;\n\n        _CALL_BEFORE_QUOTE0 = _configData0.callBeforeQuote;\n\n        // TOKEN #1\n\n        _SILO1 = _configData1.silo;\n        _TOKEN1 = _configData1.token;\n\n        _PROTECTED_COLLATERAL_SHARE_TOKEN1 = _configData1.protectedShareToken;\n        _COLLATERAL_SHARE_TOKEN1 = _configData1.silo;\n        _DEBT_SHARE_TOKEN1 = _configData1.debtShareToken;\n\n        _SOLVENCY_ORACLE1 = _configData1.solvencyOracle;\n        _MAX_LTV_ORACLE1 = _configData1.maxLtvOracle;\n\n        _INTEREST_RATE_MODEL1 = _configData1.interestRateModel;\n\n        _MAX_LTV1 = _configData1.maxLtv;\n        _LT1 = _configData1.lt;\n        _LIQUIDATION_TARGET_LTV1 = _configData1.liquidationTargetLtv;\n        _LIQUIDATION_FEE1 = _configData1.liquidationFee;\n        _FLASHLOAN_FEE1 = _configData1.flashloanFee;\n\n        _CALL_BEFORE_QUOTE1 = _configData1.callBeforeQuote;\n    }\n\n    /// @inheritdoc ISiloConfig\n    function setThisSiloAsCollateralSilo(address) external virtual returns (bool) {\n        revert Deprecated();\n    }\n\n    /// @inheritdoc ISiloConfig\n    function setOtherSiloAsCollateralSilo(address _borrower) external virtual returns (bool collateralSiloChanged) {\n        collateralSiloChanged = _setSiloAsCollateralSilo(msg.sender == _SILO0 ? _SILO1 : _SILO0, _borrower);\n    }\n\n    /// @inheritdoc ISiloConfig\n    function onDebtTransfer(address _sender, address _recipient) external virtual {\n        require(msg.sender == _DEBT_SHARE_TOKEN0 || msg.sender == _DEBT_SHARE_TOKEN1, OnlyDebtShareToken());\n\n        address thisSilo = msg.sender == _DEBT_SHARE_TOKEN0 ? _SILO0 : _SILO1;\n\n        require(!hasDebtInOtherSilo(thisSilo, _recipient), DebtExistInOtherSilo());\n\n        if (borrowerCollateralSilo[_recipient] == address(0)) {\n            borrowerCollateralSilo[_recipient] = borrowerCollateralSilo[_sender];\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function accrueInterestForSilo(address _silo) external virtual {\n        address irm;\n\n        if (_silo == _SILO0) {\n            irm = _INTEREST_RATE_MODEL0;\n        } else if (_silo == _SILO1) {\n            irm = _INTEREST_RATE_MODEL1;\n        } else {\n            revert WrongSilo();\n        }\n\n        ISilo(_silo).accrueInterestForConfig(\n            irm,\n            _DAO_FEE,\n            _DEPLOYER_FEE\n        );\n    }\n\n    /// @inheritdoc ISiloConfig\n    function accrueInterestForBothSilos() external virtual {\n        ISilo(_SILO0).accrueInterestForConfig(\n            _INTEREST_RATE_MODEL0,\n            _DAO_FEE,\n            _DEPLOYER_FEE\n        );\n\n        ISilo(_SILO1).accrueInterestForConfig(\n            _INTEREST_RATE_MODEL1,\n            _DAO_FEE,\n            _DEPLOYER_FEE\n        );\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getConfigsForSolvency(address _borrower) public view virtual returns (\n        ConfigData memory collateralConfig,\n        ConfigData memory debtConfig\n    ) {\n        address debtSilo = getDebtSilo(_borrower);\n\n        if (debtSilo == address(0)) return (collateralConfig, debtConfig);\n\n        address collateralSilo = borrowerCollateralSilo[_borrower];\n\n        collateralConfig = getConfig(collateralSilo);\n        debtConfig = getConfig(debtSilo);\n    }\n\n    /// @inheritdoc ISiloConfig\n    // solhint-disable-next-line ordering\n    function getConfigsForWithdraw(address _silo, address _depositOwner) external view virtual returns (\n        DepositConfig memory depositConfig,\n        ConfigData memory collateralConfig,\n        ConfigData memory debtConfig\n    ) {\n        depositConfig = _getDepositConfig(_silo);\n        (collateralConfig, debtConfig) = getConfigsForSolvency(_depositOwner);\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getConfigsForBorrow(address _debtSilo)\n        external\n        view\n        virtual\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig)\n    {\n        address collateralSilo; \n        \n        if (_debtSilo == _SILO0) {\n            collateralSilo = _SILO1;\n        } else if (_debtSilo == _SILO1) {\n            collateralSilo = _SILO0;\n        } else {\n            revert WrongSilo();\n        }\n\n        collateralConfig = getConfig(collateralSilo);\n        debtConfig = getConfig(_debtSilo);\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getSilos() external view virtual returns (address silo0, address silo1) {\n        return (_SILO0, _SILO1);\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getShareTokens(address _silo)\n        external\n        view\n        virtual\n        returns (address protectedShareToken, address collateralShareToken, address debtShareToken)\n    {\n        if (_silo == _SILO0) {\n            return (_PROTECTED_COLLATERAL_SHARE_TOKEN0, _COLLATERAL_SHARE_TOKEN0, _DEBT_SHARE_TOKEN0);\n        } else if (_silo == _SILO1) {\n            return (_PROTECTED_COLLATERAL_SHARE_TOKEN1, _COLLATERAL_SHARE_TOKEN1, _DEBT_SHARE_TOKEN1);\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getAssetForSilo(address _silo) external view virtual returns (address asset) {\n        if (_silo == _SILO0) {\n            return _TOKEN0;\n        } else if (_silo == _SILO1) {\n            return _TOKEN1;\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getFeesWithAsset(address _silo)\n        external\n        view\n        virtual\n        returns (uint256 daoFee, uint256 deployerFee, uint256 flashloanFee, address asset)\n    {\n        daoFee = _DAO_FEE;\n        deployerFee = _DEPLOYER_FEE;\n\n        if (_silo == _SILO0) {\n            asset = _TOKEN0;\n            flashloanFee = _FLASHLOAN_FEE0;\n        } else if (_silo == _SILO1) {\n            asset = _TOKEN1;\n            flashloanFee = _FLASHLOAN_FEE1;\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getCollateralShareTokenAndAsset(address _silo, ISilo.CollateralType _collateralType)\n        external\n        view\n        virtual\n        returns (address shareToken, address asset)\n    {\n        if (_silo == _SILO0) {\n            return _collateralType == ISilo.CollateralType.Collateral\n                ? (_COLLATERAL_SHARE_TOKEN0, _TOKEN0)\n                : (_PROTECTED_COLLATERAL_SHARE_TOKEN0, _TOKEN0);\n        } else if (_silo == _SILO1) {\n            return _collateralType == ISilo.CollateralType.Collateral\n                ? (_COLLATERAL_SHARE_TOKEN1, _TOKEN1)\n                : (_PROTECTED_COLLATERAL_SHARE_TOKEN1, _TOKEN1);\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getDebtShareTokenAndAsset(address _silo)\n        external\n        view\n        virtual\n        returns (address shareToken, address asset)\n    {\n        if (_silo == _SILO0) {\n            return (_DEBT_SHARE_TOKEN0, _TOKEN0);\n        } else if (_silo == _SILO1) {\n            return (_DEBT_SHARE_TOKEN1, _TOKEN1);\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getConfig(address _silo) public view virtual returns (ConfigData memory config) {\n        if (_silo == _SILO0) {\n            config = _silo0ConfigData();\n        } else if (_silo == _SILO1) {\n            config = _silo1ConfigData();\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function hasDebtInOtherSilo(address _thisSilo, address _borrower) public view virtual returns (bool hasDebt) {\n        if (_thisSilo == _SILO0) {\n            hasDebt = _balanceOf(_DEBT_SHARE_TOKEN1, _borrower) != 0;\n        } else if (_thisSilo == _SILO1) {\n            hasDebt = _balanceOf(_DEBT_SHARE_TOKEN0, _borrower) != 0;\n        } else {\n            revert WrongSilo();\n        }\n     }\n\n    /// @inheritdoc ISiloConfig\n    function getDebtSilo(address _borrower) public view virtual returns (address debtSilo) {\n        uint256 debtBal0 = _balanceOf(_DEBT_SHARE_TOKEN0, _borrower);\n        uint256 debtBal1 = _balanceOf(_DEBT_SHARE_TOKEN1, _borrower);\n\n        require(debtBal0 == 0 || debtBal1 == 0, DebtExistInOtherSilo());\n        if (debtBal0 == 0 && debtBal1 == 0) return address(0);\n\n        debtSilo = debtBal0 != 0 ? _SILO0 : _SILO1;\n    }\n\n    function _silo0ConfigData() internal view virtual returns (ConfigData memory config) {\n        config = ConfigData({\n            daoFee: _DAO_FEE,\n            deployerFee: _DEPLOYER_FEE,\n            silo: _SILO0,\n            token: _TOKEN0,\n            protectedShareToken: _PROTECTED_COLLATERAL_SHARE_TOKEN0,\n            collateralShareToken: _COLLATERAL_SHARE_TOKEN0,\n            debtShareToken: _DEBT_SHARE_TOKEN0,\n            solvencyOracle: _SOLVENCY_ORACLE0,\n            maxLtvOracle: _MAX_LTV_ORACLE0,\n            interestRateModel: _INTEREST_RATE_MODEL0,\n            maxLtv: _MAX_LTV0,\n            lt: _LT0,\n            liquidationTargetLtv: _LIQUIDATION_TARGET_LTV0,\n            liquidationFee: _LIQUIDATION_FEE0,\n            flashloanFee: _FLASHLOAN_FEE0,\n            hookReceiver: _HOOK_RECEIVER,\n            callBeforeQuote: _CALL_BEFORE_QUOTE0\n        });\n    }\n\n    function _silo1ConfigData() internal view virtual returns (ConfigData memory config) {\n        config = ConfigData({\n            daoFee: _DAO_FEE,\n            deployerFee: _DEPLOYER_FEE,\n            silo: _SILO1,\n            token: _TOKEN1,\n            protectedShareToken: _PROTECTED_COLLATERAL_SHARE_TOKEN1,\n            collateralShareToken: _COLLATERAL_SHARE_TOKEN1,\n            debtShareToken: _DEBT_SHARE_TOKEN1,\n            solvencyOracle: _SOLVENCY_ORACLE1,\n            maxLtvOracle: _MAX_LTV_ORACLE1,\n            interestRateModel: _INTEREST_RATE_MODEL1,\n            maxLtv: _MAX_LTV1,\n            lt: _LT1,\n            liquidationTargetLtv: _LIQUIDATION_TARGET_LTV1,\n            liquidationFee: _LIQUIDATION_FEE1,\n            flashloanFee: _FLASHLOAN_FEE1,\n            hookReceiver: _HOOK_RECEIVER,\n            callBeforeQuote: _CALL_BEFORE_QUOTE1\n        });\n    }\n\n    function _getDepositConfig(address _silo) internal view virtual returns (DepositConfig memory config) {\n        if (_silo == _SILO0) {\n            config = DepositConfig({\n                silo: _SILO0,\n                token: _TOKEN0,\n                collateralShareToken: _COLLATERAL_SHARE_TOKEN0,\n                protectedShareToken: _PROTECTED_COLLATERAL_SHARE_TOKEN0,\n                daoFee: _DAO_FEE,\n                deployerFee: _DEPLOYER_FEE,\n                interestRateModel: _INTEREST_RATE_MODEL0\n            });\n        } else if (_silo == _SILO1) {\n            config = DepositConfig({\n                silo: _SILO1,\n                token: _TOKEN1,\n                collateralShareToken: _COLLATERAL_SHARE_TOKEN1,\n                protectedShareToken: _PROTECTED_COLLATERAL_SHARE_TOKEN1,\n                daoFee: _DAO_FEE,\n                deployerFee: _DEPLOYER_FEE,\n                interestRateModel: _INTEREST_RATE_MODEL1\n            });\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    function _onlySiloOrTokenOrHookReceiver() internal view virtual override {\n        if (msg.sender != _SILO0 &&\n            msg.sender != _SILO1 &&\n            msg.sender != _HOOK_RECEIVER &&\n            msg.sender != _COLLATERAL_SHARE_TOKEN0 &&\n            msg.sender != _COLLATERAL_SHARE_TOKEN1 &&\n            msg.sender != _PROTECTED_COLLATERAL_SHARE_TOKEN0 &&\n            msg.sender != _PROTECTED_COLLATERAL_SHARE_TOKEN1 &&\n            msg.sender != _DEBT_SHARE_TOKEN0 &&\n            msg.sender != _DEBT_SHARE_TOKEN1\n        ) {\n            revert OnlySiloOrTokenOrHookReceiver();\n        }\n    }\n\n    function _onlySilo() internal view virtual {\n        require(msg.sender == _SILO0 || msg.sender == _SILO1, OnlySilo());\n    }\n\n    function _balanceOf(address _token, address _user) internal view virtual returns (uint256 balance) {\n        balance = IERC20(_token).balanceOf(_user);\n    }\n\n    function _setSiloAsCollateralSilo(address _newCollateralSilo, address _borrower)\n        internal\n        virtual\n        returns (bool collateralSiloChanged)\n    {\n        _onlySilo();\n\n        if (borrowerCollateralSilo[_borrower] != _newCollateralSilo) {\n            borrowerCollateralSilo[_borrower] = _newCollateralSilo;\n            collateralSiloChanged = true;\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/IInterestRateModelV2Config.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IInterestRateModelV2} from \"./IInterestRateModelV2.sol\";\n\ninterface IInterestRateModelV2Config {\n    /// @return config returns immutable IRM configuration that is present in contract\n    function getConfig() external view returns (IInterestRateModelV2.Config memory config);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/IsContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nlibrary IsContract {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address _account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return _account.code.length > 0;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/contracts/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/contracts/utils/NoncesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "silo-core/contracts/utils/CrossReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {ICrossReentrancyGuard} from \"../interfaces/ICrossReentrancyGuard.sol\";\n\nabstract contract CrossReentrancyGuard is ICrossReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 0;\n    uint256 private constant _ENTERED = 1;\n\n    uint256 private transient _crossReentrantStatus;\n\n    /// @inheritdoc ICrossReentrancyGuard\n    function turnOnReentrancyProtection() external virtual {\n        _onlySiloOrTokenOrHookReceiver();\n        \n        require(_crossReentrantStatus != _ENTERED, CrossReentrantCall());\n\n        _crossReentrantStatus = _ENTERED;\n    }\n\n    /// @inheritdoc ICrossReentrancyGuard\n    function turnOffReentrancyProtection() external virtual {\n        _onlySiloOrTokenOrHookReceiver();\n        \n        // Leaving it unprotected may lead to a bug in the reentrancy protection system,\n        // as it can be used in the function without activating the protection before deactivating it.\n        // Later on, these functions may be called to turn off the reentrancy protection.\n        // To avoid this, we check if the protection is active before deactivating it.\n        require(_crossReentrantStatus != _NOT_ENTERED, CrossReentrancyNotActive());\n\n        _crossReentrantStatus = _NOT_ENTERED;\n    }\n\n    /// @inheritdoc ICrossReentrancyGuard\n    function reentrancyGuardEntered() external view virtual returns (bool entered) {\n        entered = _crossReentrantStatus == _ENTERED;\n    }\n\n    function _onlySiloOrTokenOrHookReceiver() internal virtual {}\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=gitmodules/forge-std/src/",
      "silo-foundry-utils/=gitmodules/silo-foundry-utils/contracts/",
      "properties/=gitmodules/crytic/properties/contracts/",
      "silo-core/=silo-core/",
      "silo-oracles/=silo-oracles/",
      "silo-vaults/=silo-vaults/",
      "@openzeppelin/=gitmodules/openzeppelin-contracts-5/",
      "morpho-blue/=gitmodules/morpho-blue/src/",
      "openzeppelin5/=gitmodules/openzeppelin-contracts-5/contracts/",
      "openzeppelin5-upgradeable/=gitmodules/openzeppelin-contracts-upgradeable-5/contracts/",
      "chainlink/=gitmodules/chainlink/contracts/src/",
      "chainlink-ccip/=gitmodules/chainlink-ccip/contracts/src/",
      "uniswap/=gitmodules/uniswap/",
      "@uniswap/v3-core/=gitmodules/uniswap/v3-core/",
      "pyth-sdk-solidity/=gitmodules/pyth-sdk-solidity/target_chains/ethereum/sdk/solidity/",
      "a16z-erc4626-tests/=gitmodules/a16z-erc4626-tests/",
      "@ensdomains/=node_modules/@ensdomains/",
      "@solidity-parser/=node_modules/prettier-plugin-solidity/node_modules/@solidity-parser/",
      "ERC4626/=gitmodules/crytic/properties/lib/ERC4626/contracts/",
      "createx/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/src/",
      "crytic/=gitmodules/crytic/",
      "ds-test/=gitmodules/openzeppelin-contracts-5/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=gitmodules/openzeppelin-contracts-5/lib/erc4626-tests/",
      "halmos-cheatcodes/=gitmodules/morpho-blue/lib/halmos-cheatcodes/src/",
      "hardhat/=node_modules/hardhat/",
      "openzeppelin-contracts-5/=gitmodules/openzeppelin-contracts-5/",
      "openzeppelin-contracts-upgradeable-5/=gitmodules/openzeppelin-contracts-upgradeable-5/",
      "openzeppelin-contracts-upgradeable/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/",
      "prettier-plugin-solidity/=node_modules/prettier-plugin-solidity/",
      "solady/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/lib/solady/",
      "solmate/=gitmodules/crytic/properties/lib/solmate/src/",
      "x-silo/=node_modules/x-silo/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {
      "silo-core/contracts/Silo.sol": {
        "Actions": "0x3f6bf00619ece8d739e453f5fb43c4cb58e82b24",
        "ShareCollateralTokenLib": "0xda0090733bd62d803f9edf80f5cfcfdb827f651a",
        "ShareTokenLib": "0xf2086544cebe5b670d0250574f0cec875aa42646",
        "SiloLendingLib": "0xc2bd89c110f8c32288a828d7a695e3d1c8628418",
        "Views": "0xef9b1386bc4f76a7700541e48727956643443d1c"
      }
    }
  }
}