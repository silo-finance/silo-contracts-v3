{
  "language": "Solidity",
  "sources": {
    "silo-core/contracts/SiloDeployer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Clones} from \"openzeppelin5/proxy/Clones.sol\";\n\nimport {ISiloConfig} from \"silo-core/contracts/interfaces/ISiloConfig.sol\";\nimport {ISiloFactory} from \"silo-core/contracts/interfaces/ISiloFactory.sol\";\nimport {IInterestRateModelV2} from \"silo-core/contracts/interfaces/IInterestRateModelV2.sol\";\nimport {IInterestRateModelV2Factory} from \"silo-core/contracts/interfaces/IInterestRateModelV2Factory.sol\";\nimport {IDynamicKinkModelFactory} from \"silo-core/contracts/interfaces/IDynamicKinkModelFactory.sol\";\nimport {IInterestRateModel} from \"silo-core/contracts/interfaces/IInterestRateModel.sol\";\nimport {IHookReceiver} from \"silo-core/contracts/interfaces/IHookReceiver.sol\";\nimport {ISiloDeployer} from \"silo-core/contracts/interfaces/ISiloDeployer.sol\";\nimport {SiloConfig} from \"silo-core/contracts/SiloConfig.sol\";\nimport {CloneDeterministic} from \"silo-core/contracts/lib/CloneDeterministic.sol\";\nimport {Views} from \"silo-core/contracts/lib/Views.sol\";\nimport {Create2Factory} from \"common/utils/Create2Factory.sol\";\n\n/// @notice Silo Deployer\ncontract SiloDeployer is Create2Factory, ISiloDeployer {\n    // solhint-disable var-name-mixedcase\n    IInterestRateModelV2Factory public immutable IRM_CONFIG_FACTORY;\n    IDynamicKinkModelFactory public immutable DYNAMIC_KINK_MODEL_FACTORY;\n    ISiloFactory public immutable SILO_FACTORY;\n    address public immutable SILO_IMPL;\n    address public immutable SHARE_PROTECTED_COLLATERAL_TOKEN_IMPL;\n    address public immutable SHARE_DEBT_TOKEN_IMPL;\n    // solhint-enable var-name-mixedcase\n\n    constructor(\n        IInterestRateModelV2Factory _irmConfigFactory,\n        IDynamicKinkModelFactory _dynamicKinkModelFactory,\n        ISiloFactory _siloFactory,\n        address _siloImpl,\n        address _shareProtectedCollateralTokenImpl,\n        address _shareDebtTokenImpl\n    ) {\n        IRM_CONFIG_FACTORY = _irmConfigFactory;\n        DYNAMIC_KINK_MODEL_FACTORY = _dynamicKinkModelFactory;\n        SILO_FACTORY = _siloFactory;\n        SILO_IMPL = _siloImpl;\n        SHARE_PROTECTED_COLLATERAL_TOKEN_IMPL = _shareProtectedCollateralTokenImpl;\n        SHARE_DEBT_TOKEN_IMPL = _shareDebtTokenImpl;\n    }\n\n    /// @inheritdoc ISiloDeployer\n    function deploy(\n        Oracles calldata _oracles,\n        bytes calldata _irmConfigData0,\n        bytes calldata _irmConfigData1,\n        ClonableHookReceiver calldata _clonableHookReceiver,\n        ISiloConfig.InitData memory _siloInitData\n    )\n        external\n        returns (ISiloConfig siloConfig)\n    {\n        // setUp IRMs (create if needed) and update `_siloInitData`\n        _setUpIRMs(_irmConfigData0, _irmConfigData1, _siloInitData);\n        // create oracles and update `_siloInitData`\n        _createOracles(_siloInitData, _oracles);\n        // clone hook receiver if needed\n        _cloneHookReceiver(_siloInitData, _clonableHookReceiver.implementation);\n        // deploy `SiloConfig` (with predicted addresses)\n        siloConfig = _deploySiloConfig(_siloInitData);\n        // create silo\n        SILO_FACTORY.createSilo({\n            _siloConfig: siloConfig,\n            _siloImpl: SILO_IMPL,\n            _shareProtectedCollateralTokenImpl: SHARE_PROTECTED_COLLATERAL_TOKEN_IMPL,\n            _shareDebtTokenImpl: SHARE_DEBT_TOKEN_IMPL,\n            _deployer: _siloInitData.deployer,\n            _creator: msg.sender\n        });\n        // initialize hook receiver only if it was cloned\n        _initializeHookReceiver(_siloInitData, siloConfig, _clonableHookReceiver);\n\n        emit SiloCreated(siloConfig);\n    }\n\n    /// @notice Deploy `SiloConfig` with predicted addresses\n    /// @param _siloInitData Silo configuration for the silo creation\n    /// @return siloConfig Deployed `SiloConfig`\n    // solhint-disable-next-line function-max-lines\n    function _deploySiloConfig(ISiloConfig.InitData memory _siloInitData) internal returns (ISiloConfig siloConfig) {\n        uint256 creatorSiloCounter = SILO_FACTORY.creatorSiloCounter(msg.sender);\n\n        ISiloConfig.ConfigData memory configData0;\n        ISiloConfig.ConfigData memory configData1;\n\n        (configData0, configData1) = Views.copySiloConfig(\n            _siloInitData,\n            SILO_FACTORY.daoFeeRange(),\n            SILO_FACTORY.maxDeployerFee(),\n            SILO_FACTORY.maxFlashloanFee(),\n            SILO_FACTORY.maxLiquidationFee()\n        );\n\n        configData0.silo = CloneDeterministic.predictSilo0Addr(\n            SILO_IMPL,\n            creatorSiloCounter,\n            address(SILO_FACTORY),\n            msg.sender\n        );\n\n        configData1.silo = CloneDeterministic.predictSilo1Addr(\n            SILO_IMPL,\n            creatorSiloCounter,\n            address(SILO_FACTORY),\n            msg.sender\n        );\n\n        configData0.collateralShareToken = configData0.silo;\n        configData1.collateralShareToken = configData1.silo;\n\n        configData0.protectedShareToken = CloneDeterministic.predictShareProtectedCollateralToken0Addr(\n            SHARE_PROTECTED_COLLATERAL_TOKEN_IMPL,\n            creatorSiloCounter,\n            address(SILO_FACTORY),\n            msg.sender\n        );\n\n        configData1.protectedShareToken = CloneDeterministic.predictShareProtectedCollateralToken1Addr(\n            SHARE_PROTECTED_COLLATERAL_TOKEN_IMPL,\n            creatorSiloCounter,\n            address(SILO_FACTORY),\n            msg.sender\n        );\n\n        configData0.debtShareToken = CloneDeterministic.predictShareDebtToken0Addr(\n            SHARE_DEBT_TOKEN_IMPL,\n            creatorSiloCounter,\n            address(SILO_FACTORY),\n            msg.sender\n        );\n\n        configData1.debtShareToken = CloneDeterministic.predictShareDebtToken1Addr(\n            SHARE_DEBT_TOKEN_IMPL,\n            creatorSiloCounter,\n            address(SILO_FACTORY),\n            msg.sender\n        );\n\n        uint256 nextSiloId = SILO_FACTORY.getNextSiloId();\n\n        siloConfig = ISiloConfig(address(new SiloConfig{salt: _salt()}(nextSiloId, configData0, configData1)));\n    }\n\n    /// @notice Create IRMs and update `_siloInitData`\n    /// @param _irmConfigData0 IRM config data for a silo `_TOKEN0`\n    /// @param _irmConfigData1 IRM config data for a silo `_TOKEN1`\n    /// @param _siloInitData Silo configuration for the silo creation\n    function _setUpIRMs(\n        bytes calldata _irmConfigData0,\n        bytes calldata _irmConfigData1,\n        ISiloConfig.InitData memory _siloInitData\n    ) internal {\n        bytes32 salt = _salt();\n\n        if (_siloInitData.interestRateModel0 == address(IRM_CONFIG_FACTORY)) {\n            _siloInitData.interestRateModel0 = _createInterestRateModel(_irmConfigData0, salt);\n        }\n\n        if (_siloInitData.interestRateModel1 == address(IRM_CONFIG_FACTORY)) {\n            _siloInitData.interestRateModel1 = _createInterestRateModel(_irmConfigData1, salt);\n        }\n\n        uint256 creatorSiloCounter = SILO_FACTORY.creatorSiloCounter(msg.sender);\n\n        if (_siloInitData.interestRateModel0 == address(DYNAMIC_KINK_MODEL_FACTORY)) {\n            address silo = CloneDeterministic.predictSilo0Addr(\n                SILO_IMPL,\n                creatorSiloCounter,\n                address(SILO_FACTORY),\n                msg.sender\n            );\n\n            _siloInitData.interestRateModel0 = _createDKinkIRM(_irmConfigData0, silo, salt);\n        }\n\n        if (_siloInitData.interestRateModel1 == address(DYNAMIC_KINK_MODEL_FACTORY)) {\n            address silo = CloneDeterministic.predictSilo1Addr(\n                SILO_IMPL,\n                creatorSiloCounter,\n                address(SILO_FACTORY),\n                msg.sender\n            );\n\n            _siloInitData.interestRateModel1 = _createDKinkIRM(_irmConfigData1, silo, salt);\n        }\n    }\n\n    /// @notice Create an interest rate model\n    /// @param _irmConfigData IRM config data\n    /// @return interestRateModel Deployed interest rate model\n    function _createInterestRateModel(bytes memory _irmConfigData, bytes32 _salt) internal returns (address) {\n        IInterestRateModelV2.Config memory config = abi.decode(_irmConfigData, (IInterestRateModelV2.Config));\n        (, IInterestRateModelV2 interestRateModel) = IRM_CONFIG_FACTORY.create(config, _salt);\n\n        return address(interestRateModel);\n    }\n\n    /// @notice Create a DKinkIRM\n    /// @param _irmConfigData DKinkIRM config data\n    /// @param _silo Silo address\n    /// @return interestRateModel Deployed DKinkIRM\n    function _createDKinkIRM(bytes memory _irmConfigData, address _silo, bytes32 _salt) internal returns (address) {\n        DKinkIRMConfig memory dkink = abi.decode(_irmConfigData, (DKinkIRMConfig));\n\n        IInterestRateModel interestRateModel = DYNAMIC_KINK_MODEL_FACTORY.create(\n            dkink.config,\n            dkink.immutableArgs,\n            dkink.initialOwner,\n            _silo,\n            _salt\n        );\n\n        return address(interestRateModel);\n    }\n\n    /// @notice Create an oracle if it is not specified in the `_siloInitData` and has tx details for the creation\n    /// @param _siloInitData Silo configuration for the silo creation\n    /// @param _oracles Oracles creation details (factory and creation tx input)\n    function _createOracles(ISiloConfig.InitData memory _siloInitData, Oracles memory _oracles) internal {\n        if (_siloInitData.solvencyOracle0 == address(0)) {\n            _siloInitData.solvencyOracle0 = _createOracle(_oracles.solvencyOracle0);\n        }\n\n        if (_siloInitData.maxLtvOracle0 == address(0)) {\n            _siloInitData.maxLtvOracle0 = _createOracle(_oracles.maxLtvOracle0);\n        }\n\n        if (_siloInitData.solvencyOracle1 == address(0)) {\n            _siloInitData.solvencyOracle1 = _createOracle(_oracles.solvencyOracle1);\n        }\n\n        if (_siloInitData.maxLtvOracle1 == address(0)) {\n            _siloInitData.maxLtvOracle1 = _createOracle(_oracles.maxLtvOracle1);\n        }\n    }\n\n    /// @notice Create an oracle\n    /// @param _txData Oracle creation details (factory and creation tx input)\n    function _createOracle(OracleCreationTxData memory _txData) internal returns (address _oracle) {\n        if (_txData.deployed != address(0)) return _txData.deployed;\n\n        address factory = _txData.factory;\n\n        if (factory == address(0)) return address(0);\n\n        _updateSalt(_txData.txInput);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = factory.call(_txData.txInput);\n\n        require(success && data.length == 32, FailedToCreateAnOracle(factory));\n\n        // Safe: `data` length is exactly 32 bytes and encodes an EVM address in the low 20 bytes.\n        // forge-lint: disable-next-line(unsafe-typecast)\n        _oracle = address(uint160(uint256(bytes32(data))));\n    }\n\n    /// @notice Clone hook receiver if it is provided\n    /// @param _siloInitData Silo configuration for the silo creation\n    /// @param _hookReceiverImplementation Hook receiver implementation to clone\n    function _cloneHookReceiver(\n        ISiloConfig.InitData memory _siloInitData,\n        address _hookReceiverImplementation\n    ) internal {\n        require(\n            _hookReceiverImplementation == address(0) || _siloInitData.hookReceiver == address(0),\n            HookReceiverMisconfigured()\n        );\n\n        if (_hookReceiverImplementation != address(0)) {\n            _siloInitData.hookReceiver = Clones.cloneDeterministic(_hookReceiverImplementation, _salt());\n        }\n    }\n\n    /// @notice Initialize hook receiver if it was cloned\n    /// @param _siloInitData Silo configuration for the silo creation\n    /// (where _siloInitData.hookReceiver is the cloned hook receiver)\n    /// @param _siloConfig Configuration of the created silo\n    /// @param _clonableHookReceiver Hook receiver implementation and initialization data\n    function _initializeHookReceiver(\n        ISiloConfig.InitData memory _siloInitData,\n        ISiloConfig _siloConfig,\n        ClonableHookReceiver calldata _clonableHookReceiver\n    ) internal {\n        if (_clonableHookReceiver.implementation != address(0)) {\n            IHookReceiver(_siloInitData.hookReceiver).initialize(\n                _siloConfig,\n                _clonableHookReceiver.initializationData\n            );\n        }\n    }\n\n    /// @notice Update the salt of the tx input\n    /// @param _txInput The tx input for the oracle factory\n    function _updateSalt(bytes memory _txInput) internal {\n        bytes32 salt = _salt();\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := add(add(_txInput, 0x20), sub(mload(_txInput), 0x20))\n            mstore(pointer, salt)\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISilo} from \"./ISilo.sol\";\nimport {ICrossReentrancyGuard} from \"./ICrossReentrancyGuard.sol\";\n\ninterface ISiloConfig is ICrossReentrancyGuard {\n    struct InitData {\n        /// @notice Can be address zero if deployer fees are not to be collected. If deployer address is zero then\n        /// deployer fee must be zero as well. Deployer will be minted an NFT that gives the right to claim deployer\n        /// fees. NFT can be transferred with the right to claim.\n        address deployer;\n\n        /// @notice Address of the hook receiver called on every before/after action on Silo. Hook contract also\n        /// implements liquidation logic and veSilo gauge connection.\n        address hookReceiver;\n\n        /// @notice Deployer's fee in 18 decimals points. Deployer will earn this fee based on the interest earned\n        /// by the Silo. Max deployer fee is set by the DAO. At deployment it is 15%.\n        uint256 deployerFee;\n\n        /// @notice DAO's fee in 18 decimals points. DAO will earn this fee based on the interest earned\n        /// by the Silo. Acceptable fee range fee is set by the DAO. Default at deployment is 5% - 50%.\n        uint256 daoFee;\n\n        /// @notice Address of the first token\n        address token0;\n\n        /// @notice Address of the solvency oracle. Solvency oracle is used to calculate LTV when deciding if borrower\n        /// is solvent or should be liquidated. Solvency oracle is optional and if not set price of 1 will be assumed.\n        address solvencyOracle0;\n\n        /// @notice Address of the maxLtv oracle. Max LTV oracle is used to calculate LTV when deciding if borrower\n        /// can borrow given amount of assets. Max LTV oracle is optional and if not set it defaults to solvency\n        /// oracle. If neither is set price of 1 will be assumed.\n        address maxLtvOracle0;\n\n        /// @notice Address of the interest rate model\n        address interestRateModel0;\n\n        /// @notice Maximum LTV for first token. maxLTV is in 18 decimals points and is used to determine, if borrower\n        /// can borrow given amount of assets. MaxLtv is in 18 decimals points. MaxLtv must be lower or equal to LT.\n        uint256 maxLtv0;\n\n        /// @notice Liquidation threshold for first token. LT is used to calculate solvency. LT is in 18 decimals\n        /// points. LT must not be lower than maxLTV.\n        uint256 lt0;\n\n        /// @notice minimal acceptable LTV after liquidation, in 18 decimals points\n        uint256 liquidationTargetLtv0;\n\n        /// @notice Liquidation fee for the first token in 18 decimals points. Liquidation fee is what liquidator earns\n        /// for repaying insolvent loan.\n        uint256 liquidationFee0;\n\n        /// @notice Flashloan fee sets the cost of taking a flashloan in 18 decimals points\n        uint256 flashloanFee0;\n\n        /// @notice Indicates if a beforeQuote on oracle contract should be called before quoting price\n        bool callBeforeQuote0;\n\n        /// @notice Address of the second token\n        address token1;\n\n        /// @notice Address of the solvency oracle. Solvency oracle is used to calculate LTV when deciding if borrower\n        /// is solvent or should be liquidated. Solvency oracle is optional and if not set price of 1 will be assumed.\n        address solvencyOracle1;\n\n        /// @notice Address of the maxLtv oracle. Max LTV oracle is used to calculate LTV when deciding if borrower\n        /// can borrow given amount of assets. Max LTV oracle is optional and if not set it defaults to solvency\n        /// oracle. If neither is set price of 1 will be assumed.\n        address maxLtvOracle1;\n\n        /// @notice Address of the interest rate model\n        address interestRateModel1;\n\n        /// @notice Maximum LTV for first token. maxLTV is in 18 decimals points and is used to determine,\n        /// if borrower can borrow given amount of assets. maxLtv is in 18 decimals points\n        uint256 maxLtv1;\n\n        /// @notice Liquidation threshold for first token. LT is used to calculate solvency. LT is in 18 decimals points\n        uint256 lt1;\n\n        /// @notice minimal acceptable LTV after liquidation, in 18 decimals points\n        uint256 liquidationTargetLtv1;\n\n        /// @notice Liquidation fee is what liquidator earns for repaying insolvent loan.\n        uint256 liquidationFee1;\n\n        /// @notice Flashloan fee sets the cost of taking a flashloan in 18 decimals points\n        uint256 flashloanFee1;\n\n        /// @notice Indicates if a beforeQuote on oracle contract should be called before quoting price\n        bool callBeforeQuote1;\n    }\n\n    struct ConfigData {\n        uint256 daoFee;\n        uint256 deployerFee;\n        address silo;\n        address token;\n        address protectedShareToken;\n        address collateralShareToken;\n        address debtShareToken;\n        address solvencyOracle;\n        address maxLtvOracle;\n        address interestRateModel;\n        uint256 maxLtv;\n        uint256 lt;\n        uint256 liquidationTargetLtv;\n        uint256 liquidationFee;\n        uint256 flashloanFee;\n        address hookReceiver;\n        bool callBeforeQuote;\n    }\n\n    struct DepositConfig {\n        address silo;\n        address token;\n        address collateralShareToken;\n        address protectedShareToken;\n        uint256 daoFee;\n        uint256 deployerFee;\n        address interestRateModel;\n    }\n\n    error OnlySilo();\n    error OnlySiloOrTokenOrHookReceiver();\n    error WrongSilo();\n    error OnlyDebtShareToken();\n    error DebtExistInOtherSilo();\n    error FeeTooHigh();\n    error Deprecated();\n\n    /// @dev It should be called on debt transfer (debt share token transfer).\n    /// In the case if the`_recipient` doesn't have configured a collateral silo,\n    /// it will be set to the collateral silo of the `_sender`.\n    /// @param _sender sender address\n    /// @param _recipient recipient address\n    function onDebtTransfer(address _sender, address _recipient) external;\n\n    /// @notice deprecated\n    function setThisSiloAsCollateralSilo(address _borrower) external returns (bool collateralSiloChanged);\n\n    /// @notice Set collateral silo\n    /// @dev Revert if msg.sender is not a SILO_0 or SILO_1.\n    /// @dev Always set collateral silo opposite to the msg.sender.\n    /// @param _borrower borrower address\n    /// @return collateralSiloChanged TRUE if collateral silo changed\n    function setOtherSiloAsCollateralSilo(address _borrower) external returns (bool collateralSiloChanged);\n\n    /// @notice Accrue interest for the silo\n    /// @param _silo silo for which accrue interest\n    function accrueInterestForSilo(address _silo) external;\n\n    /// @notice Accrue interest for both silos (SILO_0 and SILO_1 in a config)\n    function accrueInterestForBothSilos() external;\n\n    /// @notice Retrieves the collateral silo for a specific borrower.\n    /// @dev As a user can deposit into `Silo0` and `Silo1`, this property specifies which Silo\n    /// will be used as collateral for the debt. Later on, it will be used for max LTV and solvency checks.\n    /// After being set, the collateral silo is never set to `address(0)` again but such getters as\n    /// `getConfigsForSolvency`, `getConfigsForBorrow`, `getConfigsForWithdraw` will return empty\n    /// collateral silo config if borrower doesn't have debt.\n    ///\n    /// In the SiloConfig collateral silo is set by the following functions:\n    /// `onDebtTransfer` - only if the recipient doesn't have collateral silo set (inherits it from the sender)\n    /// This function is called on debt share token transfer (debt transfer).\n    /// `setOtherSiloAsCollateralSilo` - sets the opposite silo as collateral from the one that calls the function.\n    ///\n    /// In the Silo collateral silo is set by the following functions:\n    /// `borrow` - always sets opposite silo as collateral.\n    /// If Silo0 borrows, then Silo1 will be collateral and vice versa.\n    /// @param _borrower The address of the borrower for which the collateral silo is being retrieved\n    /// @return collateralSilo The address of the collateral silo for the specified borrower\n    function borrowerCollateralSilo(address _borrower) external view returns (address collateralSilo);\n\n    /// @notice Retrieves the silo ID\n    /// @dev Each silo is assigned a unique ID. ERC-721 token is minted with identical ID to deployer.\n    /// An owner of that token receives the deployer fees.\n    /// @return siloId The ID of the silo\n    function SILO_ID() external view returns (uint256 siloId); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Retrieves the addresses of the two silos\n    /// @return silo0 The address of the first silo\n    /// @return silo1 The address of the second silo\n    function getSilos() external view returns (address silo0, address silo1);\n\n    /// @notice Retrieves the asset associated with a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which the associated asset is being retrieved\n    /// @return asset The address of the asset associated with the specified silo\n    function getAssetForSilo(address _silo) external view returns (address asset);\n\n    /// @notice Verifies if the borrower has debt in other silo by checking the debt share token balance\n    /// @param _thisSilo The address of the silo in respect of which the debt is checked\n    /// @param _borrower The address of the borrower for which the debt is checked\n    /// @return hasDebt true if the borrower has debt in other silo\n    function hasDebtInOtherSilo(address _thisSilo, address _borrower) external view returns (bool hasDebt);\n\n    /// @notice Retrieves the debt silo associated with a specific borrower\n    /// @dev This function reverts if debt present in two silo (should not happen)\n    /// @param _borrower The address of the borrower for which the debt silo is being retrieved\n    function getDebtSilo(address _borrower) external view returns (address debtSilo);\n\n    /// @notice Retrieves configuration data for both silos. First config is for the silo that is asking for configs.\n    /// @param borrower borrower address for which debtConfig will be returned\n    /// @return collateralConfig The configuration data for collateral silo (empty if there is no debt).\n    /// @return debtConfig The configuration data for debt silo (empty if there is no debt).\n    function getConfigsForSolvency(address borrower)\n        external\n        view\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig);\n\n    /// @notice Retrieves configuration data for a specific silo\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _silo The address of the silo for which configuration data is being retrieved\n    /// @return config The configuration data for the specified silo\n    function getConfig(address _silo) external view returns (ConfigData memory config);\n\n    /// @notice Retrieves configuration data for a specific silo for withdraw fn.\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _silo The address of the silo for which configuration data is being retrieved\n    /// @return depositConfig The configuration data for the specified silo (always config for `_silo`)\n    /// @return collateralConfig The configuration data for the collateral silo (empty if there is no debt)\n    /// @return debtConfig The configuration data for the debt silo (empty if there is no debt)\n    function getConfigsForWithdraw(address _silo, address _borrower) external view returns (\n        DepositConfig memory depositConfig,\n        ConfigData memory collateralConfig,\n        ConfigData memory debtConfig\n    );\n\n    /// @notice Retrieves configuration data for a specific silo for borrow fn.\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _debtSilo The address of the silo for which configuration data is being retrieved\n    /// @return collateralConfig The configuration data for the collateral silo (always other than `_debtSilo`)\n    /// @return debtConfig The configuration data for the debt silo (always config for `_debtSilo`)\n    function getConfigsForBorrow(address _debtSilo)\n        external\n        view\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig);\n\n    /// @notice Retrieves fee-related information for a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which fee-related information is being retrieved.\n    /// @return daoFee The DAO fee percentage in 18 decimals points.\n    /// @return deployerFee The deployer fee percentage in 18 decimals points.\n    /// @return flashloanFee The flashloan fee percentage in 18 decimals points.\n    /// @return asset The address of the asset associated with the specified silo.\n    function getFeesWithAsset(address _silo)\n        external\n        view\n        returns (uint256 daoFee, uint256 deployerFee, uint256 flashloanFee, address asset);\n\n    /// @notice Retrieves share tokens associated with a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which share tokens are being retrieved\n    /// @return protectedShareToken The address of the protected (non-borrowable) share token\n    /// @return collateralShareToken The address of the collateral share token\n    /// @return debtShareToken The address of the debt share token\n    function getShareTokens(address _silo)\n        external\n        view\n        returns (address protectedShareToken, address collateralShareToken, address debtShareToken);\n\n    /// @notice Retrieves the share token and the silo token associated with a specific silo\n    /// @param _silo The address of the silo for which the share token and silo token are being retrieved\n    /// @param _collateralType The type of collateral\n    /// @return shareToken The address of the share token (collateral or protected collateral)\n    /// @return asset The address of the silo token\n    function getCollateralShareTokenAndAsset(address _silo, ISilo.CollateralType _collateralType)\n        external\n        view\n        returns (address shareToken, address asset);\n\n    /// @notice Retrieves the share token and the silo token associated with a specific silo\n    /// @param _silo The address of the silo for which the share token and silo token are being retrieved\n    /// @return shareToken The address of the share token (debt)\n    /// @return asset The address of the silo token\n    function getDebtShareTokenAndAsset(address _silo)\n        external\n        view\n        returns (address shareToken, address asset);\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC721} from \"openzeppelin5/interfaces/IERC721.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\ninterface ISiloFactory is IERC721 {\n    struct Range {\n        uint128 min;\n        uint128 max;\n    }\n\n    /// @notice Emitted on the creation of a Silo.\n    /// @param implementation Address of the Silo implementation.\n    /// @param token0 Address of the first Silo token.\n    /// @param token1 Address of the second Silo token.\n    /// @param silo0 Address of the first Silo.\n    /// @param silo1 Address of the second Silo.\n    /// @param siloConfig Address of the SiloConfig.\n    event NewSilo(\n        address indexed implementation,\n        address indexed token0,\n        address indexed token1,\n        address silo0,\n        address silo1,\n        address siloConfig\n    );\n\n    /// @notice Emitted on the creation of a Silo, note that collateral share token == silo\n    event NewSiloShareTokens(\n        address indexed protectedShareToken, \n        address indexed collateralShareToken,\n        address indexed debtShareToken\n    );\n\n    event NewSiloHook(address indexed silo, address indexed hook);\n\n    event BaseURI(string newBaseURI);\n\n    /// @notice Emitted on the update of DAO fee.\n    /// @param minDaoFee Value of the new minimal DAO fee.\n    /// @param maxDaoFee Value of the new maximal DAO fee.\n    event DaoFeeChanged(uint128 minDaoFee, uint128 maxDaoFee);\n\n    /// @notice Emitted on the update of max deployer fee.\n    /// @param maxDeployerFee Value of the new max deployer fee.\n    event MaxDeployerFeeChanged(uint256 maxDeployerFee);\n\n    /// @notice Emitted on the update of max flashloan fee.\n    /// @param maxFlashloanFee Value of the new max flashloan fee.\n    event MaxFlashloanFeeChanged(uint256 maxFlashloanFee);\n\n    /// @notice Emitted on the update of max liquidation fee.\n    /// @param maxLiquidationFee Value of the new max liquidation fee.\n    event MaxLiquidationFeeChanged(uint256 maxLiquidationFee);\n\n    /// @notice Emitted on the change of DAO fee receiver.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChanged(address daoFeeReceiver);\n\n    /// @notice Emitted on the change of DAO fee receiver for particular silo\n    /// @param silo Address for which new DAO fee receiver is set.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChangedForSilo(address silo, address daoFeeReceiver);\n\n    /// @notice Emitted on the change of DAO fee receiver for particular asset\n    /// @param asset Address for which new DAO fee receiver is set.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChangedForAsset(address asset, address daoFeeReceiver);\n\n    error MissingHookReceiver();\n    error ZeroAddress();\n    error DaoFeeReceiverZeroAddress();\n    error SameDaoFeeReceiver();\n    error EmptyToken0();\n    error EmptyToken1();\n    error MaxFeeExceeded();\n    error InvalidFeeRange();\n    error SameAsset();\n    error SameRange();\n    error InvalidIrm();\n    error InvalidMaxLtv();\n    error InvalidLt();\n    error InvalidDeployer();\n    error DaoMinRangeExceeded();\n    error DaoMaxRangeExceeded();\n    error MaxDeployerFeeExceeded();\n    error MaxFlashloanFeeExceeded();\n    error MaxLiquidationFeeExceeded();\n    error InvalidCallBeforeQuote();\n    error OracleMisconfiguration();\n    error InvalidQuoteToken();\n    error HookIsZeroAddress();\n    error LiquidationTargetLtvTooHigh();\n    error NotYourSilo();\n    error ConfigMismatchSilo();\n    error ConfigMismatchShareProtectedToken();\n    error ConfigMismatchShareDebtToken();\n    error ConfigMismatchShareCollateralToken();\n\n    /// @notice Create a new Silo.\n    /// @param _siloConfig Silo configuration.\n    /// @param _siloImpl Address of the `Silo` implementation.\n    /// @param _shareProtectedCollateralTokenImpl Address of the `ShareProtectedCollateralToken` implementation.\n    /// @param _shareDebtTokenImpl Address of the `ShareDebtToken` implementation.\n    /// @param _deployer Address of the deployer.\n    /// @param _creator Address of the creator.\n    function createSilo(\n        ISiloConfig _siloConfig,\n        address _siloImpl,\n        address _shareProtectedCollateralTokenImpl,\n        address _shareDebtTokenImpl,\n        address _deployer,\n        address _creator\n    )\n        external;\n\n    /// @notice NFT ownership represents the deployer fee receiver for the each Silo ID.  After burning, \n    /// the deployer fee is sent to the DAO. Burning doesn't affect Silo's behavior. It is only about fee distribution.\n    /// @param _siloIdToBurn silo ID to burn.\n    function burn(uint256 _siloIdToBurn) external;\n\n    /// @notice Update the value of DAO fee. Updated value will be used only for a new Silos.\n    /// Previously deployed SiloConfigs are immutable.\n    /// @param _minFee Value of the new DAO minimal fee.\n    /// @param _maxFee Value of the new DAO maximal fee.\n    function setDaoFee(uint128 _minFee, uint128 _maxFee) external;\n\n    /// @notice Set the default DAO fee receiver.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiver(address _newDaoFeeReceiver) external;\n\n    /// @notice Set the new DAO fee receiver for asset, this setup will be used when fee receiver for silo is empty.\n    /// @param _asset Address for which new DAO fee receiver is set.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiverForAsset(address _asset, address _newDaoFeeReceiver) external;\n\n    /// @notice Set the new DAO fee receiver for silo. This setup has highest priority.\n    /// @param _silo Address for which new DAO fee receiver is set.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiverForSilo(address _silo, address _newDaoFeeReceiver) external;\n\n    /// @notice Update the value of max deployer fee. Updated value will be used only for a new Silos max deployer\n    /// fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxDeployerFee Value of the new max deployer fee.\n    function setMaxDeployerFee(uint256 _newMaxDeployerFee) external;\n\n    /// @notice Update the value of max flashloan fee. Updated value will be used only for a new Silos max flashloan\n    /// fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxFlashloanFee Value of the new max flashloan fee.\n    function setMaxFlashloanFee(uint256 _newMaxFlashloanFee) external;\n\n    /// @notice Update the value of max liquidation fee. Updated value will be used only for a new Silos max\n    /// liquidation fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxLiquidationFee Value of the new max liquidation fee.\n    function setMaxLiquidationFee(uint256 _newMaxLiquidationFee) external;\n   \n    /// @notice Update the base URI.\n    /// @param _newBaseURI Value of the new base URI.\n    function setBaseURI(string calldata _newBaseURI) external;\n\n    /// @notice Acceptable DAO fee range for new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function daoFeeRange() external view returns (Range memory);\n\n    /// @notice Max deployer fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxDeployerFee() external view returns (uint256);\n\n    /// @notice Max flashloan fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxFlashloanFee() external view returns (uint256);\n\n    /// @notice Max liquidation fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxLiquidationFee() external view returns (uint256);\n\n    /// @notice The recipient of DAO fees.\n    function daoFeeReceiver() external view returns (address);\n\n    /// @notice Get SiloConfig address by Silo id.\n    function idToSiloConfig(uint256 _id) external view returns (address);\n\n    /// @notice Get the counter of silos created by the wallet.\n    function creatorSiloCounter(address _creator) external view returns (uint256);\n\n    /// @notice Do not use this method to check if silo is secure. Anyone can deploy silo with any configuration\n    /// and implementation. Most critical part of verification would be to check who deployed it.\n    /// @dev True if the address was deployed using SiloFactory.\n    function isSilo(address _silo) external view returns (bool);\n\n    /// @notice Id of a next Silo to be deployed. This is an ID of non-existing Silo outside of createSilo\n    /// function call. ID of a first Silo is 1.\n    function getNextSiloId() external view returns (uint256);\n\n    /// @notice Get the DAO and deployer fee receivers for a particular Silo address.\n    /// @param _silo Silo address.\n    /// @return dao DAO fee receiver.\n    /// @return deployer Deployer fee receiver.\n    function getFeeReceivers(address _silo) external view returns (address dao, address deployer);\n\n    /// @notice Validate InitData for a new Silo. Config will be checked for the fee limits, missing parameters.\n    /// @param _initData Silo init data.\n    function validateSiloInitData(ISiloConfig.InitData memory _initData) external view returns (bool);\n}\n"
    },
    "silo-core/contracts/interfaces/IInterestRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IInterestRateModelV2 {\n    struct Config {\n        // uopt ∈ (0, 1) – optimal utilization;\n        int256 uopt;\n        // ucrit ∈ (uopt, 1) – threshold of large utilization;\n        int256 ucrit;\n        // ulow ∈ (0, uopt) – threshold of low utilization\n        int256 ulow;\n        // ki > 0 – integrator gain\n        int256 ki;\n        // kcrit > 0 – proportional gain for large utilization\n        int256 kcrit;\n        // klow ≥ 0 – proportional gain for low utilization\n        int256 klow;\n        // klin ≥ 0 – coefficient of the lower linear bound\n        int256 klin;\n        // beta ≥ 0 - a scaling factor\n        int256 beta;\n        // ri ≥ 0 – initial value of the integrator\n        int112 ri;\n        // Tcrit ≥ 0 - initial value of the time during which the utilization exceeds the critical value\n        int112 Tcrit;\n    }\n\n    struct Setup {\n        // ri ≥ 0 – the integrator\n        int112 ri;\n        // Tcrit ≥ 0 - the time during which the utilization exceeds the critical value\n        int112 Tcrit;\n        // flag that informs if setup is initialized\n        bool initialized;\n    }\n    /* solhint-enable */\n\n    error AddressZero();\n    error DeployConfigFirst();\n    error AlreadyInitialized();\n\n    error InvalidBeta();\n    error InvalidKcrit();\n    error InvalidKi();\n    error InvalidKlin();\n    error InvalidKlow();\n    error InvalidTcrit();\n    error InvalidTimestamps();\n    error InvalidUcrit();\n    error InvalidUlow();\n    error InvalidUopt();\n    error InvalidRi();\n\n    /// @dev Get config for given asset in a Silo.\n    /// @param _silo Silo address for which config should be set\n    /// @return Config struct for asset in Silo\n    function getConfig(address _silo) external view returns (Config memory);\n\n    /// @notice get the flag to detect rcomp restriction (zero current interest) due to overflow\n    /// overflow boolean flag to detect rcomp restriction\n    function overflowDetected(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (bool overflow);\n\n    /// @dev pure function that calculates current annual interest rate\n    /// @param _c configuration object, IInterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function calculateCurrentInterestRate(\n        Config calldata _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (uint256 rcur);\n\n    /// @dev pure function that calculates interest rate based on raw input data\n    /// @param _c configuration object, IInterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    /// @return ri current integral part of the rate\n    /// @return Tcrit time during which the utilization exceeds the critical value\n    /// @return overflow boolean flag to detect rcomp restriction\n    function calculateCompoundInterestRateWithOverflowDetection(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    )\n        external\n        pure\n        returns (\n            uint256 rcomp,\n            int256 ri,\n            int256 Tcrit,\n            bool overflow\n        );\n\n    /// @dev pure function that calculates interest rate based on raw input data\n    /// @param _c configuration object, IInterestRateModel.Config\n    /// @param _totalBorrowAmount current total borrows for asset\n    /// @param _totalDeposits current total deposits for asset\n    /// @param _interestRateTimestamp timestamp of last interest rate update\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    /// @return ri current integral part of the rate\n    /// @return Tcrit time during which the utilization exceeds the critical value\n    function calculateCompoundInterestRate(\n        Config memory _c,\n        uint256 _totalDeposits,\n        uint256 _totalBorrowAmount,\n        uint256 _interestRateTimestamp,\n        uint256 _blockTimestamp\n    ) external pure returns (uint256 rcomp, int256 ri, int256 Tcrit);\n}\n"
    },
    "silo-core/contracts/interfaces/IInterestRateModelV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IInterestRateModelV2} from \"./IInterestRateModelV2.sol\";\n\ninterface IInterestRateModelV2Factory {\n    /// @dev config hash and IRM should be easily accessible directly from oracle contract\n    event NewInterestRateModelV2(bytes32 indexed configHash, IInterestRateModelV2 indexed irm);\n\n    /// @dev verifies config and creates IRM config contract\n    /// @notice it can be used in separate tx eg config can be prepared before it will be used for Silo creation\n    /// @param _config IRM configuration\n    /// @param _externalSalt external salt for the create2 call\n    /// @return configHash the hashed config used as a key for IRM contract\n    /// @return irm deployed (or existing one, depends on the config) contract address\n    function create(IInterestRateModelV2.Config calldata _config, bytes32 _externalSalt)\n        external\n        returns (bytes32 configHash, IInterestRateModelV2 irm);\n\n    /// @dev DP is 18 decimal points used for integer calculations\n    // solhint-disable-next-line func-name-mixedcase\n    function DP() external view returns (uint256);\n\n    /// @dev verifies if config has correct values for a model, throws on invalid `_config`\n    /// @param _config config that will ve verified\n    function verifyConfig(IInterestRateModelV2.Config calldata _config) external view;\n\n    /// @dev hashes IRM config\n    /// @param _config IRM config\n    /// @return configId hash of `_config`\n    function hashConfig(IInterestRateModelV2.Config calldata _config) external pure returns (bytes32 configId);\n}\n"
    },
    "silo-core/contracts/interfaces/IDynamicKinkModelFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IDynamicKinkModel} from \"./IDynamicKinkModel.sol\";\nimport {IInterestRateModel} from \"./IInterestRateModel.sol\";\n\n/// @title IDynamicKinkModelFactory\n/// @notice Factory interface for creating Dynamic Kink Interest Rate Model instances\n/// @dev This factory creates and manages DynamicKinkModel instances using a clone pattern.\n///      It provides utilities for configuration generation, validation, and deterministic\n///      address prediction using CREATE2.\n/// \n///      Key Features:\n///      - Creates DynamicKinkModel instances via cloning\n///      - Converts user-friendly configs to internal model parameters\n///      - Validates configurations before deployment\n///      - Predicts deterministic addresses for CREATE2 deployments\n///      - Tracks which models were created by this factory\n/// \n///      Usage Flow:\n///      1. Use generateConfig() to convert UserFriendlyConfig to internal Config\n///      2. Use verifyConfig() to validate the configuration\n///      3. Use create() to deploy a new DynamicKinkModel instance\n///      4. Use predictAddress() to determine the deployment address beforehand\ninterface IDynamicKinkModelFactory {\n    /// @notice Emitted when a new DynamicKinkModel instance is created\n    /// @param irm The address of the newly created DynamicKinkModel instance\n    event NewDynamicKinkModel(IDynamicKinkModel indexed irm);\n\n    /// @notice Thrown when trying to predict address with zero deployer address\n    error DeployerCannotBeZero();\n\n    /// @notice Creates a new DynamicKinkModel instance using CREATE2\n    /// @dev This function verifies the configuration, creates a clone of the implementation,\n    ///      initializes it with the provided parameters, and tracks it in the factory.\n    ///      The same salt will always produce the same address, enabling deterministic deployments.\n    /// \n    ///      The function can be used in separate transactions - configurations can be prepared\n    ///      and validated before being used for Silo creation.\n    /// \n    /// @param _config Updatable configuration parameters\n    /// @param _immutableArgs Immutable configuration arguments\n    /// @param _initialOwner Address that will own and control the created model instance\n    /// @param _silo Address of the Silo contract this model will serve\n    /// @param _externalSalt External salt for the CREATE2 deterministic deployment\n    /// @return irm The deployed DynamicKinkModel instance (IInterestRateModel interface)\n    function create(\n        IDynamicKinkModel.Config calldata _config, \n        IDynamicKinkModel.ImmutableArgs calldata _immutableArgs,\n        address _initialOwner,\n        address _silo,\n        bytes32 _externalSalt\n    )\n        external\n        returns (IInterestRateModel irm);\n\n    /// @notice Converts user-friendly configuration to internal model parameters\n    /// @dev This function takes intuitive configuration parameters and converts them to the\n    ///      internal mathematical parameters used by the DynamicKinkModel. It performs\n    ///      validation to ensure the configuration is mathematically sound and within\n    ///      acceptable limits.\n    /// \n    ///      The conversion includes:\n    ///      - Converting annual rates to per-second rates\n    ///      - Calculating slope parameters (kmin, kmax) from rate ranges\n    ///      - Computing time-based coefficients (c1, c2, cminus, cplus)\n    ///      - Validating parameter relationships and constraints\n    /// \n    /// @param _default User-friendly configuration parameters (utilization thresholds, rates, times)\n    /// @return config Internal configuration parameters ready for model initialization\n    function generateConfig(IDynamicKinkModel.UserFriendlyConfig calldata _default)\n        external\n        view\n        returns (IDynamicKinkModel.Config memory config);\n\n    /// @notice Validates that configuration parameters are within acceptable limits\n    /// @dev This function checks if all configuration parameters are within the safe operating ranges\n    ///      defined by the model whitepaper. Some limits are narrower than the original whitepaper\n    ///      due to additional research and safety considerations.\n    /// \n    ///      For detailed limits, see:\n    ///      https://silofinance.atlassian.net/wiki/spaces/SF/pages/347963393/DynamicKink+model+config+limits+V1\n    /// \n    /// @param _config The configuration to validate (does not include model state)\n    /// @custom:throws Reverts if any parameter is outside acceptable limits\n    function verifyConfig(IDynamicKinkModel.Config calldata _config) external view;\n\n    /// @notice Predicts the deterministic address of a DynamicKinkModel that would be created\n    /// @dev This function calculates the address that would be generated by CREATE2 when\n    ///      creating a DynamicKinkModel with the given deployer and salt. This enables\n    ///      front-running protection and allows users to know the address before deployment.\n    /// \n    ///      The same deployer and salt will always produce the same predicted address.\n    /// \n    /// @param _deployer Address of the account that will deploy the model\n    /// @param _externalSalt External salt for the CREATE2 deterministic deployment\n    /// @return predictedAddress The address where the DynamicKinkModel would be deployed\n    function predictAddress(address _deployer, bytes32 _externalSalt)\n        external\n        view\n        returns (address predictedAddress);\n\n    /// @notice Checks if a DynamicKinkModel was created by this factory\n    /// @dev This function verifies whether a given address corresponds to a DynamicKinkModel\n    ///      instance that was deployed through this factory. This is useful for:\n    ///      - Verifying the authenticity of model instances\n    ///      - Implementing access controls based on factory creation\n    ///      - Tracking and managing factory-deployed models\n    /// \n    /// @param _irm Address of the DynamicKinkModel contract to check\n    /// @return isCreated True if the model was created by this factory, false otherwise\n    function createdByFactory(address _irm) external view returns (bool isCreated);\n}\n"
    },
    "silo-core/contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IInterestRateModel {\n    event InterestRateModelError();\n\n    /// @dev Sets config address for all Silos that will use this model\n    /// @param _irmConfig address of IRM config contract\n    function initialize(address _irmConfig) external;\n\n    /// @dev get compound interest rate and update model storage for current block.timestamp\n    /// @param _collateralAssets total silo collateral assets\n    /// @param _debtAssets total silo debt assets\n    /// @param _interestRateTimestamp last IRM timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRateAndUpdate(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _interestRateTimestamp\n    )\n        external\n        returns (uint256 rcomp);\n\n    /// @dev get compound interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcomp);\n\n    /// @dev get current annual interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function getCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcur);\n\n    /// @dev returns decimal points used by model\n    function decimals() external view returns (uint256);\n}\n"
    },
    "silo-core/contracts/interfaces/IHookReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\ninterface IHookReceiver {\n    struct HookConfig {\n        uint24 hooksBefore;\n        uint24 hooksAfter;\n    }\n\n    event HookConfigured(address silo, uint24 hooksBefore, uint24 hooksAfter);\n\n    /// @dev Revert if provided silo configuration during initialization is empty\n    error EmptySiloConfig();\n    /// @dev Revert if the hook receiver is already configured/initialized\n    error AlreadyConfigured();\n    /// @dev Revert if the caller is not a silo\n    error OnlySilo();\n    /// @dev Revert if the caller is not a silo or a share token\n    error OnlySiloOrShareToken();\n\n    /// @notice Initialize a hook receiver\n    /// @param _siloConfig Silo configuration with all the details about the silo\n    /// @param _data Data to initialize the hook receiver (if needed)\n    function initialize(ISiloConfig _siloConfig, bytes calldata _data) external;\n\n    /// @notice state of Silo before action, can be also without interest, if you need them, call silo.accrueInterest()\n    function beforeAction(address _silo, uint256 _action, bytes calldata _input) external;\n\n    function afterAction(address _silo, uint256 _action, bytes calldata _inputAndOutput) external;\n\n    /// @notice return hooksBefore and hooksAfter configuration\n    function hookReceiverConfig(address _silo) external view returns (uint24 hooksBefore, uint24 hooksAfter);\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IDynamicKinkModel} from \"./IDynamicKinkModel.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\n/// @notice Silo Deployer\ninterface ISiloDeployer {\n    /// @dev Details of the oracle creation transaction\n    struct OracleCreationTxData {\n        address deployed; // if oracle is already deployed, this will be the address to use\n        address factory; // oracle factory (chainlinkV3, uniswapV3, etc)\n        bytes txInput; // fn input `abi.encodeCall(fn, params...)`\n    }\n\n    /// @dev Hook receiver to be cloned and initialized during the Silo creation\n    struct ClonableHookReceiver {\n        address implementation;\n        bytes initializationData;\n    }\n\n    /// @dev Oracles to be create during the Silo creation.\n    /// If an oracle for the provided config is already created an oracle factory will return its address.\n    struct Oracles {\n        OracleCreationTxData solvencyOracle0;\n        OracleCreationTxData maxLtvOracle0;\n        OracleCreationTxData solvencyOracle1;\n        OracleCreationTxData maxLtvOracle1;\n    }\n\n    /// @dev DKinkIRM config to be created during the Silo creation.\n    struct DKinkIRMConfig {\n        IDynamicKinkModel.Config config;\n        IDynamicKinkModel.ImmutableArgs immutableArgs;\n        address initialOwner;\n    }\n\n    /// @dev Emit after the Silo creation\n    event SiloCreated(ISiloConfig siloConfig);\n\n    /// @dev Revert if an oracle factory fails to create an oracle\n    error FailedToCreateAnOracle(address _factory);\n\n    /// @dev Revert if for the deployment provided both hook receiver and hook receiver implementation\n    error HookReceiverMisconfigured();\n\n    /// @notice Deploy silo\n    /// @param _oracles Oracles to be create during the silo creation\n    /// @param _irmConfigData0 IRM config data for a silo `_TOKEN0`\n    /// @param _irmConfigData1 IRM config data for a silo `_TOKEN1`\n    /// @param _clonableHookReceiver Hook receiver implementation to clone (ignored if implementation has address(0))\n    /// @param _siloInitData Silo configuration for the silo creation\n    function deploy(\n        Oracles calldata _oracles,\n        bytes calldata _irmConfigData0,\n        bytes calldata _irmConfigData1,\n        ClonableHookReceiver calldata _clonableHookReceiver,\n        ISiloConfig.InitData memory _siloInitData\n    )\n        external\n        returns (ISiloConfig siloConfig);\n}\n"
    },
    "silo-core/contracts/SiloConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\n\nimport {ISilo} from \"./interfaces/ISilo.sol\";\nimport {ISiloConfig} from \"./interfaces/ISiloConfig.sol\";\nimport {CrossReentrancyGuard} from \"./utils/CrossReentrancyGuard.sol\";\nimport {Hook} from \"./lib/Hook.sol\";\n\n/// @notice SiloConfig stores full configuration of Silo in immutable manner\n/// @dev Immutable contract is more expensive to deploy than minimal proxy however it provides nearly 10x cheaper\n/// data access using immutable variables.\ncontract SiloConfig is ISiloConfig, CrossReentrancyGuard {\n    using Hook for uint256;\n    \n    uint256 public immutable SILO_ID;\n\n    uint256 internal immutable _DAO_FEE;\n    uint256 internal immutable _DEPLOYER_FEE;\n    address internal immutable _HOOK_RECEIVER;\n\n    // TOKEN #0\n\n    address internal immutable _SILO0;\n\n    address internal immutable _TOKEN0;\n\n    /// @dev Token that represents a share in total protected deposits of Silo\n    address internal immutable _PROTECTED_COLLATERAL_SHARE_TOKEN0;\n    /// @dev Token that represents a share in total deposits of Silo\n    address internal immutable _COLLATERAL_SHARE_TOKEN0;\n    /// @dev Token that represents a share in total debt of Silo\n    address internal immutable _DEBT_SHARE_TOKEN0;\n\n    address internal immutable _SOLVENCY_ORACLE0;\n    address internal immutable _MAX_LTV_ORACLE0;\n\n    address internal immutable _INTEREST_RATE_MODEL0;\n\n    uint256 internal immutable _MAX_LTV0;\n    uint256 internal immutable _LT0;\n    /// @dev target LTV after liquidation\n    uint256 internal immutable _LIQUIDATION_TARGET_LTV0;\n    uint256 internal immutable _LIQUIDATION_FEE0;\n    uint256 internal immutable _FLASHLOAN_FEE0;\n\n    bool internal immutable _CALL_BEFORE_QUOTE0;\n\n    // TOKEN #1\n\n    address internal immutable _SILO1;\n\n    address internal immutable _TOKEN1;\n\n    /// @dev Token that represents a share in total protected deposits of Silo\n    address internal immutable _PROTECTED_COLLATERAL_SHARE_TOKEN1;\n    /// @dev Token that represents a share in total deposits of Silo\n    address internal immutable _COLLATERAL_SHARE_TOKEN1;\n    /// @dev Token that represents a share in total debt of Silo\n    address internal immutable _DEBT_SHARE_TOKEN1;\n\n    address internal immutable _SOLVENCY_ORACLE1;\n    address internal immutable _MAX_LTV_ORACLE1;\n\n    address internal immutable _INTEREST_RATE_MODEL1;\n\n    uint256 internal immutable _MAX_LTV1;\n    uint256 internal immutable _LT1;\n    /// @dev target LTV after liquidation\n    uint256 internal immutable _LIQUIDATION_TARGET_LTV1;\n    uint256 internal immutable _LIQUIDATION_FEE1;\n    uint256 internal immutable _FLASHLOAN_FEE1;\n\n    bool internal immutable _CALL_BEFORE_QUOTE1;\n    \n    /// @inheritdoc ISiloConfig\n    mapping (address borrower => address collateralSilo) public borrowerCollateralSilo;\n    \n    /// @param _siloId ID of this pool assigned by factory\n    /// @param _configData0 silo configuration data for token0\n    /// @param _configData1 silo configuration data for token1\n    constructor( // solhint-disable-line function-max-lines\n        uint256 _siloId,\n        ConfigData memory _configData0,\n        ConfigData memory _configData1\n    ) {\n        SILO_ID = _siloId;\n\n        // To make further computations in the Silo secure require DAO and deployer fees to be less than 100%\n        require(_configData0.daoFee + _configData0.deployerFee < 1e18, FeeTooHigh());\n\n        _DAO_FEE = _configData0.daoFee;\n        _DEPLOYER_FEE = _configData0.deployerFee;\n        _HOOK_RECEIVER = _configData0.hookReceiver;\n\n        // TOKEN #0\n\n        _SILO0 = _configData0.silo;\n        _TOKEN0 = _configData0.token;\n\n        _PROTECTED_COLLATERAL_SHARE_TOKEN0 = _configData0.protectedShareToken;\n        _COLLATERAL_SHARE_TOKEN0 = _configData0.silo;\n        _DEBT_SHARE_TOKEN0 = _configData0.debtShareToken;\n\n        _SOLVENCY_ORACLE0 = _configData0.solvencyOracle;\n        _MAX_LTV_ORACLE0 = _configData0.maxLtvOracle;\n\n        _INTEREST_RATE_MODEL0 = _configData0.interestRateModel;\n\n        _MAX_LTV0 = _configData0.maxLtv;\n        _LT0 = _configData0.lt;\n        _LIQUIDATION_TARGET_LTV0 = _configData0.liquidationTargetLtv;\n        _LIQUIDATION_FEE0 = _configData0.liquidationFee;\n        _FLASHLOAN_FEE0 = _configData0.flashloanFee;\n\n        _CALL_BEFORE_QUOTE0 = _configData0.callBeforeQuote;\n\n        // TOKEN #1\n\n        _SILO1 = _configData1.silo;\n        _TOKEN1 = _configData1.token;\n\n        _PROTECTED_COLLATERAL_SHARE_TOKEN1 = _configData1.protectedShareToken;\n        _COLLATERAL_SHARE_TOKEN1 = _configData1.silo;\n        _DEBT_SHARE_TOKEN1 = _configData1.debtShareToken;\n\n        _SOLVENCY_ORACLE1 = _configData1.solvencyOracle;\n        _MAX_LTV_ORACLE1 = _configData1.maxLtvOracle;\n\n        _INTEREST_RATE_MODEL1 = _configData1.interestRateModel;\n\n        _MAX_LTV1 = _configData1.maxLtv;\n        _LT1 = _configData1.lt;\n        _LIQUIDATION_TARGET_LTV1 = _configData1.liquidationTargetLtv;\n        _LIQUIDATION_FEE1 = _configData1.liquidationFee;\n        _FLASHLOAN_FEE1 = _configData1.flashloanFee;\n\n        _CALL_BEFORE_QUOTE1 = _configData1.callBeforeQuote;\n    }\n\n    /// @inheritdoc ISiloConfig\n    function setThisSiloAsCollateralSilo(address) external virtual returns (bool) {\n        revert Deprecated();\n    }\n\n    /// @inheritdoc ISiloConfig\n    function setOtherSiloAsCollateralSilo(address _borrower) external virtual returns (bool collateralSiloChanged) {\n        collateralSiloChanged = _setSiloAsCollateralSilo(msg.sender == _SILO0 ? _SILO1 : _SILO0, _borrower);\n    }\n\n    /// @inheritdoc ISiloConfig\n    function onDebtTransfer(address _sender, address _recipient) external virtual {\n        require(msg.sender == _DEBT_SHARE_TOKEN0 || msg.sender == _DEBT_SHARE_TOKEN1, OnlyDebtShareToken());\n\n        address thisSilo = msg.sender == _DEBT_SHARE_TOKEN0 ? _SILO0 : _SILO1;\n\n        require(!hasDebtInOtherSilo(thisSilo, _recipient), DebtExistInOtherSilo());\n\n        if (borrowerCollateralSilo[_recipient] == address(0)) {\n            borrowerCollateralSilo[_recipient] = borrowerCollateralSilo[_sender];\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function accrueInterestForSilo(address _silo) external virtual {\n        address irm;\n\n        if (_silo == _SILO0) {\n            irm = _INTEREST_RATE_MODEL0;\n        } else if (_silo == _SILO1) {\n            irm = _INTEREST_RATE_MODEL1;\n        } else {\n            revert WrongSilo();\n        }\n\n        ISilo(_silo).accrueInterestForConfig(\n            irm,\n            _DAO_FEE,\n            _DEPLOYER_FEE\n        );\n    }\n\n    /// @inheritdoc ISiloConfig\n    function accrueInterestForBothSilos() external virtual {\n        ISilo(_SILO0).accrueInterestForConfig(\n            _INTEREST_RATE_MODEL0,\n            _DAO_FEE,\n            _DEPLOYER_FEE\n        );\n\n        ISilo(_SILO1).accrueInterestForConfig(\n            _INTEREST_RATE_MODEL1,\n            _DAO_FEE,\n            _DEPLOYER_FEE\n        );\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getConfigsForSolvency(address _borrower) public view virtual returns (\n        ConfigData memory collateralConfig,\n        ConfigData memory debtConfig\n    ) {\n        address debtSilo = getDebtSilo(_borrower);\n\n        if (debtSilo == address(0)) return (collateralConfig, debtConfig);\n\n        address collateralSilo = borrowerCollateralSilo[_borrower];\n\n        collateralConfig = getConfig(collateralSilo);\n        debtConfig = getConfig(debtSilo);\n    }\n\n    /// @inheritdoc ISiloConfig\n    // solhint-disable-next-line ordering\n    function getConfigsForWithdraw(address _silo, address _depositOwner) external view virtual returns (\n        DepositConfig memory depositConfig,\n        ConfigData memory collateralConfig,\n        ConfigData memory debtConfig\n    ) {\n        depositConfig = _getDepositConfig(_silo);\n        (collateralConfig, debtConfig) = getConfigsForSolvency(_depositOwner);\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getConfigsForBorrow(address _debtSilo)\n        external\n        view\n        virtual\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig)\n    {\n        address collateralSilo; \n        \n        if (_debtSilo == _SILO0) {\n            collateralSilo = _SILO1;\n        } else if (_debtSilo == _SILO1) {\n            collateralSilo = _SILO0;\n        } else {\n            revert WrongSilo();\n        }\n\n        collateralConfig = getConfig(collateralSilo);\n        debtConfig = getConfig(_debtSilo);\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getSilos() external view virtual returns (address silo0, address silo1) {\n        return (_SILO0, _SILO1);\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getShareTokens(address _silo)\n        external\n        view\n        virtual\n        returns (address protectedShareToken, address collateralShareToken, address debtShareToken)\n    {\n        if (_silo == _SILO0) {\n            return (_PROTECTED_COLLATERAL_SHARE_TOKEN0, _COLLATERAL_SHARE_TOKEN0, _DEBT_SHARE_TOKEN0);\n        } else if (_silo == _SILO1) {\n            return (_PROTECTED_COLLATERAL_SHARE_TOKEN1, _COLLATERAL_SHARE_TOKEN1, _DEBT_SHARE_TOKEN1);\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getAssetForSilo(address _silo) external view virtual returns (address asset) {\n        if (_silo == _SILO0) {\n            return _TOKEN0;\n        } else if (_silo == _SILO1) {\n            return _TOKEN1;\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getFeesWithAsset(address _silo)\n        external\n        view\n        virtual\n        returns (uint256 daoFee, uint256 deployerFee, uint256 flashloanFee, address asset)\n    {\n        daoFee = _DAO_FEE;\n        deployerFee = _DEPLOYER_FEE;\n\n        if (_silo == _SILO0) {\n            asset = _TOKEN0;\n            flashloanFee = _FLASHLOAN_FEE0;\n        } else if (_silo == _SILO1) {\n            asset = _TOKEN1;\n            flashloanFee = _FLASHLOAN_FEE1;\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getCollateralShareTokenAndAsset(address _silo, ISilo.CollateralType _collateralType)\n        external\n        view\n        virtual\n        returns (address shareToken, address asset)\n    {\n        if (_silo == _SILO0) {\n            return _collateralType == ISilo.CollateralType.Collateral\n                ? (_COLLATERAL_SHARE_TOKEN0, _TOKEN0)\n                : (_PROTECTED_COLLATERAL_SHARE_TOKEN0, _TOKEN0);\n        } else if (_silo == _SILO1) {\n            return _collateralType == ISilo.CollateralType.Collateral\n                ? (_COLLATERAL_SHARE_TOKEN1, _TOKEN1)\n                : (_PROTECTED_COLLATERAL_SHARE_TOKEN1, _TOKEN1);\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getDebtShareTokenAndAsset(address _silo)\n        external\n        view\n        virtual\n        returns (address shareToken, address asset)\n    {\n        if (_silo == _SILO0) {\n            return (_DEBT_SHARE_TOKEN0, _TOKEN0);\n        } else if (_silo == _SILO1) {\n            return (_DEBT_SHARE_TOKEN1, _TOKEN1);\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function getConfig(address _silo) public view virtual returns (ConfigData memory config) {\n        if (_silo == _SILO0) {\n            config = _silo0ConfigData();\n        } else if (_silo == _SILO1) {\n            config = _silo1ConfigData();\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    /// @inheritdoc ISiloConfig\n    function hasDebtInOtherSilo(address _thisSilo, address _borrower) public view virtual returns (bool hasDebt) {\n        if (_thisSilo == _SILO0) {\n            hasDebt = _balanceOf(_DEBT_SHARE_TOKEN1, _borrower) != 0;\n        } else if (_thisSilo == _SILO1) {\n            hasDebt = _balanceOf(_DEBT_SHARE_TOKEN0, _borrower) != 0;\n        } else {\n            revert WrongSilo();\n        }\n     }\n\n    /// @inheritdoc ISiloConfig\n    function getDebtSilo(address _borrower) public view virtual returns (address debtSilo) {\n        uint256 debtBal0 = _balanceOf(_DEBT_SHARE_TOKEN0, _borrower);\n        uint256 debtBal1 = _balanceOf(_DEBT_SHARE_TOKEN1, _borrower);\n\n        require(debtBal0 == 0 || debtBal1 == 0, DebtExistInOtherSilo());\n        if (debtBal0 == 0 && debtBal1 == 0) return address(0);\n\n        debtSilo = debtBal0 != 0 ? _SILO0 : _SILO1;\n    }\n\n    function _silo0ConfigData() internal view virtual returns (ConfigData memory config) {\n        config = ConfigData({\n            daoFee: _DAO_FEE,\n            deployerFee: _DEPLOYER_FEE,\n            silo: _SILO0,\n            token: _TOKEN0,\n            protectedShareToken: _PROTECTED_COLLATERAL_SHARE_TOKEN0,\n            collateralShareToken: _COLLATERAL_SHARE_TOKEN0,\n            debtShareToken: _DEBT_SHARE_TOKEN0,\n            solvencyOracle: _SOLVENCY_ORACLE0,\n            maxLtvOracle: _MAX_LTV_ORACLE0,\n            interestRateModel: _INTEREST_RATE_MODEL0,\n            maxLtv: _MAX_LTV0,\n            lt: _LT0,\n            liquidationTargetLtv: _LIQUIDATION_TARGET_LTV0,\n            liquidationFee: _LIQUIDATION_FEE0,\n            flashloanFee: _FLASHLOAN_FEE0,\n            hookReceiver: _HOOK_RECEIVER,\n            callBeforeQuote: _CALL_BEFORE_QUOTE0\n        });\n    }\n\n    function _silo1ConfigData() internal view virtual returns (ConfigData memory config) {\n        config = ConfigData({\n            daoFee: _DAO_FEE,\n            deployerFee: _DEPLOYER_FEE,\n            silo: _SILO1,\n            token: _TOKEN1,\n            protectedShareToken: _PROTECTED_COLLATERAL_SHARE_TOKEN1,\n            collateralShareToken: _COLLATERAL_SHARE_TOKEN1,\n            debtShareToken: _DEBT_SHARE_TOKEN1,\n            solvencyOracle: _SOLVENCY_ORACLE1,\n            maxLtvOracle: _MAX_LTV_ORACLE1,\n            interestRateModel: _INTEREST_RATE_MODEL1,\n            maxLtv: _MAX_LTV1,\n            lt: _LT1,\n            liquidationTargetLtv: _LIQUIDATION_TARGET_LTV1,\n            liquidationFee: _LIQUIDATION_FEE1,\n            flashloanFee: _FLASHLOAN_FEE1,\n            hookReceiver: _HOOK_RECEIVER,\n            callBeforeQuote: _CALL_BEFORE_QUOTE1\n        });\n    }\n\n    function _getDepositConfig(address _silo) internal view virtual returns (DepositConfig memory config) {\n        if (_silo == _SILO0) {\n            config = DepositConfig({\n                silo: _SILO0,\n                token: _TOKEN0,\n                collateralShareToken: _COLLATERAL_SHARE_TOKEN0,\n                protectedShareToken: _PROTECTED_COLLATERAL_SHARE_TOKEN0,\n                daoFee: _DAO_FEE,\n                deployerFee: _DEPLOYER_FEE,\n                interestRateModel: _INTEREST_RATE_MODEL0\n            });\n        } else if (_silo == _SILO1) {\n            config = DepositConfig({\n                silo: _SILO1,\n                token: _TOKEN1,\n                collateralShareToken: _COLLATERAL_SHARE_TOKEN1,\n                protectedShareToken: _PROTECTED_COLLATERAL_SHARE_TOKEN1,\n                daoFee: _DAO_FEE,\n                deployerFee: _DEPLOYER_FEE,\n                interestRateModel: _INTEREST_RATE_MODEL1\n            });\n        } else {\n            revert WrongSilo();\n        }\n    }\n\n    function _onlySiloOrTokenOrHookReceiver() internal view virtual override {\n        if (msg.sender != _SILO0 &&\n            msg.sender != _SILO1 &&\n            msg.sender != _HOOK_RECEIVER &&\n            msg.sender != _COLLATERAL_SHARE_TOKEN0 &&\n            msg.sender != _COLLATERAL_SHARE_TOKEN1 &&\n            msg.sender != _PROTECTED_COLLATERAL_SHARE_TOKEN0 &&\n            msg.sender != _PROTECTED_COLLATERAL_SHARE_TOKEN1 &&\n            msg.sender != _DEBT_SHARE_TOKEN0 &&\n            msg.sender != _DEBT_SHARE_TOKEN1\n        ) {\n            revert OnlySiloOrTokenOrHookReceiver();\n        }\n    }\n\n    function _onlySilo() internal view virtual {\n        require(msg.sender == _SILO0 || msg.sender == _SILO1, OnlySilo());\n    }\n\n    function _balanceOf(address _token, address _user) internal view virtual returns (uint256 balance) {\n        balance = IERC20(_token).balanceOf(_user);\n    }\n\n    function _setSiloAsCollateralSilo(address _newCollateralSilo, address _borrower)\n        internal\n        virtual\n        returns (bool collateralSiloChanged)\n    {\n        _onlySilo();\n\n        if (borrowerCollateralSilo[_borrower] != _newCollateralSilo) {\n            borrowerCollateralSilo[_borrower] = _newCollateralSilo;\n            collateralSiloChanged = true;\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/CloneDeterministic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Clones} from \"openzeppelin5/proxy/Clones.sol\";\n\n/// @title Deterministic clones library for the silo market deployment.\n/// @dev This library is used to deploy deterministic clones of:\n/// Silo (SILO_0, SILO_1)\n/// ShareProtectedCollateralToken (SHARE_PROTECTED_COLLATERAL_TOKEN_0, SHARE_PROTECTED_COLLATERAL_TOKEN_1)\n/// ShareDebtToken (SHARE_DEBT_TOKEN_0, SHARE_DEBT_TOKEN_1)\nlibrary CloneDeterministic {\n    /// @dev Deterministic salt for Silo0\n    bytes32 private constant _SILO_0 = keccak256(\"create2.salt.Silo0\");\n    /// @dev Deterministic salt for ShareProtectedCollateralToken Silo0\n    bytes32 private constant _SHARE_PROTECTED_COLLATERAL_TOKEN_0 = keccak256(\n        \"create2.salt.ShareProtectedCollateralToken0\"\n    );\n    /// @dev Deterministic salt for ShareDebtToken Silo0\n    bytes32 private constant _SHARE_DEBT_TOKEN_0 = keccak256(\"create2.salt.ShareDebtToken0\");\n    /// @dev Deterministic salt for Silo1\n    bytes32 private constant _SILO_1 = keccak256(\"create2.salt.Silo1\");\n    /// @dev Deterministic salt for ShareProtectedCollateralToken Silo1\n    bytes32 private constant _SHARE_PROTECTED_COLLATERAL_TOKEN_1 = keccak256(\n        \"create2.salt.ShareProtectedCollateralToken1\"\n    );\n    /// @dev Deterministic salt for ShareDebtToken Silo1\n    bytes32 private constant _SHARE_DEBT_TOKEN_1 = keccak256(\"create2.salt.ShareDebtToken1\");\n\n    /// @notice Deploys a Silo0 clone.\n    /// @param _implementation The Silo implementation to be cloned.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function silo0(address _implementation, uint256 _creatorSiloCounter, address _creator)\n        internal\n        returns (address instance)\n    {\n        instance = Clones.cloneDeterministic(_implementation, _silo0Salt(_creatorSiloCounter, _creator));\n    }\n\n    /// @notice Deploys a Silo1 clone.\n    /// @param _implementation The Silo implementation to be cloned.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function silo1(address _implementation, uint256 _creatorSiloCounter, address _creator)\n        internal\n        returns (address instance)\n    {\n        instance = Clones.cloneDeterministic(_implementation, _silo1Salt(_creatorSiloCounter, _creator));\n    }\n\n    /// @notice Deploys a protected share token clone for the silo0.\n    /// @param _implementation The protected share token implementation to be cloned.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function shareProtectedCollateralToken0(\n        address _implementation,\n        uint256 _creatorSiloCounter,\n        address _creator\n    )\n        internal\n        returns (address instance)\n    {\n        instance = Clones.cloneDeterministic(\n            _implementation, _shareProtectedCollateralToken0Salt(_creatorSiloCounter, _creator)\n        );\n    }\n\n    /// @notice Deploys a debt share token clone for the silo0.\n    /// @param _implementation The debt share token implementation to be cloned.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function shareDebtToken0(\n        address _implementation,\n        uint256 _creatorSiloCounter,\n        address _creator\n    )\n        internal\n        returns (address instance)\n    {\n        instance = Clones.cloneDeterministic(_implementation, _shareDebtToken0Salt(_creatorSiloCounter, _creator));\n    }\n\n    /// @notice Deploys a protected share token  clone for the silo1.\n    /// @param _implementation The protected share token implementation to be cloned.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function shareProtectedCollateralToken1(\n        address _implementation,\n        uint256 _creatorSiloCounter,\n        address _creator\n    )\n        internal\n        returns (address instance)\n    {\n        instance = Clones.cloneDeterministic(\n            _implementation,\n            _shareProtectedCollateralToken1Salt(_creatorSiloCounter, _creator)\n        );\n    }\n\n    /// @notice Deploys a debt share token clone for the silo1.\n    /// @param _implementation The debt share token implementation to be cloned.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function shareDebtToken1(\n        address _implementation,\n        uint256 _creatorSiloCounter,\n        address _creator\n    )\n        internal\n        returns (address instance)\n    {\n        instance = Clones.cloneDeterministic(_implementation, _shareDebtToken1Salt(_creatorSiloCounter, _creator));\n    }\n\n    /// @notice Predicts the address of the SiloConfig _SILO0.\n    /// @param _siloImpl The Silo implementation address.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _deployer The deployer address.\n    /// @param _creator The creator address.\n    function predictSilo0Addr(\n        address _siloImpl,\n        uint256 _creatorSiloCounter,\n        address _deployer,\n        address _creator\n    )\n        internal\n        pure\n        returns (address addr)\n    {\n        addr = Clones.predictDeterministicAddress(_siloImpl, _silo0Salt(_creatorSiloCounter, _creator), _deployer);\n    }\n\n    /// @notice Predicts the address of the SiloConfig _SILO1.\n    /// @param _siloImpl The Silo implementation address.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _deployer The deployer address.\n    /// @param _creator The creator address.\n    function predictSilo1Addr(\n        address _siloImpl,\n        uint256 _creatorSiloCounter,\n        address _deployer,\n        address _creator\n    )\n        internal\n        pure\n        returns (address addr)\n    {\n        addr = Clones.predictDeterministicAddress(_siloImpl, _silo1Salt(_creatorSiloCounter, _creator), _deployer);\n    }\n\n    /// @notice Predicts the address of the SiloConfig _PROTECTED_COLLATERAL_SHARE_TOKEN0.\n    /// @param _shareProtectedCollateralTokenImpl The ShareProtectedCollateralToken implementation address.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _deployer The deployer address.\n    /// @param _creator The creator address.\n    function predictShareProtectedCollateralToken0Addr(\n        address _shareProtectedCollateralTokenImpl,\n        uint256 _creatorSiloCounter,\n        address _deployer,\n        address _creator\n    )\n        internal\n        pure\n        returns (address addr)\n    {\n        addr = Clones.predictDeterministicAddress(\n            _shareProtectedCollateralTokenImpl,\n            _shareProtectedCollateralToken0Salt(_creatorSiloCounter, _creator),\n            _deployer\n        );\n    }\n\n    /// @notice Predicts the address of the SiloConfig _DEBT_SHARE_TOKEN0.\n    /// @param _shareDebtTokenImpl The ShareDebtToken implementation address.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _deployer The deployer address.\n    /// @param _creator The creator address.\n    function predictShareDebtToken0Addr(\n        address _shareDebtTokenImpl,\n        uint256 _creatorSiloCounter,\n        address _deployer,\n        address _creator\n    )\n        internal\n        pure\n        returns (address addr)\n    {\n        addr = Clones.predictDeterministicAddress(\n            _shareDebtTokenImpl, _shareDebtToken0Salt(_creatorSiloCounter, _creator), _deployer\n        );\n    }\n\n    /// @notice Predicts the address of the SiloConfig _PROTECTED_COLLATERAL_SHARE_TOKEN1.\n    /// @param _shareProtectedCollateralTokenImpl The ShareProtectedCollateralToken implementation address.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _deployer The deployer address.\n    /// @param _creator The creator address.\n    function predictShareProtectedCollateralToken1Addr(\n        address _shareProtectedCollateralTokenImpl,\n        uint256 _creatorSiloCounter,\n        address _deployer,\n        address _creator\n    )\n        internal\n        pure\n        returns (address addr)\n    {\n        addr = Clones.predictDeterministicAddress(\n            _shareProtectedCollateralTokenImpl,\n            _shareProtectedCollateralToken1Salt(_creatorSiloCounter, _creator),\n            _deployer\n        );\n    }\n\n    /// @notice Predicts the address of the SiloConfig _DEBT_SHARE_TOKEN1.\n    /// @param _shareDebtTokenImpl The ShareDebtToken implementation address.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _deployer The deployer address.\n    /// @param _creator The creator address.\n    function predictShareDebtToken1Addr(\n        address _shareDebtTokenImpl,\n        uint256 _creatorSiloCounter,\n        address _deployer,\n        address _creator\n    )\n        internal\n        pure\n        returns (address addr)\n    {\n        addr = Clones.predictDeterministicAddress(\n            _shareDebtTokenImpl, _shareDebtToken1Salt(_creatorSiloCounter, _creator), _deployer\n        );\n    }\n\n    /// @notice Generates the salt for the `Silo0` `create2` operations.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function _silo0Salt(uint256 _creatorSiloCounter, address _creator) private pure returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(_creatorSiloCounter, _creator, _SILO_0));\n    }\n\n    /// @notice Generates the salt for the `Silo1` `create2` operations.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function _silo1Salt(uint256 _creatorSiloCounter, address _creator) private pure returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(_creatorSiloCounter, _creator, _SILO_1));\n    }\n\n    /// @notice Generates the salt for the `ShareProtectedCollateralToken0` `create2` operations.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function _shareProtectedCollateralToken0Salt(\n        uint256 _creatorSiloCounter,\n        address _creator\n    )\n        private\n        pure\n        returns (bytes32 salt)\n    {\n        salt = keccak256(abi.encodePacked(_creatorSiloCounter, _creator, _SHARE_PROTECTED_COLLATERAL_TOKEN_0));\n    }\n\n    /// @notice Generates the salt for the `ShareDebtToken0` `create2` operations.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function _shareDebtToken0Salt(\n        uint256 _creatorSiloCounter,\n        address _creator\n    )\n        private\n        pure\n        returns (bytes32 salt)\n    {\n        salt = keccak256(abi.encodePacked(_creatorSiloCounter, _creator, _SHARE_DEBT_TOKEN_0));\n    }\n\n    /// @notice Generates the salt for the `ShareProtectedCollateralToken1` `create2` operations.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function _shareProtectedCollateralToken1Salt(\n        uint256 _creatorSiloCounter,\n        address _creator\n    )\n        private\n        pure\n        returns (bytes32 salt)\n    {\n        salt = keccak256(abi.encodePacked(_creatorSiloCounter, _creator, _SHARE_PROTECTED_COLLATERAL_TOKEN_1));\n    }\n\n    /// @notice Generates the salt for the `ShareDebtToken1` `create2` operations.\n    /// @param _creatorSiloCounter The Silo ID (assigned by the `SiloFactory`).\n    /// @param _creator The creator address.\n    function _shareDebtToken1Salt(uint256 _creatorSiloCounter, address _creator) private pure returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(_creatorSiloCounter, _creator, _SHARE_DEBT_TOKEN_1));\n    }\n}\n"
    },
    "silo-core/contracts/lib/Views.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {ISiloFactory} from \"../interfaces/ISiloFactory.sol\";\n\nimport {SiloERC4626Lib} from \"./SiloERC4626Lib.sol\";\nimport {SiloSolvencyLib} from \"./SiloSolvencyLib.sol\";\nimport {SiloLendingLib} from \"./SiloLendingLib.sol\";\nimport {SiloStdLib} from \"./SiloStdLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\nimport {ShareTokenLib} from \"./ShareTokenLib.sol\";\nimport {SiloStorageLib} from \"./SiloStorageLib.sol\";\n\n// solhint-disable ordering\n\nlibrary Views {\n    uint256 internal constant _100_PERCENT = 1e18;\n\n    bytes32 internal constant _FLASHLOAN_CALLBACK = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    function isSolvent(address _borrower) external view returns (bool) {\n        (\n            ISiloConfig.ConfigData memory collateral,\n            ISiloConfig.ConfigData memory debt\n        ) = ShareTokenLib.siloConfig().getConfigsForSolvency(_borrower);\n\n        return SiloSolvencyLib.isSolvent(collateral, debt, _borrower, ISilo.AccrueInterestInMemory.Yes);\n    }\n\n    /// @notice Returns flash fee amount\n    /// @param _token for which fee is calculated\n    /// @param _amount for which fee is calculated\n    /// @return fee flash fee amount\n    function flashFee(address _token, uint256 _amount) external view returns (uint256 fee) {\n        fee = SiloStdLib.flashFee(ShareTokenLib.siloConfig(), _token, _amount);\n    }\n\n    function maxFlashLoan(address _token) internal view returns (uint256 maxLoan) {\n        if (_token != ShareTokenLib.siloConfig().getAssetForSilo(address(this))) return 0;\n\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n        uint256 protectedAssets = $.totalAssets[ISilo.AssetType.Protected];\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        unchecked {\n            // we check underflow ourself\n            return balance > protectedAssets ? balance - protectedAssets : 0;\n        }\n    }\n\n    function maxBorrow(address _borrower)\n        external\n        view\n        returns (uint256 maxAssets, uint256 maxShares)\n    {\n        return SiloLendingLib.maxBorrow(_borrower);\n    }\n\n    function maxWithdraw(address _owner, ISilo.CollateralType _collateralType)\n        external\n        view\n        returns (uint256 assets, uint256 shares)\n    {\n        return SiloERC4626Lib.maxWithdraw(\n            _owner,\n            _collateralType,\n            // 0 for CollateralType.Collateral because it will be calculated internally\n            _collateralType == ISilo.CollateralType.Protected\n                ? SiloStorageLib.getSiloStorage().totalAssets[ISilo.AssetType.Protected]\n                : 0\n        );\n    }\n\n    function maxRepay(address _borrower) external view returns (uint256 assets) {\n        ISiloConfig.ConfigData memory configData = ShareTokenLib.getConfig();\n        uint256 shares = IShareToken(configData.debtShareToken).balanceOf(_borrower);\n\n        (uint256 totalSiloAssets, uint256 totalShares) =\n            SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(configData, ISilo.AssetType.Debt);\n\n        return SiloMathLib.convertToAssets(\n            shares, totalSiloAssets, totalShares, Rounding.MAX_REPAY_TO_ASSETS, ISilo.AssetType.Debt\n        );\n    }\n\n    function getSiloStorage()\n        internal\n        view\n        returns (\n            uint192 daoAndDeployerRevenue,\n            uint64 interestRateTimestamp,\n            uint256 protectedAssets,\n            uint256 collateralAssets,\n            uint256 debtAssets\n        )\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        daoAndDeployerRevenue = $.daoAndDeployerRevenue;\n        interestRateTimestamp = $.interestRateTimestamp;\n        protectedAssets = $.totalAssets[ISilo.AssetType.Protected];\n        collateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n        debtAssets = $.totalAssets[ISilo.AssetType.Debt];\n    }\n\n    function getFractionsStorage() internal view returns (ISilo.Fractions memory fractions) {\n        fractions = SiloStorageLib.getSiloStorage().fractions;\n    }\n\n    function utilizationData() internal view returns (ISilo.UtilizationData memory) {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        return ISilo.UtilizationData({\n            collateralAssets: $.totalAssets[ISilo.AssetType.Collateral],\n            debtAssets: $.totalAssets[ISilo.AssetType.Debt],\n            interestRateTimestamp: $.interestRateTimestamp\n        });\n    }\n\n    function getDebtAssets() internal view returns (uint256 totalDebtAssets) {\n        ISiloConfig.ConfigData memory thisSiloConfig = ShareTokenLib.getConfig();\n\n        totalDebtAssets = SiloStdLib.getTotalDebtAssetsWithInterest(\n            thisSiloConfig.silo, thisSiloConfig.interestRateModel\n        );\n    }\n\n    function getCollateralAndProtectedAssets()\n        internal\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalProtectedAssets)\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n        totalProtectedAssets = $.totalAssets[ISilo.AssetType.Protected];\n    }\n\n    function getCollateralAndDebtAssets()\n        internal\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalDebtAssets)\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n        totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n    }\n\n    function copySiloConfig(\n        ISiloConfig.InitData memory _initData,\n        ISiloFactory.Range memory _daoFeeRange,\n        uint256 _maxDeployerFee,\n        uint256 _maxFlashloanFee,\n        uint256 _maxLiquidationFee\n    )\n        internal\n        view\n        returns (ISiloConfig.ConfigData memory configData0, ISiloConfig.ConfigData memory configData1)\n    {\n        validateSiloInitData(_initData, _daoFeeRange, _maxDeployerFee, _maxFlashloanFee, _maxLiquidationFee);\n\n        configData0.hookReceiver = _initData.hookReceiver;\n        configData0.token = _initData.token0;\n        configData0.solvencyOracle = _initData.solvencyOracle0;\n        // If maxLtv oracle is not set, fallback to solvency oracle\n        configData0.maxLtvOracle = _initData.maxLtvOracle0 == address(0)\n            ? _initData.solvencyOracle0\n            : _initData.maxLtvOracle0;\n        configData0.interestRateModel = _initData.interestRateModel0;\n        configData0.maxLtv = _initData.maxLtv0;\n        configData0.lt = _initData.lt0;\n        configData0.liquidationTargetLtv = _initData.liquidationTargetLtv0;\n        configData0.deployerFee = _initData.deployerFee;\n        configData0.daoFee = _initData.daoFee;\n        configData0.liquidationFee = _initData.liquidationFee0;\n        configData0.flashloanFee = _initData.flashloanFee0;\n        configData0.callBeforeQuote = _initData.callBeforeQuote0;\n\n        configData1.hookReceiver = _initData.hookReceiver;\n        configData1.token = _initData.token1;\n        configData1.solvencyOracle = _initData.solvencyOracle1;\n        // If maxLtv oracle is not set, fallback to solvency oracle\n        configData1.maxLtvOracle = _initData.maxLtvOracle1 == address(0)\n            ? _initData.solvencyOracle1\n            : _initData.maxLtvOracle1;\n        configData1.interestRateModel = _initData.interestRateModel1;\n        configData1.maxLtv = _initData.maxLtv1;\n        configData1.lt = _initData.lt1;\n        configData1.liquidationTargetLtv = _initData.liquidationTargetLtv1;\n        configData1.deployerFee = _initData.deployerFee;\n        configData1.daoFee = _initData.daoFee;\n        configData1.liquidationFee = _initData.liquidationFee1;\n        configData1.flashloanFee = _initData.flashloanFee1;\n        configData1.callBeforeQuote = _initData.callBeforeQuote1;\n    }\n\n    // solhint-disable-next-line code-complexity, function-max-lines\n    function validateSiloInitData(\n        ISiloConfig.InitData memory _initData,\n        ISiloFactory.Range memory _daoFeeRange,\n        uint256 _maxDeployerFee,\n        uint256 _maxFlashloanFee,\n        uint256 _maxLiquidationFee\n    ) internal view returns (bool) {\n        require(_initData.hookReceiver != address(0), ISiloFactory.MissingHookReceiver());\n\n        require(_initData.token0 != address(0), ISiloFactory.EmptyToken0());\n        require(_initData.token1 != address(0), ISiloFactory.EmptyToken1());\n\n        require(_initData.token0 != _initData.token1, ISiloFactory.SameAsset());\n        require(_initData.maxLtv0 != 0 || _initData.maxLtv1 != 0, ISiloFactory.InvalidMaxLtv());\n        require(_initData.maxLtv0 <= _initData.lt0, ISiloFactory.InvalidMaxLtv());\n        require(_initData.maxLtv1 <= _initData.lt1, ISiloFactory.InvalidMaxLtv());\n        require(_initData.liquidationFee0 <= _maxLiquidationFee, ISiloFactory.MaxLiquidationFeeExceeded());\n        require(_initData.liquidationFee1 <= _maxLiquidationFee, ISiloFactory.MaxLiquidationFeeExceeded());\n        require(_initData.lt0 + _initData.liquidationFee0 <= _100_PERCENT, ISiloFactory.InvalidLt());\n        require(_initData.lt1 + _initData.liquidationFee1 <= _100_PERCENT, ISiloFactory.InvalidLt());\n\n        require(\n            _initData.maxLtvOracle0 == address(0) || _initData.solvencyOracle0 != address(0),\n            ISiloFactory.OracleMisconfiguration()\n        );\n\n        require(\n            !_initData.callBeforeQuote0 || _initData.solvencyOracle0 != address(0),\n            ISiloFactory.InvalidCallBeforeQuote()\n        );\n\n        require(\n            _initData.maxLtvOracle1 == address(0) || _initData.solvencyOracle1 != address(0),\n            ISiloFactory.OracleMisconfiguration()\n        );\n\n        require(\n            !_initData.callBeforeQuote1 || _initData.solvencyOracle1 != address(0),\n            ISiloFactory.InvalidCallBeforeQuote()\n        );\n\n        verifyQuoteTokens(_initData);\n\n        require(_initData.deployerFee == 0 || _initData.deployer != address(0), ISiloFactory.InvalidDeployer());\n        require(_initData.deployerFee <= _maxDeployerFee, ISiloFactory.MaxDeployerFeeExceeded());\n        require(_daoFeeRange.min <= _initData.daoFee, ISiloFactory.DaoMinRangeExceeded());\n        require(_initData.daoFee <= _daoFeeRange.max, ISiloFactory.DaoMaxRangeExceeded());\n        require(_initData.flashloanFee0 <= _maxFlashloanFee, ISiloFactory.MaxFlashloanFeeExceeded());\n        require(_initData.flashloanFee1 <= _maxFlashloanFee, ISiloFactory.MaxFlashloanFeeExceeded());\n        require(_initData.liquidationTargetLtv0 <= _initData.lt0, ISiloFactory.LiquidationTargetLtvTooHigh());\n        require(_initData.liquidationTargetLtv1 <= _initData.lt1, ISiloFactory.LiquidationTargetLtvTooHigh());\n\n        require(\n            _initData.interestRateModel0 != address(0) && _initData.interestRateModel1 != address(0),\n            ISiloFactory.InvalidIrm()\n        );\n\n        return true;\n    }\n\n    function verifyQuoteTokens(ISiloConfig.InitData memory _initData) internal view {\n        address expectedQuoteToken;\n\n        expectedQuoteToken = verifyQuoteToken(expectedQuoteToken, _initData.solvencyOracle0);\n        expectedQuoteToken = verifyQuoteToken(expectedQuoteToken, _initData.maxLtvOracle0);\n        expectedQuoteToken = verifyQuoteToken(expectedQuoteToken, _initData.solvencyOracle1);\n        expectedQuoteToken = verifyQuoteToken(expectedQuoteToken, _initData.maxLtvOracle1);\n    }\n\n    function verifyQuoteToken(address _expectedQuoteToken, address _oracle)\n        internal\n        view\n        returns (address quoteToken)\n    {\n        if (_oracle == address(0)) return _expectedQuoteToken;\n\n        quoteToken = ISiloOracle(_oracle).quoteToken();\n\n        if (_expectedQuoteToken == address(0)) return quoteToken;\n        require(_expectedQuoteToken == quoteToken, ISiloFactory.InvalidQuoteToken());\n    }\n}\n"
    },
    "common/utils/Create2Factory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Nonces} from \"openzeppelin5/utils/Nonces.sol\";\n\ncontract Create2Factory is Nonces {\n    function _salt() internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender)\n        ));\n    }\n\n    function _salt(bytes32 _externalSalt) internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender),\n            _externalSalt\n        ));\n    }\n\n    function _createSalt(address _deployer, bytes32 _externalSalt) internal view returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            _deployer,\n            nonces(_deployer),\n            _externalSalt\n        ));\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
    },
    "silo-core/contracts/interfaces/ISilo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC4626, IERC20} from \"openzeppelin5/interfaces/IERC4626.sol\";\n\nimport {IERC3156FlashLender} from \"./IERC3156FlashLender.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\nimport {ISiloFactory} from \"./ISiloFactory.sol\";\n\n// solhint-disable ordering\ninterface ISilo is IERC20, IERC4626, IERC3156FlashLender {\n    /// @dev Interest accrual happens on each deposit/withdraw/borrow/repay. View methods work on storage that might be\n    ///      outdate. Some calculations require accrued interest to return current state of Silo. This struct is used\n    ///      to make a decision inside functions if interest should be accrued in memory to work on updated values.\n    enum AccrueInterestInMemory {\n        No,\n        Yes\n    }\n\n    /// @dev Silo has two separate oracles for solvency and maxLtv calculations. MaxLtv oracle is optional. Solvency\n    ///      oracle can also be optional if asset is used as denominator in Silo config. For example, in ETH/USDC Silo\n    ///      one could setup only solvency oracle for ETH that returns price in USDC. Then USDC does not need an oracle\n    ///      because it's used as denominator for ETH and it's \"price\" can be assume as 1.\n    enum OracleType {\n        Solvency,\n        MaxLtv\n    }\n\n    /// @dev There are 3 types of accounting in the system: for non-borrowable collateral deposit called \"protected\",\n    ///      for borrowable collateral deposit called \"collateral\" and for borrowed tokens called \"debt\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum AssetType {\n        Protected, // default\n        Collateral,\n        Debt\n    }\n\n    /// @dev There are 2 types of accounting in the system: for non-borrowable collateral deposit called \"protected\" and\n    ///      for borrowable collateral deposit called \"collateral\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum CollateralType {\n        Protected, // default\n        Collateral\n    }\n\n    /// @dev Types of calls that can be made by the hook receiver on behalf of Silo via `callOnBehalfOfSilo` fn\n    enum CallType {\n        Call, // default\n        Delegatecall\n    }\n\n    /// @param _assets Amount of assets the user wishes to withdraw. Use 0 if shares are provided.\n    /// @param _shares Shares the user wishes to burn in exchange for the withdrawal. Use 0 if assets are provided.\n    /// @param _receiver Address receiving the withdrawn assets\n    /// @param _owner Address of the owner of the shares being burned\n    /// @param _spender Address executing the withdrawal; may be different than `_owner` if an allowance was set\n    /// @param _collateralType Type of the asset being withdrawn (Collateral or Protected)\n    struct WithdrawArgs {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        ISilo.CollateralType collateralType;\n    }\n\n    /// @param assets Number of assets the borrower intends to borrow. Use 0 if shares are provided.\n    /// @param shares Number of shares corresponding to the assets that the borrower intends to borrow. Use 0 if\n    /// assets are provided.\n    /// @param receiver Address that will receive the borrowed assets\n    /// @param borrower The user who is borrowing the assets\n    struct BorrowArgs {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n    }\n\n    /// @param shares Amount of shares the user wishes to transit.\n    /// @param owner owner of the shares after transition.\n    /// @param transitionFrom type of collateral that will be transitioned.\n    struct TransitionCollateralArgs {\n        uint256 shares;\n        address owner;\n        ISilo.CollateralType transitionFrom;\n    }\n\n    struct UtilizationData {\n        /// @dev COLLATERAL: Amount of asset token that has been deposited to Silo plus interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        uint256 collateralAssets;\n        /// @dev DEBT: Amount of asset token that has been borrowed plus accrued interest.\n        uint256 debtAssets;\n        /// @dev timestamp of the last interest accrual\n        uint64 interestRateTimestamp;\n    }\n\n    /// @dev Interest and revenue may be rounded down to zero if the underlying token's decimal is low.\n    /// Because of that, we need to store fractions for further calculation to minimize losses.\n    struct Fractions {\n        /// @dev interest value that we could not convert to full token in 36 decimals, max value for it is 1e18.\n        /// this value was not yet apply as interest for borrowers\n        uint64 interest;\n        /// @dev revenue value that we could not convert to full token in 36 decimals, max value for it is 1e18.\n        uint64 revenue;\n    }\n\n    struct SiloStorage {\n        /// @param daoAndDeployerRevenue Current amount of assets (fees) accrued by DAO and Deployer\n        /// but not yet withdrawn\n        uint192 daoAndDeployerRevenue;\n        /// @dev timestamp of the last interest accrual\n        uint64 interestRateTimestamp;\n        /// @dev Interest and revenue fractions for more precise calculations\n        Fractions fractions;\n\n        /// @dev silo is just for one asset,\n        /// but this one asset can be of three types: mapping key is uint256(AssetType), so we store `assets` by type.\n        /// Assets based on type:\n        /// - PROTECTED COLLATERAL: Amount of asset token that has been deposited to Silo that can be ONLY used\n        /// as collateral. These deposits do NOT earn interest and CANNOT be borrowed.\n        /// - COLLATERAL: Amount of asset token that has been deposited to Silo plus interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        /// - DEBT: Amount of asset token that has been borrowed plus accrued interest.\n        /// `totalAssets` can have outdated value (without interest), if you doing view call (of off-chain call)\n        /// please use getters eg `getCollateralAssets()` to fetch value that includes interest.\n        mapping(AssetType assetType => uint256 assets) totalAssets;\n    }\n\n    /// @notice Emitted on protected deposit\n    /// @param sender wallet address that deposited asset\n    /// @param owner wallet address that received shares in Silo\n    /// @param assets amount of asset that was deposited\n    /// @param shares amount of shares that was minted\n    event DepositProtected(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @notice Emitted on protected withdraw\n    /// @param sender wallet address that sent transaction\n    /// @param receiver wallet address that received asset\n    /// @param owner wallet address that owned asset\n    /// @param assets amount of asset that was withdrew\n    /// @param shares amount of shares that was burn\n    event WithdrawProtected(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Emitted on borrow\n    /// @param sender wallet address that sent transaction\n    /// @param receiver wallet address that received asset\n    /// @param owner wallet address that owes assets\n    /// @param assets amount of asset that was borrowed\n    /// @param shares amount of shares that was minted\n    event Borrow(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Emitted on repayment\n    /// @param sender wallet address that repaid asset\n    /// @param owner wallet address that owed asset\n    /// @param assets amount of asset that was repaid\n    /// @param shares amount of shares that was burn\n    event Repay(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @notice emitted only when collateral has been switched to other one\n    event CollateralTypeChanged(address indexed borrower);\n\n    event HooksUpdated(uint24 hooksBefore, uint24 hooksAfter);\n\n    event AccruedInterest(uint256 hooksBefore);\n\n    event FlashLoan(uint256 amount);\n\n    event WithdrawnFees(uint256 daoFees, uint256 deployerFees, bool redirectedDeployerFees);\n\n    event DeployerFeesRedirected(uint256 deployerFees);\n\n    error UnsupportedFlashloanToken();\n    error FlashloanAmountTooBig();\n    error NothingToWithdraw();\n    error ProtectedProtection();\n    error NotEnoughLiquidity();\n    error NotSolvent();\n    error BorrowNotPossible();\n    error EarnedZero();\n    error FlashloanFailed();\n    error AboveMaxLtv();\n    error SiloInitialized();\n    error OnlyHookReceiver();\n    error NoLiquidity();\n    error InputCanBeAssetsOrShares();\n    error CollateralSiloAlreadySet();\n    error RepayTooHigh();\n    error ZeroAmount();\n    error InputZeroShares();\n    error ReturnZeroAssets();\n    error ReturnZeroShares();\n    error Deprecated();\n\n    /// @return siloFactory The associated factory of the silo\n    function factory() external view returns (ISiloFactory siloFactory);\n\n    /// @notice Method for HookReceiver only to call on behalf of Silo\n    /// @param _target address of the contract to call\n    /// @param _value amount of ETH to send\n    /// @param _callType type of the call (Call or Delegatecall)\n    /// @param _input calldata for the call\n    function callOnBehalfOfSilo(address _target, uint256 _value, CallType _callType, bytes calldata _input)\n        external\n        payable\n        returns (bool success, bytes memory result);\n\n    /// @notice Initialize Silo\n    /// @param _siloConfig address of ISiloConfig with full config for this Silo\n    function initialize(ISiloConfig _siloConfig) external;\n\n    /// @notice Update hooks configuration for Silo\n    /// @dev This function must be called after the hooks configuration is changed in the hook receiver\n    function updateHooks() external;\n\n    /// @notice Fetches the silo configuration contract\n    /// @return siloConfig Address of the configuration contract associated with the silo\n    function config() external view returns (ISiloConfig siloConfig);\n\n    /// @notice Fetches the utilization data of the silo used by IRM\n    function utilizationData() external view returns (UtilizationData memory utilizationData);\n\n    /// @notice Fetches the real (available to borrow) liquidity in the silo, it does include interest\n    /// @return liquidity The amount of liquidity\n    function getLiquidity() external view returns (uint256 liquidity);\n\n    /// @notice Determines if a borrower is solvent\n    /// @param _borrower Address of the borrower to check for solvency\n    /// @return True if the borrower is solvent, otherwise false\n    function isSolvent(address _borrower) external view returns (bool);\n\n    /// @notice Retrieves the raw total amount of assets based on provided type (direct storage access)\n    function getTotalAssetsStorage(AssetType _assetType) external view returns (uint256);\n\n    /// @notice Direct storage access to silo storage\n    /// @dev See struct `SiloStorage` for more details\n    function getSiloStorage()\n        external\n        view\n        returns (\n            uint192 daoAndDeployerRevenue,\n            uint64 interestRateTimestamp,\n            uint256 protectedAssets,\n            uint256 collateralAssets,\n            uint256 debtAssets\n        );\n\n    /// @notice Direct access to silo storage fractions variables\n    function getFractionsStorage() external view returns (Fractions memory fractions);\n\n    /// @notice Retrieves the total amount of collateral (borrowable) assets with interest\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    function getCollateralAssets() external view returns (uint256 totalCollateralAssets);\n\n    /// @notice Retrieves the total amount of debt assets with interest\n    /// @return totalDebtAssets The total amount of assets of type 'Debt'\n    function getDebtAssets() external view returns (uint256 totalDebtAssets);\n\n    /// @notice Retrieves the total amounts of collateral and protected (non-borrowable) assets\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    /// @return totalProtectedAssets The total amount of protected (non-borrowable) assets\n    function getCollateralAndProtectedTotalsStorage()\n        external\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalProtectedAssets);\n\n    /// @notice Retrieves the total amounts of collateral and debt assets\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    /// @return totalDebtAssets The total amount of debt assets of type 'Debt'\n    function getCollateralAndDebtTotalsStorage()\n        external\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalDebtAssets);\n\n    /// @notice Implements IERC4626.convertToShares for each asset type\n    function convertToShares(uint256 _assets, AssetType _assetType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.convertToAssets for each asset type\n    function convertToAssets(uint256 _shares, AssetType _assetType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.previewDeposit for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewDeposit(uint256 _assets, CollateralType _collateralType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.deposit for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function deposit(uint256 _assets, address _receiver, CollateralType _collateralType)\n        external\n        returns (uint256 shares);\n\n    /// @notice Implements IERC4626.previewMint for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewMint(uint256 _shares, CollateralType _collateralType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.mint for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function mint(uint256 _shares, address _receiver, CollateralType _collateralType) external returns (uint256 assets);\n\n    /// @notice Implements IERC4626.maxWithdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function maxWithdraw(address _owner, CollateralType _collateralType) external view returns (uint256 maxAssets);\n\n    /// @notice Implements IERC4626.previewWithdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewWithdraw(uint256 _assets, CollateralType _collateralType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.withdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function withdraw(uint256 _assets, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        returns (uint256 shares);\n\n    /// @notice Implements IERC4626.maxRedeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function maxRedeem(address _owner, CollateralType _collateralType) external view returns (uint256 maxShares);\n\n    /// @notice Implements IERC4626.previewRedeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewRedeem(uint256 _shares, CollateralType _collateralType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.redeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function redeem(uint256 _shares, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        returns (uint256 assets);\n\n    /// @notice Calculates the maximum amount of assets that can be borrowed by the given address\n    /// @param _borrower Address of the potential borrower\n    /// @return maxAssets Maximum amount of assets that the borrower can borrow, this value is underestimated\n    /// That means, in some cases when you borrow maxAssets, you will be able to borrow again eg. up to 2wei\n    /// Reason for underestimation is to return value that will not cause borrow revert\n    function maxBorrow(address _borrower) external view returns (uint256 maxAssets);\n\n    /// @notice Previews the amount of shares equivalent to the given asset amount for borrowing\n    /// @param _assets Amount of assets to preview the equivalent shares for\n    /// @return shares Amount of shares equivalent to the provided asset amount\n    function previewBorrow(uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Allows an address to borrow a specified amount of assets\n    /// @param _assets Amount of assets to borrow\n    /// @param _receiver Address receiving the borrowed assets\n    /// @param _borrower Address responsible for the borrowed assets\n    /// @return shares Amount of shares equivalent to the borrowed assets\n    function borrow(uint256 _assets, address _receiver, address _borrower)\n        external returns (uint256 shares);\n\n    /// @notice Calculates the maximum amount of shares that can be borrowed by the given address\n    /// @param _borrower Address of the potential borrower\n    /// @return maxShares Maximum number of shares that the borrower can borrow\n    function maxBorrowShares(address _borrower) external view returns (uint256 maxShares);\n\n    /// @notice Previews the amount of assets equivalent to the given share amount for borrowing\n    /// @param _shares Amount of shares to preview the equivalent assets for\n    /// @return assets Amount of assets equivalent to the provided share amount\n    function previewBorrowShares(uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice deprecated\n    function maxBorrowSameAsset(address _borrower) external view returns (uint256 maxAssets);\n\n    /// @notice deprecated\n    function borrowSameAsset(uint256 _assets, address _receiver, address _borrower)\n        external returns (uint256 shares);\n\n    /// @notice Allows a user to borrow assets based on the provided share amount\n    /// @param _shares Amount of shares to borrow against\n    /// @param _receiver Address to receive the borrowed assets\n    /// @param _borrower Address responsible for the borrowed assets\n    /// @return assets Amount of assets borrowed\n    function borrowShares(uint256 _shares, address _receiver, address _borrower)\n        external\n        returns (uint256 assets);\n\n    /// @notice Calculates the maximum amount an address can repay based on their debt shares\n    /// @param _borrower Address of the borrower\n    /// @return assets Maximum amount of assets the borrower can repay\n    function maxRepay(address _borrower) external view returns (uint256 assets);\n\n    /// @notice Provides an estimation of the number of shares equivalent to a given asset amount for repayment\n    /// @param _assets Amount of assets to be repaid\n    /// @return shares Estimated number of shares equivalent to the provided asset amount\n    function previewRepay(uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Repays a given asset amount and returns the equivalent number of shares\n    /// @param _assets Amount of assets to be repaid\n    /// @param _borrower Address of the borrower whose debt is being repaid\n    /// @return shares The equivalent number of shares for the provided asset amount\n    function repay(uint256 _assets, address _borrower) external returns (uint256 shares);\n\n    /// @notice Calculates the maximum number of shares that can be repaid for a given borrower\n    /// @param _borrower Address of the borrower\n    /// @return shares The maximum number of shares that can be repaid for the borrower\n    function maxRepayShares(address _borrower) external view returns (uint256 shares);\n\n    /// @notice Provides a preview of the equivalent assets for a given number of shares to repay\n    /// @param _shares Number of shares to preview repayment for\n    /// @return assets Equivalent assets for the provided shares\n    function previewRepayShares(uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice Allows a user to repay a loan using shares instead of assets\n    /// @param _shares The number of shares the borrower wants to repay with\n    /// @param _borrower The address of the borrower for whom to repay the loan\n    /// @return assets The equivalent assets amount for the provided shares\n    function repayShares(uint256 _shares, address _borrower) external returns (uint256 assets);\n\n    /// @notice Transitions assets between borrowable (collateral) and non-borrowable (protected) states\n    /// @dev This function allows assets to move between collateral and protected (non-borrowable) states without\n    /// leaving the protocol\n    /// @param _shares Amount of shares to be transitioned\n    /// @param _owner Owner of the assets being transitioned\n    /// @param _transitionFrom Specifies if the transition is from collateral or protected assets\n    /// @return assets Amount of assets transitioned\n    function transitionCollateral(uint256 _shares, address _owner, CollateralType _transitionFrom)\n        external\n        returns (uint256 assets);\n\n    /// @notice deprecated\n    function switchCollateralToThisSilo() external;\n\n    /// @notice Accrues interest for the asset and returns the accrued interest amount\n    /// @return accruedInterest The total interest accrued during this operation\n    function accrueInterest() external returns (uint256 accruedInterest);\n\n    /// @notice only for SiloConfig\n    function accrueInterestForConfig(\n        address _interestRateModel,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    ) external;\n\n    /// @notice Withdraws earned fees and distributes them to the DAO and deployer fee receivers\n    function withdrawFees() external;\n}\n"
    },
    "silo-core/contracts/interfaces/ICrossReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ICrossReentrancyGuard {\n    error CrossReentrantCall();\n    error CrossReentrancyNotActive();\n\n    /// @notice only silo method for cross Silo reentrancy\n    function turnOnReentrancyProtection() external;\n\n    /// @notice only silo method for cross Silo reentrancy\n    function turnOffReentrancyProtection() external;\n\n    /// @notice view method for checking cross Silo reentrancy flag\n    /// @return entered true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n    /// `nonReentrant` function in the call stack.\n    function reentrancyGuardEntered() external view returns (bool entered);\n}"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "silo-core/contracts/interfaces/IDynamicKinkModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IDynamicKinkModelConfig} from \"./IDynamicKinkModelConfig.sol\";\n\n/// @title IDynamicKinkModel\n/// @notice Interface for the Dynamic Kink Interest Rate Model\n/// @dev This interface defines an adaptive interest rate model that dynamically adjusts rates based on market\n///      utilization.\n///      The model uses a \"kink\" mechanism where interest rates change more aggressively as utilization increases.\n///      Unlike static models, this implementation adapts over time to market conditions.\n/// \n///      Key Features:\n///      - Dynamic rate adjustment based on utilization thresholds\n///      - Time-based rate evolution to prevent sudden spikes\n///      - Configurable parameters for different market conditions\n///      - Compound interest calculation for accurate accrual\n/// \n///      The model operates with several utilization zones:\n///      - Low utilization (0 to ulow): Minimal rates to encourage borrowing\n///      - Optimal range (u1 to u2): Stable rates for normal operations  \n///      - High utilization (u2 to ucrit): Increasing rates to manage risk\n///      - Critical utilization (ucrit to 1e18): Maximum rates\ninterface IDynamicKinkModel {\n    /// @notice User-friendly configuration structure for setting up the Dynamic Kink Model\n    /// @dev This structure provides intuitive parameters that are converted to internal model parameters.\n    ///      All utilization values are in 18 decimals (e.g., 0.5e18 = 50% utilization).\n    ///      All time values are in seconds.\n    /// \n    /// @param ulow Utilization threshold below which rates are minimal\n    /// @param ucrit Critical utilization threshold where rates become very high\n    /// @param u1 lower bound of optimal utilization range (the model is static when utilization is in this interval).\n    /// @param u2 upper bound of optimal utilization range (the model is static when utilization is in this interval).\n    /// @param rmin Minimal per-second interest rate (minimal APR), active below ulow.\n    /// @param rcritMin Minimal APR that the model can output at the critical utilization ucrit\n    /// @param rcritMax Maximal APR that the model can output at the critical utilization ucrit\n    /// @param r100 Maximum possible per-second rate at 100% utilization\n    /// @param t1 Time in seconds for rate to decrease from max to min at u1 utilization\n    /// @param t2 Time in seconds for rate to increase from min to max at u2 utilization\n    /// @param tlow Time in seconds to reset rates when utilization drops to ulow\n    /// @param tcrit Time in seconds for rate to increase from min to max at critical utilization\n    /// @param tMin minimal time it takes to grow from the minimal to the maximal APR at any utilization\n    struct UserFriendlyConfig {\n        uint64 ulow;\n        uint64 ucrit;\n        uint64 u1;\n        uint64 u2;\n        uint72 rmin;\n        uint72 rcritMin;\n        uint72 rcritMax;\n        uint72 r100;\n        uint32 t1;\n        uint32 t2;\n        uint32 tlow;\n        uint32 tcrit;\n        uint32 tMin;\n    }\n\n    /// @dev same as UserFriendlyConfig but with int256 values to help with calculations\n    struct UserFriendlyConfigInt {\n        int256 ulow;\n        int256 ucrit;\n        int256 u1;\n        int256 u2;\n        int256 rmin;\n        int256 rcritMin;\n        int256 rcritMax;\n        int256 r100;\n        int256 t1;\n        int256 t2;\n        int256 tlow;\n        int256 tcrit;\n        int256 tMin;\n    }\n\n    /// @notice Internal configuration structure used by the model for calculations\n    /// @dev These values are used in the mathematical calculations of the interest rate model.\n    ///     Utilization values are in 18 decimals 1e18 = 100%.\n    /// @param ulow ulow ∈ [0, 1e18) Low utilization threshold\n    /// @param u1 u1 ∈ [0, 1e18) Lower bound of optimal utilization range\n    /// @param u2 u2 ∈ [u1, 1e18) Upper bound of optimal utilization range\n    /// @param ucrit ucrit ∈ [ulow, 1e18) Critical utilization threshold\n    /// @param rmin rmin >= 0 Minimal per-second interest rate\n    /// @param kmin kmin >= 0 Minimal slope k of central segment (curve) of the kink\n    /// @param kmax kmax >= kmin Maximal slope k of central segment (curve) of the kink\n    /// @param alpha alpha >= 0 Factor controlling the slope for the critical segment of the kink\n    /// @param cminus cminus >= 0 Coefficient of decrease of the slope k\n    /// @param cplus cplus >= 0 Coefficient for increasing the slope k\n    /// @param c1 c1 >= 0 Minimal rate of decrease of the slope k\n    /// @param c2 c2 >= 0 Minimal growth rate of the slope k\n    /// @param dmax dmax >= 0 Maximum growth rate of the slope k\n    struct Config {\n        int256 ulow;\n        int256 u1;\n        int256 u2;\n        int256 ucrit;\n        int256 rmin;\n        int96 kmin;\n        int96 kmax;\n        int256 alpha;\n        int256 cminus;\n        int256 cplus;\n        int256 c1;\n        int256 c2;\n        int256 dmax;\n    }\n\n    struct ImmutableArgs {\n        uint32 timelock;\n        int96 rcompCap;\n    }\n\n    struct ImmutableConfig {\n        uint32 timelock;\n        int96 rcompCapPerSecond;\n    }\n\n    /// @notice Internal variables used during compound interest calculations\n    /// @dev This structure contains temporary variables used in the mathematical calculations.\n    ///      Integrators typically don't need to interact with these values directly.\n    /// \n    /// @param T Time elapsed since the last interest rate update (in seconds)\n    /// @param k1 Internal variable for slope calculations\n    /// @param f Factor used in kink slope calculations\n    /// @param roc Rate of change variable for slope calculations\n    /// @param x Internal calculation variable\n    /// @param interest Absolute value of compounded interest\n    struct LocalVarsRCOMP {\n        int256 T;\n        int256 k1;\n        int256 f;\n        int256 roc;\n        int256 x;\n        int256 interest;\n    }\n\n    struct CompoundInterestRateArgs {\n        address silo;\n        uint256 collateralAssets;\n        uint256 debtAssets;\n        uint256 interestRateTimestamp;\n        uint256 blockTimestamp;\n        bool usePending;\n    }\n\n    /// @notice Current state of the Dynamic Kink Model\n    /// @dev This structure tracks the current state of the model, including the dynamic slope value\n    ///      that changes over time based on utilization patterns.\n    /// \n    /// @param k Current slope value of the kink curve (changes dynamically over time)\n    /// @param silo Address of the Silo contract this model is associated with\n    struct ModelState {\n        int96 k;\n        address silo;\n    }\n\n    struct History {\n        int96 k;\n        IDynamicKinkModelConfig irmConfig;\n    }\n\n    /// @notice Emitted when the model is initialized with a new configuration\n    /// @param owner Address that will own this model instance\n    /// @param silo Address of the Silo contract this model is associated with\n    event Initialized(address indexed owner, address indexed silo);\n\n    /// @notice Emitted when a new configuration is set for the model\n    /// @param config The new configuration contract address\n    /// @param activeAt Timestamp at which the configuration becomes active\n    event NewConfig(IDynamicKinkModelConfig indexed config, uint256 activeAt);\n\n    /// @notice Emitted when a pending configuration update is canceled\n    /// @param config The canceled configuration contract address\n    event PendingUpdateConfigCanceled(IDynamicKinkModelConfig indexed config);\n\n    error AddressZero();\n    error AlphaDividerZero();\n    error AlreadyInitialized();\n    error EmptySilo();\n    error InvalidAlpha();\n    error InvalidC1();\n    error InvalidC2();\n    error InvalidCminus();\n    error InvalidCplus();\n    error InvalidDefaultConfig();\n    error InvalidDmax();\n    error InvalidKmax();\n    error InvalidKmin();\n    error InvalidKRange();\n    error InvalidRcompCap();\n    error InvalidRcritMax();\n    error InvalidRcritMin();\n    error InvalidRmin();\n    error InvalidSilo();\n    error InvalidT1();\n    error InvalidT2();\n    error InvalidTimelock();\n    error InvalidTimestamp();\n    error InvalidTMin();\n    error InvalidTLow();\n    error InvalidTCrit();\n    error InvalidU1();\n    error InvalidU2();\n    error InvalidUcrit();\n    error InvalidUlow();\n    error NegativeRcomp();\n    error NegativeRcur();\n    error NoPendingUpdateToCancel();\n    error NoPendingConfig();\n    error OnlySilo();\n    error PendingUpdate();\n    error XOverflow();\n\n    /// @notice Initialize the Dynamic Kink Model with configuration and ownership\n    /// @dev This function sets up the model for a specific Silo contract. Can only be called once.\n    /// @param _config The configuration parameters for the interest rate model\n    /// @param _immutableArgs The immutable configuration parameters for the interest rate model\n    /// @param _initialOwner Address that will own and control this model instance\n    /// @param _silo Address of the Silo contract this model will serve\n    function initialize(\n        IDynamicKinkModel.Config calldata _config, \n        IDynamicKinkModel.ImmutableArgs calldata _immutableArgs, \n        address _initialOwner, \n        address _silo\n    ) \n        external;\n\n    /// @notice Update the model configuration\n    /// @dev This function allows the model owner to update the configuration of the model.\n    ///      By setting the same config, we can reset k to kmin.\n    /// @param _config The new configuration parameters for the interest rate model\n    function updateConfig(IDynamicKinkModel.Config calldata _config) external;\n\n    /// @notice Cancel the pending configuration update\n    /// @dev This function allows the model owner to cancel the pending configuration update.\n    ///      It will revert if there is no pending update.\n    function cancelPendingUpdateConfig() external;\n\n    /// @notice Calculate compound interest rate and update the model's internal state\n    /// @dev This function is the primary method used by Silo contracts to calculate\n    ///      and accrue interest. Unlike getCompoundInterestRate(), this function\n    ///      modifies the model's internal state by updating the dynamic slope value (k).\n    /// \n    ///      This function should only be called by the associated Silo contract,\n    ///      as it performs state updates that affect future interest calculations.\n    ///      It includes comprehensive overflow protection and gracefully handles\n    ///      calculation errors by returning 0 and resetting the slope to minimum.\n    /// \n    ///      The function calculates interest based on:\n    ///      - Current collateral and debt amounts\n    ///      - Time elapsed since last interest rate update\n    ///      - Dynamic slope adjustments based on utilization patterns\n    /// \n    /// @param _collateralAssets Total collateral assets in the Silo (in asset units)\n    /// @param _debtAssets Total debt assets in the Silo (in asset units)\n    /// @param _interestRateTimestamp Timestamp of the last interest rate update\n    /// @return rcomp Total compound interest multiplier (in 18 decimals, represents total accrued interest)\n    /// @custom:throws OnlySilo() if called by any address other than the associated Silo contract\n    function getCompoundInterestRateAndUpdate(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _interestRateTimestamp\n    )\n        external\n        returns (uint256 rcomp);\n    \n    function configsHistory(IDynamicKinkModelConfig _irmConfig) \n        external \n        view \n        returns (int96 k, IDynamicKinkModelConfig irmConfig);\n\n    /// @notice Get the current (active) configuration contract for this model\n    /// @return config The IDynamicKinkModelConfig contract containing the model parameters\n    function irmConfig() external view returns (IDynamicKinkModelConfig config);\n\n    /// @notice Get the current (active) model state\n    function modelState() external view returns (ModelState memory state);\n    \n    /// @notice Get both the current model state and configuration\n    /// @param _usePending Whether to use the pending configuration to pull config from\n    /// @return state Current state of the model (including dynamic slope value)\n    /// @return config configuration parameters, either active or pending, depending on _usePending\n    /// @return immutableConfig Immutable configuration parameters\n    function getModelStateAndConfig(bool _usePending) \n        external \n        view \n        returns (ModelState memory state, Config memory config, ImmutableConfig memory immutableConfig);\n\n    /// @notice Maximum compound interest rate per second (prevents extreme rates)\n    /// @return cap Maximum per-second compound interest rate in 18 decimals\n    function RCOMP_CAP_PER_SECOND() external view returns (int256 cap); // solhint-disable-line func-name-mixedcase\n    \n    /// @notice Maximum current interest rate (prevents extreme APRs)\n    /// @return cap Maximum annual interest rate in 18 decimals (e.g., 25e18 = 2500% APR)\n    function RCUR_CAP() external view returns (int256 cap); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Number of seconds in one year (used for rate calculations)\n    /// @return secondsInYear Seconds in one year (365 days)\n    function ONE_YEAR() external view returns (int256 secondsInYear); // solhint-disable-line func-name-mixedcase\n    \n    /// @notice Maximum input value for exponential calculations (prevents overflow)\n    /// @return max Maximum safe input value for exp() function\n    function X_MAX() external view returns (int256 max); // solhint-disable-line func-name-mixedcase\n    \n    /// @notice Universal limit for various model parameters\n    /// @return limit Maximum allowed value for certain configuration parameters\n    function UNIVERSAL_LIMIT() external view returns (int256 limit); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Maximum time lock for configuration changes\n    /// @return maxTimeLock Maximum time lock for configuration changes\n    function MAX_TIMELOCK() external view returns (uint32 maxTimeLock); // solhint-disable-line func-name-mixedcase\n\n    /// @return timestamp Timestamp at which the pending configuration becomes active\n    function activateConfigAt() external view returns (uint256 timestamp);\n\n    /// @return pendingIrmConfig Pending irm config for configuration changes, 0 if no pending\n    function pendingIrmConfig() external view returns (address pendingIrmConfig);\n\n    /// @notice Validate that configuration parameters are within acceptable limits\n    /// @dev This function checks if all configuration parameters are within the safe operating ranges\n    ///      defined by the model whitepaper. Some limits are narrower than the original whitepaper\n    ///      due to additional research and safety considerations.\n    /// \n    ///      For detailed limits, see:\n    ///      https://silofinance.atlassian.net/wiki/spaces/SF/pages/347963393/DynamicKink+model+config+limits+V1\n    /// \n    /// @param _config The configuration to validate (does not include model state)\n    /// @custom:throws Reverts if any parameter is outside acceptable limits\n    function verifyConfig(IDynamicKinkModel.Config calldata _config) external view;\n\n    /// @notice Calculate compound interest rate for a specific Silo at a given timestamp\n    /// @dev This function calculates the total compound interest that has accrued over time\n    ///      for a specific Silo contract.\n    /// \n    ///      The function fetches current utilization data from the Silo contract and\n    ///      calculates interest based on the time elapsed since the last rate update.\n    ///      It handles overflow protection and returns 0 if calculations would overflow.\n    /// \n    /// @param _silo Address of the Silo contract to calculate interest for\n    /// @param _blockTimestamp Timestamp to calculate interest up to (usually block.timestamp)\n    /// @return rcomp Total compound interest multiplier (in 18 decimals, represents total accrued interest)\n    /// @custom:throws InvalidSilo() if the provided Silo address doesn't match this model's associated Silo\n    function getCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcomp);\n\n    /// @notice Same as getCompoundInterestRate but uses pending configuration, throws if no pending\n    function getPendingCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcomp);\n\n    /// @notice get current annual interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp timestamp to calculate interest up to (usually block.timestamp)\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function getCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcur);\n\n    /// @notice Same as getCurrentInterestRate but uses pending configuration, throws if no pending\n    function getPendingCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcur);\n\n    /// @notice Calculate the compound interest rate for a given time period\n    /// @dev This function calculates how much interest has accrued over a time period,\n    ///      taking into account the dynamic nature of the kink model. The rate changes\n    ///      over time based on utilization patterns and the model's adaptive behavior.\n    /// \n    ///      This is the core function used by Silo contracts to determine how much\n    ///      interest borrowers owe and how much lenders should receive.\n    /// \n    /// @param _cfg Model configuration parameters\n    /// @param _state Current model state (including dynamic slope value)\n    /// @param _rcompCapPerSecond Maximum compound interest rate per second\n    /// @param _t0 Timestamp of the last interest rate update\n    /// @param _t1 Current timestamp for the calculation\n    /// @param _u Utilization ratio at time _t0 (0 to 1e18, where 1e18 = 100% utilized)\n    /// @param _tba Total borrowed amount at time _t1\n    /// @return rcomp Total compound interest accrued over the time period (in 18 decimals, represents multiplier)\n    /// @return k Updated model state (new slope value) at time _t1\n    function compoundInterestRate(\n        Config memory _cfg,\n        ModelState memory _state,\n        int256 _rcompCapPerSecond,\n        int256 _t0,\n        int256 _t1,\n        int256 _u,\n        int256 _tba\n    )\n        external\n        pure\n        returns (int256 rcomp, int256 k);\n\n    /// @notice Calculate the current instantaneous interest rate\n    /// @dev This function returns the current interest rate that would apply if a new\n    ///      transaction were to occur right now. Unlike compoundInterestRate, this\n    ///      doesn't calculate accrued interest over time, but rather the rate at\n    ///      the current moment.\n    /// \n    ///      This is useful for:\n    ///      - Displaying current rates to users\n    ///      - Calculating what rate would apply to new borrows\n    ///      - Monitoring rate changes in real-time\n    /// \n    /// @param _cfg Model configuration parameters\n    /// @param _state Current model state (including dynamic slope value)\n    /// @param _t0 Timestamp of the last interest rate update\n    /// @param _t1 Current timestamp for the calculation\n    /// @param _u Current utilization ratio (0 to 1e18, where 1e18 = 100% utilized)\n    /// @param _tba Current total borrowed amount\n    /// @return rcur Current instantaneous interest rate (in 18 decimals, annual rate)\n    function currentInterestRate(\n        Config memory _cfg,\n        ModelState memory _state,\n        int256 _t0,\n        int256 _t1,\n        int256 _u,\n        int256 _tba\n    )\n        external\n        pure\n        returns (int256 rcur);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "silo-core/contracts/utils/CrossReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {ICrossReentrancyGuard} from \"../interfaces/ICrossReentrancyGuard.sol\";\n\nabstract contract CrossReentrancyGuard is ICrossReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 0;\n    uint256 private constant _ENTERED = 1;\n\n    uint256 private transient _crossReentrantStatus;\n\n    /// @inheritdoc ICrossReentrancyGuard\n    function turnOnReentrancyProtection() external virtual {\n        _onlySiloOrTokenOrHookReceiver();\n        \n        require(_crossReentrantStatus != _ENTERED, CrossReentrantCall());\n\n        _crossReentrantStatus = _ENTERED;\n    }\n\n    /// @inheritdoc ICrossReentrancyGuard\n    function turnOffReentrancyProtection() external virtual {\n        _onlySiloOrTokenOrHookReceiver();\n        \n        // Leaving it unprotected may lead to a bug in the reentrancy protection system,\n        // as it can be used in the function without activating the protection before deactivating it.\n        // Later on, these functions may be called to turn off the reentrancy protection.\n        // To avoid this, we check if the protection is active before deactivating it.\n        require(_crossReentrantStatus != _NOT_ENTERED, CrossReentrancyNotActive());\n\n        _crossReentrantStatus = _NOT_ENTERED;\n    }\n\n    /// @inheritdoc ICrossReentrancyGuard\n    function reentrancyGuardEntered() external view virtual returns (bool entered) {\n        entered = _crossReentrantStatus == _ENTERED;\n    }\n\n    function _onlySiloOrTokenOrHookReceiver() internal virtual {}\n}\n"
    },
    "silo-core/contracts/lib/Hook.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.28;\n\nimport {ISilo} from \"../interfaces/ISilo.sol\";\n\n// solhint-disable private-vars-leading-underscore\nlibrary Hook {\n    /// @notice The data structure for the deposit hook\n    /// @param assets The amount of assets deposited\n    /// @param shares The amount of shares deposited\n    /// @param receiver The receiver of the deposit\n    struct BeforeDepositInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n    }\n\n    /// @notice The data structure for the deposit hook\n    /// @param assets The amount of assets deposited\n    /// @param shares The amount of shares deposited\n    /// @param receiver The receiver of the deposit\n    /// @param receivedAssets The exact amount of assets being deposited\n    /// @param mintedShares The exact amount of shares being minted\n    struct AfterDepositInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        uint256 receivedAssets;\n        uint256 mintedShares;\n    }\n\n    /// @notice The data structure for the withdraw hook\n    /// @param assets The amount of assets withdrawn\n    /// @param shares The amount of shares withdrawn\n    /// @param receiver The receiver of the withdrawal\n    /// @param owner The owner of the shares\n    /// @param spender The spender of the shares\n    struct BeforeWithdrawInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n    }\n\n    /// @notice The data structure for the withdraw hook\n    /// @param assets The amount of assets withdrawn\n    /// @param shares The amount of shares withdrawn\n    /// @param receiver The receiver of the withdrawal\n    /// @param owner The owner of the shares\n    /// @param spender The spender of the shares\n    /// @param withdrawnAssets The exact amount of assets being withdrawn\n    /// @param withdrawnShares The exact amount of shares being withdrawn\n    struct AfterWithdrawInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        uint256 withdrawnAssets;\n        uint256 withdrawnShares;\n    }\n\n    /// @notice The data structure for the share token transfer hook\n    /// @param sender The sender of the transfer (address(0) on mint)\n    /// @param recipient The recipient of the transfer (address(0) on burn)\n    /// @param amount The amount of tokens transferred/minted/burned\n    /// @param senderBalance The balance of the sender after the transfer (empty on mint)\n    /// @param recipientBalance The balance of the recipient after the transfer (empty on burn)\n    /// @param totalSupply The total supply of the share token\n    struct AfterTokenTransfer {\n        address sender;\n        address recipient;\n        uint256 amount;\n        uint256 senderBalance;\n        uint256 recipientBalance;\n        uint256 totalSupply;\n    }\n\n    /// @notice The data structure for the before borrow hook\n    /// @param assets The amount of assets to borrow\n    /// @param shares The amount of shares to borrow\n    /// @param receiver The receiver of the borrow\n    /// @param borrower The borrower of the assets\n    /// @param _spender Address which initiates the borrowing action on behalf of the borrower\n    struct BeforeBorrowInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n    }\n\n    /// @notice The data structure for the after borrow hook\n    /// @param assets The amount of assets borrowed\n    /// @param shares The amount of shares borrowed\n    /// @param receiver The receiver of the borrow\n    /// @param borrower The borrower of the assets\n    /// @param spender Address which initiates the borrowing action on behalf of the borrower\n    /// @param borrowedAssets The exact amount of assets being borrowed\n    /// @param borrowedShares The exact amount of shares being borrowed\n    struct AfterBorrowInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        uint256 borrowedAssets;\n        uint256 borrowedShares;\n    }\n\n    /// @notice The data structure for the before repay hook\n    /// @param assets The amount of assets to repay\n    /// @param shares The amount of shares to repay\n    /// @param borrower The borrower of the assets\n    /// @param repayer The repayer of the assets\n    struct BeforeRepayInput {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n    }\n\n    /// @notice The data structure for the after repay hook\n    /// @param assets The amount of assets to repay\n    /// @param shares The amount of shares to repay\n    /// @param borrower The borrower of the assets\n    /// @param repayer The repayer of the assets\n    /// @param repaidAssets The exact amount of assets being repaid\n    /// @param repaidShares The exact amount of shares being repaid\n    struct AfterRepayInput {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n        uint256 repaidAssets;\n        uint256 repaidShares;\n    }\n\n    /// @notice The data structure for the before flash loan hook\n    /// @param receiver The flash loan receiver\n    /// @param token The flash loan token\n    /// @param amount Requested amount of tokens\n    struct BeforeFlashLoanInput {\n        address receiver;\n        address token;\n        uint256 amount;\n    }\n\n    /// @notice The data structure for the after flash loan hook\n    /// @param receiver The flash loan receiver\n    /// @param token The flash loan token\n    /// @param amount Received amount of tokens\n    /// @param fee The flash loan fee\n    struct AfterFlashLoanInput {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint256 fee;\n    }\n\n    /// @notice The data structure for the before transition collateral hook\n    /// @param shares The amount of shares to transition\n    struct BeforeTransitionCollateralInput {\n        uint256 shares;\n        address owner;\n    }\n\n    /// @notice The data structure for the after transition collateral hook\n    /// @param shares The amount of shares to transition\n    struct AfterTransitionCollateralInput {\n        uint256 shares;\n        address owner;\n        uint256 assets;\n    }\n\n    /// @notice The data structure for the switch collateral hook\n    /// @param user The user switching collateral\n    struct SwitchCollateralInput {\n        address user;\n    }\n\n    /// @notice Supported hooks\n    /// @dev The hooks are stored as a bitmap and can be combined with bitwise OR\n    uint256 internal constant NONE = 0;\n    uint256 internal constant DEPOSIT = 2 ** 1;\n    uint256 internal constant BORROW = 2 ** 2;\n    uint256 internal constant BORROW_SAME_ASSET = 2 ** 3; // deprecated\n    uint256 internal constant REPAY = 2 ** 4;\n    uint256 internal constant WITHDRAW = 2 ** 5;\n    uint256 internal constant FLASH_LOAN = 2 ** 6;\n    uint256 internal constant TRANSITION_COLLATERAL = 2 ** 7;\n    uint256 internal constant SWITCH_COLLATERAL = 2 ** 8; // deprecated\n    uint256 internal constant SHARE_TOKEN_TRANSFER = 2 ** 10;\n    uint256 internal constant COLLATERAL_TOKEN = 2 ** 11;\n    uint256 internal constant PROTECTED_TOKEN = 2 ** 12;\n    uint256 internal constant DEBT_TOKEN = 2 ** 13;\n\n    // note: currently we can support hook value up to 2 ** 23,\n    // because for optimisation purposes, we storing hooks as uint24\n\n    // For decoding packed data\n    uint256 private constant PACKED_ADDRESS_LENGTH = 20;\n    uint256 private constant PACKED_FULL_LENGTH = 32;\n    uint256 private constant PACKED_ENUM_LENGTH = 1;\n    uint256 private constant PACKED_BOOL_LENGTH = 1;\n\n    error FailedToParseBoolean();\n    error InvalidTokenType();\n\n    /// @notice Checks if the action has a specific hook\n    /// @param _action The action\n    /// @param _expectedHook The expected hook\n    /// @dev The function returns true if the action has the expected hook.\n    /// As hooks actions can be combined with bitwise OR, the following examples are valid:\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, WITHDRAW) == true`\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, COLLATERAL_TOKEN) == true`\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, WITHDRAW | COLLATERAL_TOKEN) == true`\n    function matchAction(uint256 _action, uint256 _expectedHook) internal pure returns (bool) {\n        return (_action & _expectedHook) == _expectedHook;\n    }\n\n    /// @notice Adds a hook to an action\n    /// @param _action The action\n    /// @param _newAction The new hook to be added\n    function addAction(uint256 _action, uint256 _newAction) internal pure returns (uint256) {\n        return _action | _newAction;\n    }\n\n    /// @dev please be careful with removing actions, because other hooks might using them\n    /// eg when you have `_action = COLLATERAL_TOKEN | PROTECTED_TOKEN | SHARE_TOKEN_TRANSFER`\n    /// and you want to remove action on protected token transfer by doing\n    /// `remove(_action, PROTECTED_TOKEN | SHARE_TOKEN_TRANSFER)`, the result will be `_action=COLLATERAL_TOKEN`\n    /// and it will not trigger collateral token transfer. In this example you should do:\n    /// `remove(_action, PROTECTED_TOKEN)`\n    function removeAction(uint256 _action, uint256 _actionToRemove) internal pure returns (uint256) {\n        return _action & (~_actionToRemove);\n    }\n\n    /// @notice Returns the action for depositing a specific collateral type\n    /// @param _type The collateral type\n    function depositAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return DEPOSIT | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the action for withdrawing a specific collateral type\n    /// @param _type The collateral type\n    function withdrawAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return WITHDRAW | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the action for collateral transition\n    /// @param _type The collateral type\n    function transitionCollateralAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return TRANSITION_COLLATERAL | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the share token transfer action\n    /// @param _tokenType The token type (COLLATERAL_TOKEN || PROTECTED_TOKEN || DEBT_TOKEN)\n    function shareTokenTransfer(uint256 _tokenType) internal pure returns (uint256) {\n        require(\n            _tokenType == COLLATERAL_TOKEN || _tokenType == PROTECTED_TOKEN || _tokenType == DEBT_TOKEN,\n            InvalidTokenType()\n        );\n\n        return SHARE_TOKEN_TRANSFER | _tokenType;\n    }\n\n    /// @dev Decodes packed data from the share token after the transfer hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterTokenTransferDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterTokenTransfer memory input)\n    {\n        address sender;\n        address recipient;\n        uint256 amount;\n        uint256 senderBalance;\n        uint256 recipientBalance;\n        uint256 totalSupply;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            sender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            recipient := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            senderBalance := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            recipientBalance := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            totalSupply := mload(add(packed, pointer))\n        }\n\n        input = AfterTokenTransfer({\n            sender: sender,\n            recipient: recipient,\n            amount: amount,\n            senderBalance: senderBalance,\n            recipientBalance: recipientBalance,\n            totalSupply: totalSupply\n        });\n    }\n\n    /// @dev Decodes packed data from the deposit hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeDepositDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeDepositInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n        }\n\n        input = BeforeDepositInput({assets: assets, shares: shares, receiver: receiver});\n    }\n\n    /// @dev Decodes packed data from the deposit hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterDepositDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterDepositInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        uint256 receivedAssets;\n        uint256 mintedShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            receivedAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            mintedShares := mload(add(packed, pointer))\n        }\n\n        input = AfterDepositInput({\n            assets: assets,\n            shares: shares,\n            receiver: receiver,\n            receivedAssets: receivedAssets,\n            mintedShares: mintedShares\n        });\n    }\n\n    /// @dev Decodes packed data from the withdraw hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeWithdrawDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeWithdrawInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n        }\n\n        input = BeforeWithdrawInput({\n            assets: assets,\n            shares: shares,\n            receiver: receiver,\n            owner: owner,\n            spender: spender\n        });\n    }\n\n    /// @dev Decodes packed data from the withdraw hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterWithdrawDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterWithdrawInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        uint256 withdrawnAssets;\n        uint256 withdrawnShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            withdrawnAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            withdrawnShares := mload(add(packed, pointer))\n        }\n\n        input = AfterWithdrawInput({\n            assets: assets,\n            shares: shares,\n            receiver: receiver,\n            owner: owner,\n            spender: spender,\n            withdrawnAssets: withdrawnAssets,\n            withdrawnShares: withdrawnShares\n        });\n    }\n\n    /// @dev Decodes packed data from the before borrow hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeBorrowDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeBorrowInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n        }\n\n        input = BeforeBorrowInput({\n            assets: assets,\n            shares: shares,\n            receiver: receiver,\n            borrower: borrower,\n            spender: spender\n        });\n    }\n\n    /// @dev Decodes packed data from the after borrow hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterBorrowDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterBorrowInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        uint256 borrowedAssets;\n        uint256 borrowedShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            borrowedAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            borrowedShares := mload(add(packed, pointer))\n        }\n\n        input = AfterBorrowInput({\n            assets: assets,\n            shares: shares,\n            receiver: receiver,\n            borrower: borrower,\n            spender: spender,\n            borrowedAssets: borrowedAssets,\n            borrowedShares: borrowedShares\n        });\n    }\n\n    /// @dev Decodes packed data from the before repay hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeRepayDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeRepayInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            repayer := mload(add(packed, pointer))\n        }\n\n        input = BeforeRepayInput({assets: assets, shares: shares, borrower: borrower, repayer: repayer});\n    }\n\n    /// @dev Decodes packed data from the after repay hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterRepayDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterRepayInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n        uint256 repaidAssets;\n        uint256 repaidShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            repayer := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            repaidAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            repaidShares := mload(add(packed, pointer))\n        }\n\n        input = AfterRepayInput({\n            assets: assets,\n            shares: shares,\n            borrower: borrower,\n            repayer: repayer,\n            repaidAssets: repaidAssets,\n            repaidShares: repaidShares\n        });\n    }\n\n    /// @dev Decodes packed data from the before flash loan hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeFlashLoanDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeFlashLoanInput memory input)\n    {\n        address receiver;\n        address token;\n        uint256 amount;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            token := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n        }\n\n        input = BeforeFlashLoanInput({receiver: receiver, token: token, amount: amount});\n    }\n\n    /// @dev Decodes packed data from the before flash loan hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterFlashLoanDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterFlashLoanInput memory input)\n    {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint256 fee;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            token := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            fee := mload(add(packed, pointer))\n        }\n\n        input = AfterFlashLoanInput({receiver: receiver, token: token, amount: amount, fee: fee});\n    }\n\n    /// @dev Decodes packed data from the transition collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeTransitionCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeTransitionCollateralInput memory input)\n    {\n        uint256 shares;\n        address owner;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n        }\n\n        input = BeforeTransitionCollateralInput({shares: shares, owner: owner});\n    }\n\n    /// @dev Decodes packed data from the transition collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterTransitionCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterTransitionCollateralInput memory input)\n    {\n        uint256 shares;\n        address owner;\n        uint256 assets;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            assets := mload(add(packed, pointer))\n        }\n\n        input = AfterTransitionCollateralInput({shares: shares, owner: owner, assets: assets});\n    }\n\n    /// @dev Decodes packed data from the switch collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function switchCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (SwitchCollateralInput memory input)\n    {\n        address user;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            user := mload(add(packed, pointer))\n        }\n\n        input = SwitchCollateralInput({user: user});\n    }\n\n    /// @dev Converts a uint8 to a boolean\n    function _toBoolean(uint8 _value) internal pure returns (bool result) {\n        if (_value == 0) {\n            result = false;\n        } else if (_value == 1) {\n            result = true;\n        } else {\n            revert FailedToParseBoolean();\n        }\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ISiloOracle {\n    /// @notice Hook function to call before `quote` function reads price\n    /// @dev This hook function can be used to change state right before the price is read. For example it can be used\n    ///      for curve read only reentrancy protection. In majority of implementations this will be an empty function.\n    ///      WARNING: reverts are propagated to Silo so if `beforeQuote` reverts, Silo reverts as well.\n    /// @param _baseToken Address of priced token\n    function beforeQuote(address _baseToken) external;\n\n    /// @return quoteAmount Returns quote price for _baseAmount of _baseToken\n    /// @param _baseAmount Amount of priced token\n    /// @param _baseToken Address of priced token\n    function quote(uint256 _baseAmount, address _baseToken) external view returns (uint256 quoteAmount);\n\n    /// @return address of token in which quote (price) is denominated\n    function quoteToken() external view returns (address);\n}\n"
    },
    "silo-core/contracts/interfaces/IShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\nimport {ISilo} from \"./ISilo.sol\";\n\ninterface IShareToken is IERC20Metadata {\n    struct HookSetup {\n        /// @param this is the same as in siloConfig\n        address hookReceiver;\n        /// @param hooks bitmap\n        uint24 hooksBefore;\n        /// @param hooks bitmap\n        uint24 hooksAfter;\n        /// @param tokenType must be one of this hooks values: COLLATERAL_TOKEN, PROTECTED_TOKEN, DEBT_TOKEN\n        uint24 tokenType;\n    }\n\n    struct ShareTokenStorage {\n        /// @notice Silo address for which tokens was deployed\n        ISilo silo;\n\n        /// @dev cached silo config address\n        ISiloConfig siloConfig;\n\n        /// @notice Copy of hooks setup from SiloConfig for optimisation purposes\n        HookSetup hookSetup;\n\n        bool transferWithChecks;\n    }\n\n    /// @notice Emitted every time receiver is notified about token transfer\n    /// @param notificationReceiver receiver address\n    /// @param success false if TX reverted on `notificationReceiver` side, otherwise true\n    event NotificationSent(address indexed notificationReceiver, bool success);\n\n    error OnlySilo();\n    error OnlySiloConfig();\n    error OwnerIsZero();\n    error RecipientIsZero();\n    error AmountExceedsAllowance();\n    error RecipientNotSolventAfterTransfer();\n    error SenderNotSolventAfterTransfer();\n    error ZeroTransfer();\n\n    /// @notice method for SiloConfig to synchronize hooks\n    /// @param _hooksBefore hooks bitmap to trigger hooks BEFORE action\n    /// @param _hooksAfter hooks bitmap to trigger hooks AFTER action\n    function synchronizeHooks(uint24 _hooksBefore, uint24 _hooksAfter) external;\n\n    /// @notice Mint method for Silo to create debt\n    /// @param _owner wallet for which to mint token\n    /// @param _spender wallet that asks for mint\n    /// @param _amount amount of token to be minted\n    function mint(address _owner, address _spender, uint256 _amount) external;\n\n    /// @notice Burn method for Silo to close debt\n    /// @param _owner wallet for which to burn token\n    /// @param _spender wallet that asks for burn\n    /// @param _amount amount of token to be burned\n    function burn(address _owner, address _spender, uint256 _amount) external;\n\n    /// @notice TransferFrom method for liquidation\n    /// @param _from wallet from which we transferring tokens\n    /// @param _to wallet that will get tokens\n    /// @param _amount amount of token to transfer\n    function forwardTransferFromNoChecks(address _from, address _to, uint256 _amount) external;\n\n    /// @dev Returns the amount of tokens owned by `account`.\n    /// @param _account address for which to return data\n    /// @return balance of the _account\n    /// @return totalSupply total supply of the token\n    function balanceOfAndTotalSupply(address _account) external view returns (uint256 balance, uint256 totalSupply);\n\n    /// @notice Returns silo address for which token was deployed\n    /// @return silo address\n    function silo() external view returns (ISilo silo);\n\n    function siloConfig() external view returns (ISiloConfig silo);\n\n    /// @notice Returns hook setup\n    function hookSetup() external view returns (HookSetup memory);\n\n    /// @notice Returns hook receiver address\n    function hookReceiver() external view returns (address);\n\n    /// @dev offset value uses by vaults to calculate the conversion rate between assets and shares\n    /// it determines how many shares are minted for 1 asset eg. with offset 3, 1 asset = 1000 shares\n    /// notice, that 1:1000 ratio can change for collateral shares when shares value changes eg due to interest accrual.\n    /// see openzeppelin contract: contracts/token/ERC20/extensions/ERC4626.sol for more details about offset\n    /// @notice this method is available since Silo Core v4.0.0\n    function decimalsOffset() external view returns (uint256);\n}\n"
    },
    "silo-core/contracts/lib/SiloERC4626Lib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.28;\n\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {SiloSolvencyLib} from \"./SiloSolvencyLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {SiloLendingLib} from \"./SiloLendingLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\nimport {ShareTokenLib} from \"./ShareTokenLib.sol\";\nimport {SiloStorageLib} from \"./SiloStorageLib.sol\";\n\n// solhint-disable function-max-lines\n\nlibrary SiloERC4626Lib {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    /// @dev ERC4626: MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be\n    ///      deposited. In our case, we want to limit this value in a way, that after max deposit we can do borrow.\n    uint256 internal constant _VIRTUAL_DEPOSIT_LIMIT = type(uint256).max;\n\n    /// @notice Deposit assets into the silo\n    /// @param _token The ERC20 token address being deposited; 0 means tokens will not be transferred. Useful for\n    /// transition of collateral.\n    /// @param _depositor Address of the user depositing the assets\n    /// @param _assets Amount of assets being deposited. Use 0 if shares are provided.\n    /// @param _shares Shares being exchanged for the deposit; used for precise calculations. Use 0 if assets are\n    /// provided.\n    /// @param _receiver The address that will receive the collateral shares\n    /// @param _collateralShareToken The collateral share token\n    /// @param _collateralType The type of collateral being deposited\n    /// @return assets The exact amount of assets being deposited\n    /// @return shares The exact number of collateral shares being minted in exchange for the deposited assets\n    function deposit(\n        address _token,\n        address _depositor,\n        uint256 _assets,\n        uint256 _shares,\n        address _receiver,\n        IShareToken _collateralShareToken,\n        ISilo.CollateralType _collateralType\n    ) internal returns (uint256 assets, uint256 shares) {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n        ISilo.AssetType collateralType = ISilo.AssetType(uint256(_collateralType));\n\n        uint256 totalAssets = $.totalAssets[collateralType];\n\n        (assets, shares) = SiloMathLib.convertToAssetsOrToShares(\n            _assets,\n            _shares,\n            totalAssets,\n            _collateralShareToken.totalSupply(),\n            Rounding.DEPOSIT_TO_ASSETS,\n            Rounding.DEPOSIT_TO_SHARES,\n            collateralType\n        );\n\n        $.totalAssets[collateralType] = totalAssets + assets;\n\n        // Hook receiver is called after `mint` and can reentry but state changes are completed already,\n        // and reentrancy protection is still enabled.\n        _collateralShareToken.mint(_receiver, _depositor, shares);\n\n        if (_token != address(0)) {\n            // Reentrancy is possible only for view methods (read-only reentrancy),\n            // so no harm can be done as the state is already updated.\n            // We do not expect the silo to work with any malicious token that will not send tokens to silo.\n            IERC20(_token).safeTransferFrom(_depositor, address(this), assets);\n        }\n    }\n\n    /// @notice Withdraw assets from the silo\n    /// @dev Asset type is not verified here, make sure you revert before when type == Debt\n    /// @param _asset The ERC20 token address to withdraw; 0 means tokens will not be transferred. Useful for\n    /// transition of collateral.\n    /// @param _shareToken Address of the share token being burned for withdrawal\n    /// @param _args ISilo.WithdrawArgs\n    /// @return assets The exact amount of assets withdrawn\n    /// @return shares The exact number of shares burned in exchange for the withdrawn assets\n    function withdraw(\n        address _asset,\n        address _shareToken,\n        ISilo.WithdrawArgs memory _args\n    ) internal returns (uint256 assets, uint256 shares) {\n        uint256 shareTotalSupply = IShareToken(_shareToken).totalSupply();\n        require(shareTotalSupply != 0, ISilo.NothingToWithdraw());\n\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        ISilo.AssetType collateralType = ISilo.AssetType(uint256(_args.collateralType));\n\n        { // Stack too deep\n            uint256 totalAssets = $.totalAssets[collateralType];\n\n            (assets, shares) = SiloMathLib.convertToAssetsOrToShares(\n                _args.assets,\n                _args.shares,\n                totalAssets,\n                shareTotalSupply,\n                Rounding.WITHDRAW_TO_ASSETS,\n                Rounding.WITHDRAW_TO_SHARES,\n                collateralType\n            );\n\n            uint256 liquidity = _args.collateralType == ISilo.CollateralType.Collateral\n                ? SiloMathLib.liquidity($.totalAssets[ISilo.AssetType.Collateral], $.totalAssets[ISilo.AssetType.Debt])\n                : $.totalAssets[ISilo.AssetType.Protected];\n\n            // check liquidity\n            require(assets <= liquidity, ISilo.NotEnoughLiquidity());\n\n            $.totalAssets[collateralType] = totalAssets - assets;\n        }\n\n        // `burn` checks if `_spender` is allowed to withdraw `_owner` assets. `burn` calls hook receiver\n        // after tokens transfer and can potentially reenter, but state changes are already completed,\n        // and reentrancy protection is still enabled.\n        IShareToken(_shareToken).burn(_args.owner, _args.spender, shares);\n\n        if (_asset != address(0)) {\n            // does not matter what is the type of transfer, we can not go below protected balance\n            uint256 protectedBalance = $.totalAssets[ISilo.AssetType.Protected];\n\n            require(\n                protectedBalance == 0 || IERC20(_asset).balanceOf(address(this)) - assets >= protectedBalance,\n                ISilo.ProtectedProtection()\n            );\n\n            // fee-on-transfer is ignored\n            IERC20(_asset).safeTransfer(_args.receiver, assets);\n        }\n    }\n\n    /// @notice Determines the maximum amount a user can withdraw, either in terms of assets or shares\n    /// @dev The function computes the maximum withdrawable assets and shares, considering user's collateral, debt,\n    /// and the liquidity in the silo.\n    /// Debt withdrawals are not allowed, resulting in a revert if such an attempt is made.\n    /// @param _owner Address of the user for which the maximum withdrawal amount is calculated\n    /// @param _collateralType The type of asset being considered for withdrawal\n    /// @param _totalAssets The total PROTECTED assets in the silo. In case of collateral use `0`, total\n    /// collateral will be calculated internally with interest\n    /// @return assets The maximum assets that the user can withdraw\n    /// @return shares The maximum shares that the user can withdraw\n    function maxWithdraw(\n        address _owner,\n        ISilo.CollateralType _collateralType,\n        uint256 _totalAssets\n    ) internal view returns (uint256 assets, uint256 shares) {\n        (\n            ISiloConfig.DepositConfig memory depositConfig,\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        ) = ShareTokenLib.siloConfig().getConfigsForWithdraw(address(this), _owner);\n\n        uint256 shareTokenTotalSupply;\n        uint256 liquidity;\n\n        if (_collateralType == ISilo.CollateralType.Collateral) {\n            shareTokenTotalSupply = IShareToken(depositConfig.collateralShareToken).totalSupply();\n            (liquidity, _totalAssets, ) = SiloLendingLib.getLiquidityAndAssetsWithInterest(\n                depositConfig.interestRateModel,\n                depositConfig.daoFee,\n                depositConfig.deployerFee\n            );\n\n            if (liquidity != 0) {\n                // We need to count for fractions. When fractions are applied, liquidity may be decreased.\n                unchecked { liquidity -= 1; _totalAssets -= 1; }\n            }\n        } else {\n            shareTokenTotalSupply = IShareToken(depositConfig.protectedShareToken).totalSupply();\n            liquidity = _totalAssets;\n        }\n\n        // if deposit is not related to debt\n        if (depositConfig.silo != collateralConfig.silo) {\n            shares = _collateralType == ISilo.CollateralType.Protected\n                ? IShareToken(depositConfig.protectedShareToken).balanceOf(_owner)\n                : IShareToken(depositConfig.collateralShareToken).balanceOf(_owner);\n\n            assets = SiloMathLib.convertToAssets(\n                shares,\n                _totalAssets,\n                shareTokenTotalSupply,\n                Rounding.MAX_WITHDRAW_TO_ASSETS,\n                ISilo.AssetType(uint256(_collateralType))\n            );\n\n            if (_collateralType == ISilo.CollateralType.Collateral && assets > liquidity) {\n                assets = liquidity;\n\n                shares = SiloMathLib.convertToShares(\n                    assets,\n                    _totalAssets,\n                    shareTokenTotalSupply,\n                    // when we doing withdraw, we using Rounding.Ceil, because we want to burn as many shares\n                    // however here, we will be using shares as input to withdraw, if we round up, we can overflow\n                    // because we will want to withdraw too much, so we have to use Rounding.Floor\n                    Rounding.MAX_WITHDRAW_TO_SHARES,\n                    ISilo.AssetType.Collateral\n                );\n            }\n        } else {\n            (assets, shares) = maxWithdrawWhenDebt(\n                collateralConfig, debtConfig, _owner, liquidity, shareTokenTotalSupply, _collateralType, _totalAssets\n            );\n        }\n\n        /*\n        there might be a case where conversion from assets <=> shares is not returning same amounts eg:\n        convert to shares ==> 1 * (1002 + 1e3) / (2 + 1) = 667.3\n        convert to assets ==> 667 * (2 + 1) / (1002 + 1e3) = 0.9995\n        so when user will use 667 withdrawal will fail, this is why we have to cross check:\n        */\n        if (\n            SiloMathLib.convertToAssets({\n                _shares: shares,\n                _totalAssets: _totalAssets,\n                _totalShares: shareTokenTotalSupply,\n                _rounding: Rounding.MAX_WITHDRAW_TO_ASSETS,\n                _assetType: ISilo.AssetType(uint8(_collateralType))\n            }) == 0\n        ) {\n            return (0, 0);\n        }\n    }\n\n    function maxWithdrawWhenDebt(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _owner,\n        uint256 _liquidity,\n        uint256 _shareTokenTotalSupply,\n        ISilo.CollateralType _collateralType,\n        uint256 _totalAssets\n    ) internal view returns (uint256 assets, uint256 shares) {\n        SiloSolvencyLib.LtvData memory ltvData = SiloSolvencyLib.getAssetsDataForLtvCalculations(\n            _collateralConfig,\n            _debtConfig,\n            _owner,\n            ISilo.OracleType.Solvency,\n            ISilo.AccrueInterestInMemory.Yes,\n            IShareToken(_debtConfig.debtShareToken).balanceOf(_owner)\n        );\n\n        // Workaround for fractions. We assume the worst case scenario that we will have integral revenue\n        // that will be subtracted from collateral and integral interest that will be added to debt.\n        {\n            // We need to decrease borrowerCollateralAssets\n            // since we cannot access totalCollateralAssets before calculations.\n            if (ltvData.borrowerCollateralAssets != 0) ltvData.borrowerCollateralAssets--;\n\n            // We need to increase borrowerDebtAssets since we cannot access totalDebtAssets before calculations.\n            // If borrowerDebtAssets is 0 then we have no interest\n            if (ltvData.borrowerDebtAssets != 0) ltvData.borrowerDebtAssets++;\n        }\n\n        {\n            (uint256 collateralValue, uint256 debtValue) =\n                SiloSolvencyLib.getPositionValues(ltvData, _collateralConfig.token, _debtConfig.token);\n\n            assets = SiloMathLib.calculateMaxAssetsToWithdraw({\n                _sumOfCollateralsValue: collateralValue,\n                _debtValue: debtValue,\n                _lt: _collateralConfig.lt,\n                _borrowerCollateralAssets: ltvData.borrowerCollateralAssets,\n                _borrowerProtectedAssets: ltvData.borrowerProtectedAssets\n            });\n        }\n\n        (assets, shares) = SiloMathLib.maxWithdrawToAssetsAndShares({\n            _maxAssets: assets,\n            _borrowerCollateralAssets: ltvData.borrowerCollateralAssets,\n            _borrowerProtectedAssets: ltvData.borrowerProtectedAssets,\n            _collateralType: _collateralType,\n            _totalAssets: _totalAssets,\n            _assetTypeShareTokenTotalSupply: _shareTokenTotalSupply,\n            _liquidity: _liquidity\n        });\n\n        if (assets != 0) {\n            // recalculate assets due to rounding error that we have in convertToShares\n            assets = SiloMathLib.convertToAssets(\n                shares,\n                _totalAssets,\n                _shareTokenTotalSupply,\n                Rounding.MAX_WITHDRAW_TO_ASSETS,\n                ISilo.AssetType(uint256(_collateralType))\n            );\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloSolvencyLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\nimport {SiloStdLib, ISiloConfig, IShareToken, ISilo} from \"./SiloStdLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\n\nlibrary SiloSolvencyLib {\n    using Math for uint256;\n\n    struct LtvData {\n        ISiloOracle collateralOracle;\n        ISiloOracle debtOracle;\n        uint256 borrowerProtectedAssets;\n        uint256 borrowerCollateralAssets;\n        uint256 borrowerDebtAssets;\n    }\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n    uint256 internal constant _INFINITY = type(uint256).max;\n\n    /// @notice Determines if a borrower is solvent based on the Loan-to-Value (LTV) ratio\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower to check solvency for\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return True if the borrower is solvent, false otherwise\n    function isSolvent(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.AccrueInterestInMemory _accrueInMemory\n    ) internal view returns (bool) {\n        if (_debtConfig.silo == address(0)) return true; // no debt, so solvent\n\n        uint256 ltv = getLtv(\n            _collateralConfig,\n            _debtConfig,\n            _borrower,\n            ISilo.OracleType.Solvency,\n            _accrueInMemory,\n            IShareToken(_debtConfig.debtShareToken).balanceOf(_borrower)\n        );\n\n        return ltv <= _collateralConfig.lt;\n    }\n\n    /// @notice Determines if a borrower's Loan-to-Value (LTV) ratio is below the maximum allowed LTV\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower to check against max LTV\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return True if the borrower's LTV is below the maximum, false otherwise\n    function isBelowMaxLtv(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.AccrueInterestInMemory _accrueInMemory\n    ) internal view returns (bool) {\n        uint256 debtShareBalance = IShareToken(_debtConfig.debtShareToken).balanceOf(_borrower);\n        if (debtShareBalance == 0) return true;\n\n        uint256 ltv = getLtv(\n            _collateralConfig,\n            _debtConfig,\n            _borrower,\n            ISilo.OracleType.MaxLtv,\n            _accrueInMemory,\n            debtShareBalance\n        );\n\n        return ltv <= _collateralConfig.maxLtv;\n    }\n\n    /// @notice Retrieves assets data required for LTV calculations\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower whose LTV data is to be calculated\n    /// @param _oracleType Specifies whether to use the MaxLTV or Solvency oracle type for calculations\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @param _debtShareBalanceCached Cached value of debt share balance for the borrower. If debt shares of\n    /// `_borrower` is unknown, simply pass `0`.\n    /// @return ltvData Data structure containing necessary data to compute LTV\n    function getAssetsDataForLtvCalculations( // solhint-disable-line function-max-lines\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.OracleType _oracleType,\n        ISilo.AccrueInterestInMemory _accrueInMemory,\n        uint256 _debtShareBalanceCached\n    ) internal view returns (LtvData memory ltvData) {\n        if (_collateralConfig.token != _debtConfig.token) {\n            // When calculating maxLtv, use maxLtv oracle.\n            (ltvData.collateralOracle, ltvData.debtOracle) = _oracleType == ISilo.OracleType.MaxLtv\n                ? (ISiloOracle(_collateralConfig.maxLtvOracle), ISiloOracle(_debtConfig.maxLtvOracle))\n                : (ISiloOracle(_collateralConfig.solvencyOracle), ISiloOracle(_debtConfig.solvencyOracle));\n        }\n\n        uint256 totalShares;\n        uint256 shares;\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _collateralConfig.protectedShareToken, _borrower, 0 /* no cache */\n        );\n\n        (\n            uint256 totalCollateralAssets, uint256 totalProtectedAssets\n        ) = ISilo(_collateralConfig.silo).getCollateralAndProtectedTotalsStorage();\n\n        ltvData.borrowerProtectedAssets = SiloMathLib.convertToAssets(\n            shares, totalProtectedAssets, totalShares, Rounding.COLLATERAL_TO_ASSETS, ISilo.AssetType.Protected\n        );\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _collateralConfig.collateralShareToken, _borrower, 0 /* no cache */\n        );\n\n        totalCollateralAssets = _accrueInMemory == ISilo.AccrueInterestInMemory.Yes\n            ? SiloStdLib.getTotalCollateralAssetsWithInterest(\n                _collateralConfig.silo,\n                _collateralConfig.interestRateModel,\n                _collateralConfig.daoFee,\n                _collateralConfig.deployerFee\n            )\n            : totalCollateralAssets;\n\n        ltvData.borrowerCollateralAssets = SiloMathLib.convertToAssets(\n            shares, totalCollateralAssets, totalShares, Rounding.COLLATERAL_TO_ASSETS, ISilo.AssetType.Collateral\n        );\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _debtConfig.debtShareToken, _borrower, _debtShareBalanceCached\n        );\n\n        uint256 totalDebtAssets = _accrueInMemory == ISilo.AccrueInterestInMemory.Yes\n            ? SiloStdLib.getTotalDebtAssetsWithInterest(_debtConfig.silo, _debtConfig.interestRateModel)\n            : ISilo(_debtConfig.silo).getTotalAssetsStorage(ISilo.AssetType.Debt);\n\n        // BORROW value -> to assets -> UP\n        ltvData.borrowerDebtAssets = SiloMathLib.convertToAssets(\n            shares, totalDebtAssets, totalShares, Rounding.DEBT_TO_ASSETS, ISilo.AssetType.Debt\n        );\n    }\n\n    /// @notice Calculates the Loan-To-Value (LTV) ratio for a given borrower\n    /// @param _collateralConfig Configuration data related to the collateral asset\n    /// @param _debtConfig Configuration data related to the debt asset\n    /// @param _borrower Address of the borrower whose LTV is to be computed\n    /// @param _oracleType Oracle type to use for fetching the asset prices\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return ltvInDp The computed LTV ratio in 18 decimals precision\n    function getLtv(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.OracleType _oracleType,\n        ISilo.AccrueInterestInMemory _accrueInMemory,\n        uint256 _debtShareBalance\n    ) internal view returns (uint256 ltvInDp) {\n        if (_debtShareBalance == 0) return 0;\n\n        LtvData memory ltvData = getAssetsDataForLtvCalculations(\n            _collateralConfig, _debtConfig, _borrower, _oracleType, _accrueInMemory, _debtShareBalance\n        );\n\n        if (ltvData.borrowerDebtAssets == 0) return 0;\n\n        (,, ltvInDp) = calculateLtv(ltvData, _collateralConfig.token, _debtConfig.token);\n    }\n\n    /// @notice Calculates the Loan-to-Value (LTV) ratio based on provided collateral and debt data\n    /// @dev calculation never reverts, if there is revert, then it is because of oracle\n    /// @param _ltvData Data structure containing relevant information to calculate LTV\n    /// @param _collateralToken Address of the collateral token\n    /// @param _debtAsset Address of the debt token\n    /// @return sumOfBorrowerCollateralValue Total value of borrower's collateral\n    /// @return totalBorrowerDebtValue Total debt value for the borrower\n    /// @return ltvInDp Calculated LTV in 18 decimal precision\n    function calculateLtv(\n        SiloSolvencyLib.LtvData memory _ltvData, address _collateralToken, address _debtAsset)\n        internal\n        view\n        returns (uint256 sumOfBorrowerCollateralValue, uint256 totalBorrowerDebtValue, uint256 ltvInDp)\n    {\n        (\n            sumOfBorrowerCollateralValue, totalBorrowerDebtValue\n        ) = getPositionValues(_ltvData, _collateralToken, _debtAsset);\n\n        if (sumOfBorrowerCollateralValue == 0 && totalBorrowerDebtValue == 0) {\n            return (0, 0, 0);\n        } else if (sumOfBorrowerCollateralValue == 0) {\n            ltvInDp = _INFINITY;\n        } else {\n            ltvInDp = ltvMath(totalBorrowerDebtValue, sumOfBorrowerCollateralValue);\n        }\n    }\n\n    /// @notice Computes the value of collateral and debt based on given LTV data and asset addresses\n    /// @param _ltvData Data structure containing the assets data required for LTV calculations\n    /// @param _collateralAsset Address of the collateral asset\n    /// @param _debtAsset Address of the debt asset\n    /// @return sumOfCollateralValue Total value of collateral assets considering both protected and regular collateral\n    /// assets\n    /// @return debtValue Total value of debt assets\n    function getPositionValues(LtvData memory _ltvData, address _collateralAsset, address _debtAsset)\n        internal\n        view\n        returns (uint256 sumOfCollateralValue, uint256 debtValue)\n    {\n        uint256 sumOfCollateralAssets;\n        \n        sumOfCollateralAssets = _ltvData.borrowerProtectedAssets + _ltvData.borrowerCollateralAssets;\n\n        if (sumOfCollateralAssets != 0) {\n            // if no oracle is set, assume price 1, we should also not set oracle for quote token\n            sumOfCollateralValue = address(_ltvData.collateralOracle) != address(0)\n                ? _ltvData.collateralOracle.quote(sumOfCollateralAssets, _collateralAsset)\n                : sumOfCollateralAssets;\n        }\n\n        if (_ltvData.borrowerDebtAssets != 0) {\n            // if no oracle is set, assume price 1, we should also not set oracle for quote token\n            debtValue = address(_ltvData.debtOracle) != address(0)\n                ? _ltvData.debtOracle.quote(_ltvData.borrowerDebtAssets, _debtAsset)\n                : _ltvData.borrowerDebtAssets;\n        }\n    }\n\n    function ltvMath(uint256 _totalBorrowerDebtValue, uint256 _sumOfBorrowerCollateralValue)\n        internal\n        pure\n        returns (uint256 ltvInDp)\n    {\n        ltvInDp = _totalBorrowerDebtValue.mulDiv(_PRECISION_DECIMALS, _sumOfBorrowerCollateralValue, Rounding.LTV);\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloLendingLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.28;\n\n// solhint-disable ordering\n\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {SiloSolvencyLib} from \"./SiloSolvencyLib.sol\";\nimport {SiloStdLib} from \"./SiloStdLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\nimport {ShareTokenLib} from \"./ShareTokenLib.sol\";\nimport {SiloStorageLib} from \"./SiloStorageLib.sol\";\n\nlibrary SiloLendingLib {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n    /// @dev If SILO has low total debt, interest might be lost to rounding for low deposits.\n    /// Value is based on minimal deposit needed to accrue two digit wei interest for 1 second at 0.01% APR.\n    /// Example of calculations for 1 second at 0.01% APR and totalDebtAssets 1e13:\n    /// 1e13 * (0.0001/365/24/3600*1e18) * 1 / 1e18 = 31.70979198376459\n    uint256 internal constant _ROUNDING_THRESHOLD = 1e13;\n\n    /// @notice Allows repaying borrowed assets either partially or in full\n    /// @param _debtShareToken debt share token address\n    /// @param _debtAsset underlying debt asset address\n    /// @param _assets The amount of assets to repay. Use 0 if shares are used.\n    /// @param _shares The number of corresponding shares associated with the debt. Use 0 if assets are used.\n    /// @param _borrower The account that has the debt\n    /// @param _repayer The account that is repaying the debt\n    /// @return assets The amount of assets that was repaid\n    /// @return shares The corresponding number of debt shares that were repaid\n    function repay(\n        IShareToken _debtShareToken,\n        address _debtAsset,\n        uint256 _assets,\n        uint256 _shares,\n        address _borrower,\n        address _repayer\n    ) internal returns (uint256 assets, uint256 shares) {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        uint256 totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n        (uint256 debtSharesBalance, uint256 totalDebtShares) = _debtShareToken.balanceOfAndTotalSupply(_borrower);\n\n        (assets, shares) = SiloMathLib.convertToAssetsOrToShares({\n            _assets: _assets,\n            _shares: _shares,\n            _totalAssets: totalDebtAssets,\n            _totalShares: totalDebtShares,\n            _roundingToAssets: Rounding.REPAY_TO_ASSETS,\n            _roundingToShares: Rounding.REPAY_TO_SHARES,\n            _assetType: ISilo.AssetType.Debt\n        });\n\n        if (shares > debtSharesBalance) {\n            shares = debtSharesBalance;\n\n            (assets, shares) = SiloMathLib.convertToAssetsOrToShares({\n                _assets: 0,\n                _shares: shares,\n                _totalAssets: totalDebtAssets,\n                _totalShares: totalDebtShares,\n                _roundingToAssets: Rounding.REPAY_TO_ASSETS,\n                _roundingToShares: Rounding.REPAY_TO_SHARES,\n                _assetType: ISilo.AssetType.Debt\n            });\n        }\n\n        require(totalDebtAssets >= assets, ISilo.RepayTooHigh());\n\n        // subtract repayment from debt, save to unchecked because of above `totalDebtAssets < assets`\n        unchecked { $.totalAssets[ISilo.AssetType.Debt] = totalDebtAssets - assets; }\n\n        // Anyone can repay anyone's debt so no approval check is needed.\n        _debtShareToken.burn(_borrower, _repayer, shares);\n        // fee-on-transfer is ignored\n        // Reentrancy is possible only for view methods (read-only reentrancy),\n        // so no harm can be done as the state is already updated.\n        // We do not expect the silo to work with any malicious token that will not send tokens back.\n        IERC20(_debtAsset).safeTransferFrom(_repayer, address(this), assets);\n    }\n\n    /// @notice Accrues interest on assets, updating the collateral and debt balances\n    /// @dev This method will accrue interest for ONE asset ONLY, to calculate for both silos you have to call it twice\n    /// with `_configData` for each token\n    /// @param _interestRateModel The address of the interest rate model to calculate the compound interest rate\n    /// @param _daoFee DAO's fee in 18 decimals points\n    /// @param _deployerFee Deployer's fee in 18 decimals points\n    /// @return accruedInterest The total amount of interest accrued\n    // solhint-disable-next-line function-max-lines\n    function accrueInterestForAsset(address _interestRateModel, uint256 _daoFee, uint256 _deployerFee)\n        external\n        returns (uint256 accruedInterest)\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        uint64 lastTimestamp = $.interestRateTimestamp;\n\n        // Interest has already been accrued this block\n        if (lastTimestamp == block.timestamp) {\n            return 0;\n        }\n\n        // This is the first time, so we can return early and save some gas\n        if (lastTimestamp == 0) {\n            $.interestRateTimestamp = uint64(block.timestamp);\n            return 0;\n        }\n\n        uint256 totalFees;\n        uint256 totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n        uint256 totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n\n        uint256 rcomp = getCompoundInterestRate({\n            _interestRateModel: _interestRateModel,\n            _totalCollateralAssets: totalCollateralAssets,\n            _totalDebtAssets: totalDebtAssets,\n            _lastTimestamp: lastTimestamp\n        });\n\n        if (rcomp == 0) {\n            $.interestRateTimestamp = uint64(block.timestamp);\n            return 0;\n        }\n\n        (\n            $.totalAssets[ISilo.AssetType.Collateral], $.totalAssets[ISilo.AssetType.Debt], totalFees, accruedInterest\n        ) = SiloMathLib.getCollateralAmountsWithInterest({\n            _collateralAssets: totalCollateralAssets,\n            _debtAssets: totalDebtAssets,\n            _rcomp: rcomp,\n            _daoFee: _daoFee,\n            _deployerFee: _deployerFee\n        });\n\n        (accruedInterest, totalFees) = applyFractions({\n            _totalDebtAssets: totalDebtAssets,\n            _rcomp: rcomp,\n            _accruedInterest: accruedInterest,\n            _fees: _daoFee + _deployerFee,\n            _totalFees: totalFees\n        });\n\n        // update remaining contract state\n        $.interestRateTimestamp = uint64(block.timestamp);\n\n        // we operating on chunks (fees) of real tokens, so overflow should not happen\n        // fee is simply too small to overflow on cast to uint192, even if, we will get lower fee\n        // forge-lint: disable-next-line(unsafe-typecast)\n        unchecked { $.daoAndDeployerRevenue += uint192(totalFees); }\n    }\n\n    /// @notice Allows a user or a delegate to borrow assets against their collateral\n    /// @dev The function checks for necessary conditions such as borrow possibility, enough liquidity, and zero\n    /// values\n    /// @param _debtShareToken address of debt share token\n    /// @param _token address of underlying debt token\n    /// @param _spender Address which initiates the borrowing action on behalf of the borrower\n    /// @return borrowedAssets Actual number of assets that the user has borrowed\n    /// @return borrowedShares Number of debt share tokens corresponding to the borrowed assets\n    function borrow(\n        address _debtShareToken,\n        address _token,\n        address _spender,\n        ISilo.BorrowArgs memory _args\n    )\n        internal\n        returns (uint256 borrowedAssets, uint256 borrowedShares)\n    {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        uint256 totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n\n        (borrowedAssets, borrowedShares) = SiloMathLib.convertToAssetsOrToShares(\n            _args.assets,\n            _args.shares,\n            totalDebtAssets,\n            IShareToken(_debtShareToken).totalSupply(),\n            Rounding.BORROW_TO_ASSETS,\n            Rounding.BORROW_TO_SHARES,\n            ISilo.AssetType.Debt\n        );\n\n        uint256 totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n\n        require(\n            _token == address(0) || borrowedAssets <= SiloMathLib.liquidity(totalCollateralAssets, totalDebtAssets),\n            ISilo.NotEnoughLiquidity()\n        );\n\n        // add new debt\n        $.totalAssets[ISilo.AssetType.Debt] = totalDebtAssets + borrowedAssets;\n\n        // `mint` checks if _spender is allowed to borrow on the account of _borrower.\n        IShareToken(_debtShareToken).mint(_args.borrower, _spender, borrowedShares);\n\n        if (_token != address(0)) {\n            // fee-on-transfer is ignored.\n            IERC20(_token).safeTransfer(_args.receiver, borrowedAssets);\n        }\n    }\n\n    /// @notice Determines the maximum amount (both in assets and shares) that a borrower can borrow\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower The address of the borrower whose maximum borrow limit is being queried\n    /// @param _totalDebtAssets The total debt assets in the system\n    /// @param _totalDebtShares The total debt shares in the system\n    /// @param _siloConfig address of SiloConfig contract\n    /// @return assets The maximum amount in assets that can be borrowed\n    /// @return shares The equivalent amount in shares for the maximum assets that can be borrowed\n    function calculateMaxBorrow( // solhint-disable-line function-max-lines\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        uint256 _totalDebtAssets,\n        uint256 _totalDebtShares,\n        ISiloConfig _siloConfig\n    )\n        internal\n        view\n        returns (uint256 assets, uint256 shares)\n    {\n        SiloSolvencyLib.LtvData memory ltvData = SiloSolvencyLib.getAssetsDataForLtvCalculations({\n            _collateralConfig: _collateralConfig,\n            _debtConfig: _debtConfig,\n            _borrower: _borrower,\n            _oracleType: ISilo.OracleType.MaxLtv,\n            _accrueInMemory: ISilo.AccrueInterestInMemory.Yes,\n            _debtShareBalanceCached: 0 /* no cache */\n        });\n\n        // Workaround for fractions. We assume the worst case scenario that we will have integral revenue\n        // that will be subtracted from collateral and integral interest that will be added to debt.\n        {\n            // We need to decrease borrowerCollateralAssets\n            // since we cannot access totalCollateralAssets before calculations.\n            if (ltvData.borrowerCollateralAssets != 0) ltvData.borrowerCollateralAssets--;\n\n            // We need to increase borrowerDebtAssets since we cannot access totalDebtAssets before calculations.\n            // If borrowerDebtAssets is 0 then we have no interest\n            if (ltvData.borrowerDebtAssets != 0) ltvData.borrowerDebtAssets++;\n\n            // It _totalDebtAssets is 0 then we have no interest\n            if (_totalDebtAssets != 0) _totalDebtAssets++;\n        }\n\n        (\n            uint256 sumOfBorrowerCollateralValue, uint256 borrowerDebtValue\n        ) = SiloSolvencyLib.getPositionValues(ltvData, _collateralConfig.token, _debtConfig.token);\n\n        uint256 maxBorrowValue = SiloMathLib.calculateMaxBorrowValue(\n            _collateralConfig.maxLtv,\n            sumOfBorrowerCollateralValue,\n            borrowerDebtValue\n        );\n\n        (assets, shares) = maxBorrowValueToAssetsAndShares({\n            _maxBorrowValue: maxBorrowValue,\n            _debtAsset: _debtConfig.token,\n            _debtOracle: ltvData.debtOracle,\n            _totalDebtAssets: _totalDebtAssets,\n            _totalDebtShares: _totalDebtShares\n        });\n\n        if (assets == 0 || shares == 0) return (0, 0);\n\n        uint256 liquidityWithInterest = getLiquidity(_siloConfig);\n\n        if (liquidityWithInterest != 0) {\n            // We need to count for fractions, when fractions are applied liquidity may be decreased\n            unchecked { liquidityWithInterest -= 1; }\n        }\n\n        if (assets > liquidityWithInterest) {\n            assets = liquidityWithInterest;\n\n            // rounding must follow same flow as in `maxBorrowValueToAssetsAndShares()`\n            shares = SiloMathLib.convertToShares(\n                assets,\n                _totalDebtAssets,\n                _totalDebtShares,\n                Rounding.MAX_BORROW_TO_SHARES,\n                ISilo.AssetType.Debt\n            );\n        }\n    }\n\n    function maxBorrow(address _borrower)\n        internal\n        view\n        returns (uint256 maxAssets, uint256 maxShares)\n    {\n        ISiloConfig siloConfig = ShareTokenLib.siloConfig();\n        if (siloConfig.hasDebtInOtherSilo(address(this), _borrower)) return (0, 0);\n\n        ISiloConfig.ConfigData memory collateralConfig;\n        ISiloConfig.ConfigData memory debtConfig;\n\n        (collateralConfig, debtConfig) = siloConfig.getConfigsForBorrow({_debtSilo: address(this)});\n\n        (uint256 totalDebtAssets, uint256 totalDebtShares) =\n            SiloStdLib.getTotalAssetsAndTotalSharesWithInterest(debtConfig, ISilo.AssetType.Debt);\n\n        return calculateMaxBorrow(\n            collateralConfig,\n            debtConfig,\n            _borrower,\n            totalDebtAssets,\n            totalDebtShares,\n            siloConfig\n        );\n    }\n\n    function getLiquidity(ISiloConfig _siloConfig) internal view returns (uint256 liquidity) {\n        ISiloConfig.ConfigData memory config = _siloConfig.getConfig(address(this));\n        (liquidity,,) = getLiquidityAndAssetsWithInterest(config.interestRateModel, config.daoFee, config.deployerFee);\n    }\n\n    function getLiquidityAndAssetsWithInterest(address _interestRateModel, uint256 _daoFee, uint256 _deployerFee)\n        internal\n        view\n        returns (uint256 liquidity, uint256 totalCollateralAssets, uint256 totalDebtAssets)\n    {\n        totalCollateralAssets = SiloStdLib.getTotalCollateralAssetsWithInterest(\n            address(this),\n            _interestRateModel,\n            _daoFee,\n            _deployerFee\n        );\n\n        totalDebtAssets = SiloStdLib.getTotalDebtAssetsWithInterest(\n            address(this),\n            _interestRateModel\n        );\n\n        liquidity = SiloMathLib.liquidity(totalCollateralAssets, totalDebtAssets);\n    }\n\n    /// @notice Calculates the maximum borrowable assets and shares\n    /// @param _maxBorrowValue The maximum value that can be borrowed by the user\n    /// @param _debtAsset Address of the debt token\n    /// @param _debtOracle Oracle used to get the value of the debt token\n    /// @param _totalDebtAssets Total assets of the debt\n    /// @param _totalDebtShares Total shares of the debt\n    /// @return assets Maximum borrowable assets\n    /// @return shares Maximum borrowable shares\n    // solhint-disable-next-line function-max-lines\n    function maxBorrowValueToAssetsAndShares(\n        uint256 _maxBorrowValue,\n        address _debtAsset,\n        ISiloOracle _debtOracle,\n        uint256 _totalDebtAssets,\n        uint256 _totalDebtShares\n    )\n        internal\n        view\n        returns (uint256 assets, uint256 shares)\n    {\n        if (_maxBorrowValue == 0) {\n            return (0, 0);\n        }\n\n        uint256 debtTokenSample = _PRECISION_DECIMALS;\n\n        uint256 debtSampleValue = address(_debtOracle) == address(0)\n            ? debtTokenSample\n            : _debtOracle.quote(debtTokenSample, _debtAsset);\n\n        assets = _maxBorrowValue.mulDiv(debtTokenSample, debtSampleValue, Rounding.MAX_BORROW_TO_ASSETS);\n\n        // when we borrow, we convertToShares with rounding.Up, to create higher debt, however here,\n        // when we want to calculate \"max borrow\", we can not round.Up, because it can create issue with max ltv,\n        // because we not creating debt here, we calculating max assets/shares, so we need to round.Down here\n        shares = SiloMathLib.convertToShares(\n            assets, _totalDebtAssets, _totalDebtShares, Rounding.MAX_BORROW_TO_SHARES, ISilo.AssetType.Debt\n        );\n\n        {\n            /*\n            This is a workaround for handling fractions:\n\n            - Fractions are not applied in view methods, so we need to account for them manually.\n            - `_totalDebtAssets` is incremented earlier to compensate for these fractions.\n\n            Due to this, increasing `_totalDebtAssets` raises the debt share price. As a result, converting\n            assets to shares yields fewer shares, and this same reduced ratio is applied\n            to the next conversion (shown below). Ultimately, this means we receive fewer shares for the same amount\n            of assets.\n\n            When we call `borrow(assets)` and there are no fractions to apply, `_totalDebtAssets` is not incremented.\n            A lower `_totalDebtAssets` means a lower share price, so the same amount of assets\n            (as calculated by `maxBorrow()`) will result in more shares. At the final step, when checking maxLtv,\n            having more shares translates to more assets—exceeding the allowed maximum LTV.\n\n            Solution:\n            Having fewer shares is acceptable because it underestimates the value due to missing fractions.\n            When recalculating assets (due to the issue described above), we want a lower share price\n            (which occurs when there are no fractions), as this leads to fewer assets and keeps us within the LTV limit.\n\n            Therefore, we decrement `_totalDebtAssets` with `_totalDebtAssets--`\n            to offset the earlier `_totalDebtAssets++`.\n            */\n            if (_totalDebtAssets != 0) {\n                unchecked { _totalDebtAssets--; }\n            }\n        }\n\n        // we need to recalculate assets, because what we did above is assets => shares with rounding down, but when\n        // we input assets, they will generate more shares, so we need to calculate assets based on final shares\n        // not based on borrow value\n        assets = SiloMathLib.convertToAssets(\n            shares, _totalDebtAssets, _totalDebtShares, Rounding.MAX_BORROW_TO_ASSETS, ISilo.AssetType.Debt\n        );\n    }\n\n    function getCompoundInterestRate(\n        address _interestRateModel,\n        uint256 _totalCollateralAssets,\n        uint256 _totalDebtAssets,\n        uint64 _lastTimestamp\n    ) internal returns (uint256 rcomp) {\n        try\n            IInterestRateModel(_interestRateModel).getCompoundInterestRateAndUpdate(\n                _totalCollateralAssets,\n                _totalDebtAssets,\n                _lastTimestamp\n            )\n            returns (uint256 interestRate)\n        {\n            rcomp = interestRate;\n        } catch {\n            // do not lock silo on interest calculation\n            emit IInterestRateModel.InterestRateModelError();\n        }\n    }\n\n    function applyFractions(\n        uint256 _totalDebtAssets,\n        uint256 _rcomp,\n        uint256 _accruedInterest,\n        uint256 _fees,\n        uint256 _totalFees\n    )\n        internal returns (uint256 accruedInterest, uint256 totalFees)\n    {\n        // if _totalDebtAssets is greater than _ROUNDING_THRESHOLD then we don't need to worry\n        // about precision because there is enough amount of debt to generate double wei digit\n        // of interest per second so we can safely ignore fractions\n        if (_totalDebtAssets >= _ROUNDING_THRESHOLD) return (_accruedInterest, _totalFees);\n\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n        uint256 totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n\n        // `accrueInterestForAsset` should never revert,\n        // so we check edge cases for revert and do early return\n        // instead of checking each calculation individually for underflow/overflow\n        if (totalCollateralAssets == type(uint256).max || totalCollateralAssets == 0) {\n            return (_accruedInterest, _totalFees);\n        }\n\n        ISilo.Fractions memory fractions = $.fractions;\n\n        uint256 integralInterest;\n        uint256 integralRevenue;\n\n        (\n            integralInterest, fractions.interest\n        ) = SiloMathLib.calculateFraction(_totalDebtAssets, _rcomp, fractions.interest);\n\n        accruedInterest = _accruedInterest + integralInterest;\n\n        (\n            integralRevenue, fractions.revenue\n        ) = SiloMathLib.calculateFraction(accruedInterest, _fees, fractions.revenue);\n\n        totalFees = _totalFees + integralRevenue;\n\n        $.fractions = fractions;\n        $.totalAssets[ISilo.AssetType.Debt] += integralInterest;\n        $.totalAssets[ISilo.AssetType.Collateral] = totalCollateralAssets + integralInterest - integralRevenue;\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloStdLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\n\nlibrary SiloStdLib {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    /// @notice Returns flash fee amount\n    /// @param _config address of config contract for Silo\n    /// @param _token for which fee is calculated\n    /// @param _amount for which fee is calculated\n    /// @return fee flash fee amount\n    function flashFee(ISiloConfig _config, address _token, uint256 _amount) internal view returns (uint256 fee) {\n        if (_amount == 0) return 0;\n\n        // all user set fees are in 18 decimals points\n        (,, uint256 flashloanFee, address asset) = _config.getFeesWithAsset(address(this));\n        require(_token == asset, ISilo.UnsupportedFlashloanToken());\n        if (flashloanFee == 0) return 0;\n\n        require(type(uint256).max / _amount >= flashloanFee, ISilo.FlashloanAmountTooBig());\n        fee = _amount * flashloanFee / _PRECISION_DECIMALS;\n\n        // round up\n        if (fee == 0) return 1;\n    }\n\n    /// @notice Returns totalAssets and totalShares for conversion math (convertToAssets and convertToShares)\n    /// @dev This is useful for view functions that do not accrue interest before doing calculations. To work on\n    ///      updated numbers, interest should be added on the fly.\n    /// @param _configData for a single token for which to do calculations\n    /// @param _assetType used to read proper storage data\n    /// @return totalAssets total assets in Silo with interest for given asset type\n    /// @return totalShares total shares in Silo for given asset type\n    function getTotalAssetsAndTotalSharesWithInterest(\n        ISiloConfig.ConfigData memory _configData,\n        ISilo.AssetType _assetType\n    )\n        internal\n        view\n        returns (uint256 totalAssets, uint256 totalShares)\n    {\n        if (_assetType == ISilo.AssetType.Protected) {\n            totalAssets = ISilo(_configData.silo).getTotalAssetsStorage(ISilo.AssetType.Protected);\n            totalShares = IShareToken(_configData.protectedShareToken).totalSupply();\n        } else if (_assetType == ISilo.AssetType.Collateral) {\n            totalAssets = getTotalCollateralAssetsWithInterest(\n                _configData.silo,\n                _configData.interestRateModel,\n                _configData.daoFee,\n                _configData.deployerFee\n            );\n\n            totalShares = IShareToken(_configData.collateralShareToken).totalSupply();\n        } else { // ISilo.AssetType.Debt\n            totalAssets = getTotalDebtAssetsWithInterest(_configData.silo, _configData.interestRateModel);\n            totalShares = IShareToken(_configData.debtShareToken).totalSupply();\n        }\n    }\n\n    /// @notice Retrieves fee amounts in 18 decimals points and their respective receivers along with the asset\n    /// @param _silo Silo address\n    /// @return daoFeeReceiver Address of the DAO fee receiver\n    /// @return deployerFeeReceiver Address of the deployer fee receiver\n    /// @return daoFee DAO fee amount in 18 decimals points\n    /// @return deployerFee Deployer fee amount in 18 decimals points\n    /// @return asset Address of the associated asset\n    function getFeesAndFeeReceiversWithAsset(ISilo _silo)\n        internal\n        view\n        returns (\n            address daoFeeReceiver,\n            address deployerFeeReceiver,\n            uint256 daoFee,\n            uint256 deployerFee,\n            address asset\n        )\n    {\n        (daoFee, deployerFee,, asset) = _silo.config().getFeesWithAsset(address(_silo));\n        (daoFeeReceiver, deployerFeeReceiver) = _silo.factory().getFeeReceivers(address(_silo));\n    }\n\n    /// @notice Calculates the total collateral assets with accrued interest\n    /// @dev Do not use this method when accrueInterest were executed already, in that case total does not change\n    /// @param _silo Address of the silo contract\n    /// @param _interestRateModel Interest rate model to fetch compound interest rates\n    /// @param _daoFee DAO fee in 18 decimals points\n    /// @param _deployerFee Deployer fee in 18 decimals points\n    /// @return totalCollateralAssetsWithInterest Accumulated collateral amount with interest\n    function getTotalCollateralAssetsWithInterest(\n        address _silo,\n        address _interestRateModel,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    ) internal view returns (uint256 totalCollateralAssetsWithInterest) {\n        uint256 rcomp;\n\n        try IInterestRateModel(_interestRateModel).getCompoundInterestRate(_silo, block.timestamp) returns (uint256 r) {\n            rcomp = r;\n        } catch {\n            // do not lock silo\n        }\n\n        (uint256 collateralAssets, uint256 debtAssets) = ISilo(_silo).getCollateralAndDebtTotalsStorage();\n\n        (totalCollateralAssetsWithInterest,,,) = SiloMathLib.getCollateralAmountsWithInterest({\n            _collateralAssets: collateralAssets,\n            _debtAssets: debtAssets,\n            _rcomp: rcomp,\n            _daoFee: _daoFee,\n            _deployerFee: _deployerFee\n        });\n    }\n\n    /// @param _balanceCached if balance of `_owner` is unknown beforehand, then pass `0`\n    function getSharesAndTotalSupply(address _shareToken, address _owner, uint256 _balanceCached)\n        internal\n        view\n        returns (uint256 shares, uint256 totalSupply)\n    {\n        if (_balanceCached == 0) {\n            (shares, totalSupply) = IShareToken(_shareToken).balanceOfAndTotalSupply(_owner);\n        } else {\n            shares = _balanceCached;\n            totalSupply = IShareToken(_shareToken).totalSupply();\n        }\n    }\n\n    /// @notice Calculates the total debt assets with accrued interest\n    /// @param _silo Address of the silo contract\n    /// @param _interestRateModel Interest rate model to fetch compound interest rates\n    /// @return totalDebtAssetsWithInterest Accumulated debt amount with interest\n    function getTotalDebtAssetsWithInterest(address _silo, address _interestRateModel)\n        internal\n        view\n        returns (uint256 totalDebtAssetsWithInterest)\n    {\n        uint256 rcomp;\n\n        try IInterestRateModel(_interestRateModel).getCompoundInterestRate(_silo, block.timestamp) returns (uint256 r) {\n            rcomp = r;\n        } catch {\n            // do not lock silo\n        }\n\n        (\n            totalDebtAssetsWithInterest,\n        ) = SiloMathLib.getDebtAmountsWithInterest(ISilo(_silo).getTotalAssetsStorage(ISilo.AssetType.Debt), rcomp);\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloMathLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n// solhint-disable ordering\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\nimport {Rounding} from \"../lib/Rounding.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\n\nlibrary SiloMathLib {\n    using Math for uint256;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    uint256 internal constant _DECIMALS_OFFSET = 3;\n\n    /// @dev this is constant version of openzeppelin5/contracts/token/ERC20/extensions/ERC4626._decimalsOffset\n    uint256 internal constant _DECIMALS_OFFSET_POW = 10 ** _DECIMALS_OFFSET;\n\n    /// @notice Returns available liquidity to be borrowed\n    /// @dev Accrued interest is entirely added to `debtAssets` but only part of it is added to `collateralAssets`. The\n    ///      difference is DAO's and deployer's cut. That means DAO's and deployer's cut is not considered a borrowable\n    ///      liquidity.\n    function liquidity(uint256 _collateralAssets, uint256 _debtAssets) internal pure returns (uint256 liquidAssets) {\n        unchecked {\n            // we checked the underflow\n            liquidAssets = _debtAssets > _collateralAssets ? 0 : _collateralAssets - _debtAssets;\n        }\n    }\n\n    /// @notice Calculate collateral assets with accrued interest and associated fees\n    /// @param _collateralAssets The total amount of collateral assets\n    /// @param _debtAssets The total amount of debt assets\n    /// @param _rcomp Compound interest rate for debt\n    /// @param _daoFee The fee (in 18 decimals points) to be taken for the DAO\n    /// @param _deployerFee The fee (in 18 decimals points) to be taken for the deployer\n    /// @return collateralAssetsWithInterest The total collateral assets including the accrued interest\n    /// @return debtAssetsWithInterest The debt assets with accrued interest\n    /// @return daoAndDeployerRevenue Total fees amount to be split between DAO and deployer\n    /// @return accruedInterest The total accrued interest\n    function getCollateralAmountsWithInterest(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _rcomp,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    )\n        internal\n        pure\n        returns (\n            uint256 collateralAssetsWithInterest,\n            uint256 debtAssetsWithInterest,\n            uint256 daoAndDeployerRevenue,\n            uint256 accruedInterest\n        )\n    {\n        (debtAssetsWithInterest, accruedInterest) = getDebtAmountsWithInterest(_debtAssets, _rcomp);\n\n        uint256 fees;\n\n        // _daoFee and _deployerFee are expected to be less than 1e18, so we will not overflow\n        unchecked { fees = _daoFee + _deployerFee; }\n\n        daoAndDeployerRevenue = mulDivOverflow(accruedInterest, fees, _PRECISION_DECIMALS);\n\n        // we will not underflow because daoAndDeployerRevenue is chunk of accruedInterest\n        uint256 collateralInterest = accruedInterest - daoAndDeployerRevenue;\n\n        uint256 cap;\n        // save to uncheck because variable can not be more than max\n        unchecked { cap = type(uint256).max - _collateralAssets; }\n\n        if (cap < collateralInterest) {\n            // avoid overflow on interest\n            collateralInterest = cap;\n        }\n\n        // safe to uncheck because of cap\n        unchecked {  collateralAssetsWithInterest = _collateralAssets + collateralInterest; }\n    }\n\n    /// @notice Calculate the debt assets with accrued interest, it should never revert with over/under flow\n    /// @param _totalDebtAssets The total amount of debt assets before accrued interest\n    /// @param _rcomp Compound interest rate for the debt in 18 decimal precision\n    /// @return debtAssetsWithInterest The debt assets including the accrued interest\n    /// @return accruedInterest The total amount of interest accrued on the debt assets\n    function getDebtAmountsWithInterest(uint256 _totalDebtAssets, uint256 _rcomp)\n        internal\n        pure\n        returns (uint256 debtAssetsWithInterest, uint256 accruedInterest)\n    {\n        if (_totalDebtAssets == 0 || _rcomp == 0) {\n            return (_totalDebtAssets, 0);\n        }\n\n        accruedInterest = mulDivOverflow(_totalDebtAssets, _rcomp, _PRECISION_DECIMALS);\n\n        unchecked {\n            // We intentionally allow overflow here, to prevent transaction revert due to interest calculation.\n            debtAssetsWithInterest = _totalDebtAssets + accruedInterest;\n\n            // If overflow occurs, we skip accruing interest.\n            if (debtAssetsWithInterest < _totalDebtAssets) {\n                debtAssetsWithInterest = _totalDebtAssets;\n                accruedInterest = 0;\n            }\n        }\n    }\n\n    /// @notice Calculates fraction between borrowed and deposited amount of tokens denominated in percentage\n    /// @dev It assumes `_dp` = 100%.\n    /// @param _dp decimal points used by model\n    /// @param _collateralAssets current total deposits for assets\n    /// @param _debtAssets current total borrows for assets\n    /// @return utilization value, capped to 100%\n    /// Limiting utilization ratio by 100% max will allows us to perform better interest rate computations\n    /// and should not affect any other part of protocol. It is possible to go over 100% only when bad debt.\n    function calculateUtilization(uint256 _dp, uint256 _collateralAssets, uint256 _debtAssets)\n        internal\n        pure\n        returns (uint256 utilization)\n    {\n        if (_collateralAssets == 0 || _debtAssets == 0 || _dp == 0) return 0;\n\n        /*\n            how to prevent overflow on: _debtAssets.mulDiv(_dp, _collateralAssets, Rounding.ACCRUED_INTEREST):\n            1. max > _debtAssets * _dp / _collateralAssets\n            2. max / _dp > _debtAssets / _collateralAssets\n        */\n        if (type(uint256).max / _dp > _debtAssets / _collateralAssets) {\n            utilization = _debtAssets.mulDiv(_dp, _collateralAssets, Rounding.ACCRUED_INTEREST);\n            // cap at 100%\n            if (utilization > _dp) utilization = _dp;\n        } else {\n            // we have overflow\n            utilization = _dp;\n        }\n    }\n\n    function convertToAssetsOrToShares(\n        uint256 _assets,\n        uint256 _shares,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _roundingToAssets,\n        Math.Rounding _roundingToShares,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 assets, uint256 shares) {\n        if (_assets == 0) {\n            require(_shares != 0, ISilo.InputZeroShares());\n            shares = _shares;\n            assets = convertToAssets(_shares, _totalAssets, _totalShares, _roundingToAssets, _assetType);\n            require(assets != 0, ISilo.ReturnZeroAssets());\n        } else if (_shares == 0) {\n            shares = convertToShares(_assets, _totalAssets, _totalShares, _roundingToShares, _assetType);\n            assets = _assets;\n            require(shares != 0, ISilo.ReturnZeroShares());\n        } else {\n            revert ISilo.InputCanBeAssetsOrShares();\n        }\n    }\n\n    /// @dev Math for collateral is exact copy of\n    ///      openzeppelin5/contracts/token/ERC20/extensions/ERC4626._convertToShares\n    function convertToShares(\n        uint256 _assets,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _rounding,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 shares) {\n        (uint256 totalShares, uint256 totalAssets) = _commonConvertTo(_totalAssets, _totalShares, _assetType);\n\n        // initially, in case of debt, if silo is empty we return shares==assets\n        // for collateral, this will never be the case, because we are adding `+1` and offset in `_commonConvertTo`\n        if (totalShares == 0) return _assets;\n\n        shares = _assets.mulDiv(totalShares, totalAssets, _rounding);\n    }\n\n    /// @dev Math for collateral is exact copy of\n    ///      openzeppelin5/contracts/token/ERC20/extensions/ERC4626._convertToAssets\n    function convertToAssets(\n        uint256 _shares,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _rounding,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 assets) {\n        (uint256 totalShares, uint256 totalAssets) = _commonConvertTo(_totalAssets, _totalShares, _assetType);\n\n        // initially, in case of debt, if silo is empty we return shares==assets\n        // for collateral, this will never be the case, because of `+1` in line above\n        if (totalShares == 0) return _shares;\n\n        assets = _shares.mulDiv(totalAssets, totalShares, _rounding);\n    }\n\n    /// @param _collateralMaxLtv maxLTV in 18 decimals that is set for debt asset\n    /// @param _sumOfBorrowerCollateralValue borrower total collateral value (including protected)\n    /// @param _borrowerDebtValue total value of borrower debt\n    /// @return maxBorrowValue max borrow value yet available for borrower\n    function calculateMaxBorrowValue(\n        uint256 _collateralMaxLtv,\n        uint256 _sumOfBorrowerCollateralValue,\n        uint256 _borrowerDebtValue\n    ) internal pure returns (uint256 maxBorrowValue) {\n        if (_sumOfBorrowerCollateralValue == 0) {\n            return 0;\n        }\n\n        uint256 maxDebtValue = _sumOfBorrowerCollateralValue.mulDiv(\n            _collateralMaxLtv, _PRECISION_DECIMALS, Rounding.MAX_BORROW_VALUE\n        );\n\n        unchecked {\n            // we will not underflow because we checking `maxDebtValue > _borrowerDebtValue`\n            maxBorrowValue = maxDebtValue > _borrowerDebtValue ? maxDebtValue - _borrowerDebtValue : 0;\n        }\n    }\n\n    /// @notice Calculate the maximum assets a borrower can withdraw without breaching the liquidation threshold\n    /// @param _sumOfCollateralsValue The combined value of collateral and protected assets of the borrower\n    /// @param _debtValue The total debt value of the borrower\n    /// @param _lt The liquidation threshold in 18 decimal points\n    /// @param _borrowerCollateralAssets The borrower's collateral assets before the withdrawal\n    /// @param _borrowerProtectedAssets The borrower's protected assets before the withdrawal\n    /// @return maxAssets The maximum assets the borrower can safely withdraw\n    function calculateMaxAssetsToWithdraw(\n        uint256 _sumOfCollateralsValue,\n        uint256 _debtValue,\n        uint256 _lt,\n        uint256 _borrowerCollateralAssets,\n        uint256 _borrowerProtectedAssets\n    ) internal pure returns (uint256 maxAssets) {\n        if (_sumOfCollateralsValue == 0) return 0;\n        if (_debtValue == 0) return _sumOfCollateralsValue;\n        if (_lt == 0) return 0;\n\n        // using Rounding.LT (up) to have highest collateralValue that we have to leave for user to stay solvent\n        uint256 minimumCollateralValue = _debtValue.mulDiv(_PRECISION_DECIMALS, _lt, Rounding.LTV);\n\n        // if we over LT, we can not withdraw\n        if (_sumOfCollateralsValue <= minimumCollateralValue) {\n            return 0;\n        }\n\n        uint256 spareCollateralValue;\n        // safe because we checked `if (_sumOfCollateralsValue <= minimumCollateralValue)`\n        unchecked { spareCollateralValue = _sumOfCollateralsValue - minimumCollateralValue; }\n\n        maxAssets = (_borrowerProtectedAssets + _borrowerCollateralAssets)\n                .mulDiv(spareCollateralValue, _sumOfCollateralsValue, Rounding.MAX_WITHDRAW_TO_ASSETS);\n    }\n\n    /// @notice Determines the maximum number of assets and corresponding shares a borrower can safely withdraw\n    /// @param _maxAssets The calculated limit on how many assets can be withdrawn without breaching the liquidation\n    /// threshold\n    /// @param _borrowerCollateralAssets Amount of collateral assets currently held by the borrower\n    /// @param _borrowerProtectedAssets Amount of protected assets currently held by the borrower\n    /// @param _collateralType Specifies whether the asset is of type Collateral or Protected\n    /// @param _totalAssets The entire quantity of assets available in the system for withdrawal\n    /// @param _assetTypeShareTokenTotalSupply Total supply of share tokens for the specified asset type\n    /// @param _liquidity Current liquidity in the system for the asset type\n    /// @return assets Maximum assets the borrower can withdraw\n    /// @return shares Corresponding number of shares for the derived `assets` amount\n    function maxWithdrawToAssetsAndShares(\n        uint256 _maxAssets,\n        uint256 _borrowerCollateralAssets,\n        uint256 _borrowerProtectedAssets,\n        ISilo.CollateralType _collateralType,\n        uint256 _totalAssets,\n        uint256 _assetTypeShareTokenTotalSupply,\n        uint256 _liquidity\n    ) internal pure returns (uint256 assets, uint256 shares) {\n        if (_maxAssets == 0) return (0, 0);\n        if (_assetTypeShareTokenTotalSupply == 0) return (0, 0);\n\n        if (_collateralType == ISilo.CollateralType.Collateral) {\n            assets = _maxAssets > _borrowerCollateralAssets ? _borrowerCollateralAssets : _maxAssets;\n\n            if (assets > _liquidity) {\n                assets = _liquidity;\n            }\n        } else {\n            assets = _maxAssets > _borrowerProtectedAssets ? _borrowerProtectedAssets : _maxAssets;\n        }\n\n        shares = SiloMathLib.convertToShares(\n            assets,\n            _totalAssets,\n            _assetTypeShareTokenTotalSupply,\n            Rounding.MAX_WITHDRAW_TO_SHARES,\n            ISilo.AssetType(uint256(_collateralType))\n        );\n    }\n\n    /// @dev executed `_a * _b / _c`, reverts on _c == 0\n    /// @return mulDivResult on overflow returns 0\n    function mulDivOverflow(uint256 _a, uint256 _b, uint256 _c)\n        internal\n        pure\n        returns (uint256 mulDivResult)\n    {\n        if (_a == 0) return (0);\n\n        unchecked {\n            // we have to uncheck to detect overflow\n            mulDivResult = _a * _b;\n            if (mulDivResult / _a != _b) return 0;\n\n            mulDivResult /= _c;\n        }\n    }\n\n    /// @dev Debt calculations should not lower the result. Debt is a liability so protocol should not take any for\n    /// itself. It should return actual result and round it up.\n    function _commonConvertTo(\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        ISilo.AssetType _assetType\n    ) private pure returns (uint256 totalShares, uint256 totalAssets) {\n        if (_totalShares == 0) {\n            // silo is empty and we have dust to redistribute: this can only happen when everyone exits silo\n            // this case can happen only for collateral, because for collateral we rounding in favorite of protocol\n            // by resetting totalAssets, the dust that we have will go to first depositor and we starts from clean state\n            _totalAssets = 0;\n        }\n\n            (totalShares, totalAssets) = _assetType == ISilo.AssetType.Debt\n                ? (_totalShares, _totalAssets)\n                : (_totalShares + _DECIMALS_OFFSET_POW, _totalAssets + 1);\n    }\n\n    /// @dev Calculates the fraction of a given total and percentage\n    /// @param _total The total value to calculate the fraction from\n    /// @param _percent The percentage to calculate the fraction from\n    /// @param _currentFraction The current fraction to add to the result\n    /// @return integral The integral part of the fraction\n    /// @return fraction The fractional part of the fraction\n    function calculateFraction(\n        uint256 _total,\n        uint256 _percent,\n        uint64 _currentFraction\n    ) internal pure returns (uint256 integral, uint64 fraction) {\n        if (_total == 0) {\n            return (0, _currentFraction);\n        }\n\n        unchecked {\n            // safe to unchecked because: _currentFraction if never more than max uint256, div is safe\n            if (type(uint256).max / _total < _percent) {\n                // when overflow, reset `_currentFraction ` to zero as part of circuit breaker\n                return (0, 0);\n            }\n\n            // `_total * _percent` safe to unchecked because we checked for overflow in above `if`\n            // `% _PRECISION_DECIMALS` safe, because max value after modulo will be 1e18 - 1  (_PRECISION_DECIMALS - 1)\n            // and this is less than 2 ** 64\n            // calculate remainder for current interest\n            uint256 remainder = (_total * _percent) % _PRECISION_DECIMALS;\n            // integral is amount above 1e18 after adding _currentFraction and remainder\n            integral = (_currentFraction + remainder) / _PRECISION_DECIMALS;\n            // fraction is what we get below 1e18\n            // Safe: modulo by `_PRECISION_DECIMALS` guarantees value <= 1e18 - 1, far below uint64 max.\n            // forge-lint: disable-next-line(unsafe-typecast)\n            fraction = uint64((_currentFraction + remainder) % _PRECISION_DECIMALS);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/Rounding.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\n// solhint-disable private-vars-leading-underscore\nlibrary Rounding {\n    Math.Rounding internal constant UP = Math.Rounding.Ceil;\n    Math.Rounding internal constant DOWN = Math.Rounding.Floor;\n    Math.Rounding internal constant DEBT_TO_ASSETS = Math.Rounding.Ceil;\n    // COLLATERAL_TO_ASSETS is used to calculate borrower collateral (so we want to round down)\n    Math.Rounding internal constant COLLATERAL_TO_ASSETS = Math.Rounding.Floor;\n    // why DEPOSIT_TO_ASSETS is Up if COLLATERAL_TO_ASSETS is Down?\n    // DEPOSIT_TO_ASSETS is used for preview deposit and deposit, based on provided shares we want to pull \"more\" tokens\n    // so we rounding up, \"token flow\" is in different direction than for COLLATERAL_TO_ASSETS, that's why\n    // different rounding policy\n    Math.Rounding internal constant DEPOSIT_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant DEPOSIT_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant BORROW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant BORROW_TO_SHARES = Math.Rounding.Ceil;\n    Math.Rounding internal constant MAX_BORROW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_BORROW_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_BORROW_VALUE = Math.Rounding.Floor;\n    Math.Rounding internal constant REPAY_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant REPAY_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_REPAY_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant WITHDRAW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant WITHDRAW_TO_SHARES = Math.Rounding.Ceil;\n    Math.Rounding internal constant MAX_WITHDRAW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_WITHDRAW_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant LIQUIDATE_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant LTV = Math.Rounding.Ceil;\n    Math.Rounding internal constant ACCRUED_INTEREST = Math.Rounding.Floor;\n    Math.Rounding internal constant DAO_REVENUE = Math.Rounding.Ceil;\n}\n"
    },
    "silo-core/contracts/lib/ShareTokenLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Strings} from \"openzeppelin5/utils/Strings.sol\";\n\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\n\nimport {TokenHelper} from \"../lib/TokenHelper.sol\";\nimport {CallBeforeQuoteLib} from \"../lib/CallBeforeQuoteLib.sol\";\nimport {Hook} from \"../lib/Hook.sol\";\n\n// solhint-disable ordering\n\nlibrary ShareTokenLib {\n    using Hook for uint24;\n    using CallBeforeQuoteLib for ISiloConfig.ConfigData;\n\n    // keccak256(abi.encode(uint256(keccak256(\"silo.storage.ShareToken\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _STORAGE_LOCATION = 0x01b0b3f9d6e360167e522fa2b18ba597ad7b2b35841fec7e1ca4dbb0adea1200;\n\n    function getShareTokenStorage() internal pure returns (IShareToken.ShareTokenStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, private-vars-leading-underscore\n    function __ShareToken_init(ISilo _silo, address _hookReceiver, uint24 _tokenType) external {\n        IShareToken.ShareTokenStorage storage $ = ShareTokenLib.getShareTokenStorage();\n\n        $.silo = _silo;\n        $.siloConfig = _silo.config();\n\n        $.hookSetup.hookReceiver = _hookReceiver;\n        $.hookSetup.tokenType = _tokenType;\n        $.transferWithChecks = true;\n    }\n\n    /// @dev decimals of share token\n    function decimals() external view returns (uint8) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        return uint8(TokenHelper.assertAndGetDecimals(configData.token));\n    }\n\n    /// @dev Name convention:\n    ///      NAME - asset name\n    ///      SILO_ID - unique silo id\n    ///\n    ///      Protected deposit: \"Silo Finance Non-borrowable NAME Deposit, SiloId: SILO_ID\"\n    ///      Borrowable deposit: \"Silo Finance Borrowable NAME Deposit, SiloId: SILO_ID\"\n    ///      Debt: \"Silo Finance NAME Debt, SiloId: SILO_ID\"\n    function name() external view returns (string memory) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        string memory siloIdAscii = Strings.toString($.siloConfig.SILO_ID());\n\n        string memory pre = \"\";\n        string memory post = \" Deposit\";\n\n        if (address(this) == configData.protectedShareToken) {\n            pre = \"Non-borrowable \";\n        } else if (address(this) == configData.collateralShareToken) {\n            pre = \"Borrowable \";\n        } else if (address(this) == configData.debtShareToken) {\n            post = \" Debt\";\n        }\n\n        string memory tokenSymbol = TokenHelper.symbol(configData.token);\n        return string.concat(\"Silo Finance \", pre, tokenSymbol, post, \", SiloId: \", siloIdAscii);\n    }\n\n    /// @dev Symbol convention:\n    ///      SYMBOL - asset symbol\n    ///      SILO_ID - unique silo id\n    ///\n    ///      Protected deposit: \"nbSYMBOL-SILO_ID\"\n    ///      Borrowable deposit: \"bSYMBOL-SILO_ID\"\n    ///      Debt: \"dSYMBOL-SILO_ID\"\n    function symbol() external view returns (string memory) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        string memory siloIdAscii = Strings.toString($.siloConfig.SILO_ID());\n\n        string memory pre;\n\n        if (address(this) == configData.protectedShareToken) {\n            pre = \"nb\";\n        } else if (address(this) == configData.collateralShareToken) {\n            pre = \"b\";\n        } else if (address(this) == configData.debtShareToken) {\n            pre = \"d\";\n        }\n\n        string memory tokenSymbol = TokenHelper.symbol(configData.token);\n        return string.concat(pre, tokenSymbol, \"-\", siloIdAscii);\n    }\n\n    /// @notice Call beforeQuote on solvency oracles\n    /// @param _user user address for which the solvent check is performed\n    function callOracleBeforeQuote(ISiloConfig _siloConfig, address _user) internal {\n        (\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        ) = _siloConfig.getConfigsForSolvency(_user);\n\n        collateralConfig.callSolvencyOracleBeforeQuote();\n        debtConfig.callSolvencyOracleBeforeQuote();\n    }\n\n    /// @dev Call on behalf of share token\n    /// @param _target target address to call\n    /// @param _value value to send\n    /// @param _callType call type\n    /// @param _input input data\n    /// @return success true if the call was successful, false otherwise\n    /// @return result bytes returned by the call\n    function callOnBehalfOfShareToken(address _target, uint256 _value, ISilo.CallType _callType, bytes calldata _input)\n        internal\n        returns (bool success, bytes memory result)\n    {\n        // Share token will not send back any ether leftovers after the call.\n        // The hook receiver should request the ether if needed in a separate call.\n        if (_callType == ISilo.CallType.Delegatecall) {\n            (success, result) = _target.delegatecall(_input); // solhint-disable-line avoid-low-level-calls\n        } else {\n            (success, result) = _target.call{value: _value}(_input); // solhint-disable-line avoid-low-level-calls\n        }\n    }\n\n    /// @dev checks if operation is \"real\" transfer\n    /// @param _sender sender address\n    /// @param _recipient recipient address\n    /// @return bool true if operation is real transfer, false if it is mint or burn\n    function isTransfer(address _sender, address _recipient) internal pure returns (bool) {\n        // in order this check to be true, it is required to have:\n        // require(sender != address(0), \"ERC20: transfer from the zero address\");\n        // require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        // on transfer. ERC20 has them, so we good.\n        return _sender != address(0) && _recipient != address(0);\n    }\n\n    function siloConfig() internal view returns (ISiloConfig thisSiloConfig) {\n        return ShareTokenLib.getShareTokenStorage().siloConfig;\n    }\n\n    function getConfig() internal view returns (ISiloConfig.ConfigData memory thisSiloConfigData) {\n        thisSiloConfigData = ShareTokenLib.getShareTokenStorage().siloConfig.getConfig(address(this));\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloStorageLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\n\nlibrary SiloStorageLib {\n    // keccak256(abi.encode(uint256(keccak256(\"silo.storage.SiloVault\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant _STORAGE_LOCATION = 0xd7513ffe3a01a9f6606089d1b67011bca35bec018ac0faa914e1c529408f8300;\n\n    function getSiloStorage() internal pure returns (ISilo.SiloStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "silo-core/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/// @notice https://eips.ethereum.org/EIPS/eip-3156\ninterface IERC3156FlashLender {\n    /// @notice Protected deposits are not available for a flash loan.\n    /// During the execution of the flashloan, Silo methods are not taking into consideration the fact,\n    /// that some (or all) tokens were transferred as flashloan, therefore some methods can return invalid state\n    /// eg. maxWithdraw can return amount that are not available to withdraw during flashlon.\n    /// @dev Initiate a flash loan.\n    /// @param _receiver The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)\n        external\n        returns (bool);\n\n    /// @dev The amount of currency available to be lent.\n    /// @param _token The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address _token) external view returns (uint256);\n\n    /// @dev The fee to be charged for a given loan.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address _token, uint256 _amount) external view returns (uint256);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "silo-core/contracts/interfaces/IDynamicKinkModelConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IDynamicKinkModel} from \"./IDynamicKinkModel.sol\";\n\ninterface IDynamicKinkModelConfig {\n    /// @return config returns immutable IRM configuration that is present in contract\n    function getConfig() \n        external \n        view \n        returns (IDynamicKinkModel.Config memory config, IDynamicKinkModel.ImmutableConfig memory immutableConfig);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return a == 0 ? 0 : (a - 1) / b + 1;\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.UNDER_OVERFLOW);\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, expect 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Ferma's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return x < 0 ? (n - uint256(-x)) : uint256(x); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked has failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "silo-core/contracts/lib/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IsContract} from \"./IsContract.sol\";\n\nlibrary TokenHelper {\n    uint256 private constant _BYTES32_SIZE = 32;\n\n    error TokenIsNotAContract();\n\n    function assertAndGetDecimals(address _token) internal view returns (uint256) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.decimals, ()));\n\n        // decimals() is optional in the ERC20 standard, so if metadata is not accessible\n        // we assume there are no decimals and use 0.\n        if (!hasMetadata) {\n            return 0;\n        }\n\n        return abi.decode(data, (uint8));\n    }\n\n    /// @dev Returns the symbol for the provided ERC20 token.\n    /// An empty string is returned if the call to the token didn't succeed.\n    /// @param _token address of the token to get the symbol for\n    /// @return assetSymbol the token symbol\n    function symbol(address _token) internal view returns (string memory assetSymbol) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.symbol, ()));\n\n        if (!hasMetadata || data.length == 0) {\n            return \"?\";\n        } else if (data.length == _BYTES32_SIZE) {\n            return string(removeZeros(data));\n        } else {\n            return abi.decode(data, (string));\n        }\n    }\n\n    /// @dev Removes bytes with value equal to 0 from the provided byte array.\n    /// @param _data byte array from which to remove zeroes\n    /// @return result byte array with zeroes removed\n    function removeZeros(bytes memory _data) internal pure returns (bytes memory result) {\n        uint256 n = _data.length;\n\n        for (uint256 i; i < n; i++) {\n            if (_data[i] == 0) continue;\n\n            result = abi.encodePacked(result, _data[i]);\n        }\n    }\n\n    /// @dev Performs a staticcall to the token to get its metadata (symbol, decimals, name)\n    function _tokenMetadataCall(address _token, bytes memory _data) private view returns (bool, bytes memory) {\n        // We need to do this before the call, otherwise the call will succeed even for EOAs\n        require(IsContract.isContract(_token), TokenIsNotAContract());\n\n        (bool success, bytes memory result) = _token.staticcall(_data);\n\n        // If the call reverted we assume the token doesn't follow the metadata extension\n        if (!success) {\n            return (false, \"\");\n        }\n\n        return (true, result);\n    }\n}\n"
    },
    "silo-core/contracts/lib/CallBeforeQuoteLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\n\nlibrary CallBeforeQuoteLib {\n    /// @dev Call `beforeQuote` on the `solvencyOracle` oracle\n    /// @param _config Silo config data\n    function callSolvencyOracleBeforeQuote(ISiloConfig.ConfigData memory _config) internal {\n        if (_config.callBeforeQuote && _config.solvencyOracle != address(0)) {\n            ISiloOracle(_config.solvencyOracle).beforeQuote(_config.token);\n        }\n    }\n\n    /// @dev Call `beforeQuote` on the `maxLtvOracle` oracle\n    /// @param _config Silo config data\n    function callMaxLtvOracleBeforeQuote(ISiloConfig.ConfigData memory _config) internal {\n        if (_config.callBeforeQuote && _config.maxLtvOracle != address(0)) {\n            ISiloOracle(_config.maxLtvOracle).beforeQuote(_config.token);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IERC3156FlashBorrower {\n    /// @notice During the execution of the flashloan, Silo methods are not taking into consideration the fact,\n    /// that some (or all) tokens were transferred as flashloan, therefore some methods can return invalid state\n    /// eg. maxWithdraw can return amount that are not available to withdraw during flashlon.\n    /// @dev Receive a flash loan.\n    /// @param _initiator The initiator of the loan.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _fee The additional amount of tokens to repay.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    /// @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n    function onFlashLoan(address _initiator, address _token, uint256 _amount, uint256 _fee, bytes calldata _data)\n        external\n        returns (bytes32);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/IsContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nlibrary IsContract {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address _account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return _account.code.length > 0;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=gitmodules/forge-std/src/",
      "silo-foundry-utils/=gitmodules/silo-foundry-utils/contracts/",
      "properties/=gitmodules/crytic/properties/contracts/",
      "silo-core/=silo-core/",
      "silo-oracles/=silo-oracles/",
      "silo-vaults/=silo-vaults/",
      "@openzeppelin/=gitmodules/openzeppelin-contracts-5/",
      "morpho-blue/=gitmodules/morpho-blue/src/",
      "openzeppelin5/=gitmodules/openzeppelin-contracts-5/contracts/",
      "openzeppelin5-upgradeable/=gitmodules/openzeppelin-contracts-upgradeable-5/contracts/",
      "chainlink/=gitmodules/chainlink/contracts/src/",
      "chainlink-ccip/=gitmodules/chainlink-ccip/contracts/src/",
      "uniswap/=gitmodules/uniswap/",
      "@uniswap/v3-core/=gitmodules/uniswap/v3-core/",
      "pyth-sdk-solidity/=gitmodules/pyth-sdk-solidity/target_chains/ethereum/sdk/solidity/",
      "a16z-erc4626-tests/=gitmodules/a16z-erc4626-tests/",
      "@ensdomains/=node_modules/@ensdomains/",
      "@solidity-parser/=node_modules/prettier-plugin-solidity/node_modules/@solidity-parser/",
      "ERC4626/=gitmodules/crytic/properties/lib/ERC4626/contracts/",
      "createx/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/src/",
      "crytic/=gitmodules/crytic/",
      "ds-test/=gitmodules/openzeppelin-contracts-5/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=gitmodules/openzeppelin-contracts-5/lib/erc4626-tests/",
      "halmos-cheatcodes/=gitmodules/morpho-blue/lib/halmos-cheatcodes/src/",
      "hardhat/=node_modules/hardhat/",
      "openzeppelin-contracts-5/=gitmodules/openzeppelin-contracts-5/",
      "openzeppelin-contracts-upgradeable-5/=gitmodules/openzeppelin-contracts-upgradeable-5/",
      "openzeppelin-contracts-upgradeable/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/",
      "prettier-plugin-solidity/=node_modules/prettier-plugin-solidity/",
      "solady/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/lib/solady/",
      "solmate/=gitmodules/crytic/properties/lib/solmate/src/",
      "x-silo/=node_modules/x-silo/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false
  }
}