{
  "language": "Solidity",
  "sources": {
    "silo-core/contracts/hooks/SiloHookV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.28;\n\nimport {ISiloConfig} from \"silo-core/contracts/interfaces/ISiloConfig.sol\";\nimport {IHookReceiver} from \"silo-core/contracts/interfaces/IHookReceiver.sol\";\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\nimport {IVersioned} from \"silo-core/contracts/interfaces/IVersioned.sol\";\n\nimport {GaugeHookReceiver} from \"silo-core/contracts/hooks/gauge/GaugeHookReceiver.sol\";\nimport {PartialLiquidationByDefaulting} from \"silo-core/contracts/hooks/defaulting/PartialLiquidationByDefaulting.sol\";\nimport {BaseHookReceiver} from \"silo-core/contracts/hooks/_common/BaseHookReceiver.sol\";\n\ncontract SiloHookV2 is GaugeHookReceiver, PartialLiquidationByDefaulting, IVersioned {\n    function VERSION() external pure virtual returns (string memory) { // solhint-disable-line func-name-mixedcase\n        return \"SiloHookV2 4.0.0\";\n    }\n\n    /// @inheritdoc IHookReceiver\n    function initialize(ISiloConfig _config, bytes calldata _data) public virtual initializer {\n        (address owner) = abi.decode(_data, (address));\n\n        BaseHookReceiver.__BaseHookReceiver_init(_config);\n        GaugeHookReceiver.__GaugeHookReceiver_init(owner);\n        PartialLiquidationByDefaulting.__PartialLiquidationByDefaulting_init(owner);\n    }\n\n    /// @inheritdoc IHookReceiver\n    function beforeAction(address, uint256, bytes calldata) public virtual override onlySilo {\n        // Do not expect any actions.\n        revert RequestNotSupported();\n    }\n\n    /// @inheritdoc IHookReceiver\n    function afterAction(address _silo, uint256 _action, bytes calldata _inputAndOutput)\n        public\n        virtual\n        override(GaugeHookReceiver, IHookReceiver)\n        onlySiloOrShareToken\n    {\n        GaugeHookReceiver.afterAction(_silo, _action, _inputAndOutput);\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISilo} from \"./ISilo.sol\";\nimport {ICrossReentrancyGuard} from \"./ICrossReentrancyGuard.sol\";\n\ninterface ISiloConfig is ICrossReentrancyGuard {\n    struct InitData {\n        /// @notice Can be address zero if deployer fees are not to be collected. If deployer address is zero then\n        /// deployer fee must be zero as well. Deployer will be minted an NFT that gives the right to claim deployer\n        /// fees. NFT can be transferred with the right to claim.\n        address deployer;\n\n        /// @notice Address of the hook receiver called on every before/after action on Silo. Hook contract also\n        /// implements liquidation logic and veSilo gauge connection.\n        address hookReceiver;\n\n        /// @notice Deployer's fee in 18 decimals points. Deployer will earn this fee based on the interest earned\n        /// by the Silo. Max deployer fee is set by the DAO. At deployment it is 15%.\n        uint256 deployerFee;\n\n        /// @notice DAO's fee in 18 decimals points. DAO will earn this fee based on the interest earned\n        /// by the Silo. Acceptable fee range fee is set by the DAO. Default at deployment is 5% - 50%.\n        uint256 daoFee;\n\n        /// @notice Address of the first token\n        address token0;\n\n        /// @notice Address of the solvency oracle. Solvency oracle is used to calculate LTV when deciding if borrower\n        /// is solvent or should be liquidated. Solvency oracle is optional and if not set price of 1 will be assumed.\n        address solvencyOracle0;\n\n        /// @notice Address of the maxLtv oracle. Max LTV oracle is used to calculate LTV when deciding if borrower\n        /// can borrow given amount of assets. Max LTV oracle is optional and if not set it defaults to solvency\n        /// oracle. If neither is set price of 1 will be assumed.\n        address maxLtvOracle0;\n\n        /// @notice Address of the interest rate model\n        address interestRateModel0;\n\n        /// @notice Maximum LTV for first token. maxLTV is in 18 decimals points and is used to determine, if borrower\n        /// can borrow given amount of assets. MaxLtv is in 18 decimals points. MaxLtv must be lower or equal to LT.\n        uint256 maxLtv0;\n\n        /// @notice Liquidation threshold for first token. LT is used to calculate solvency. LT is in 18 decimals\n        /// points. LT must not be lower than maxLTV.\n        uint256 lt0;\n\n        /// @notice minimal acceptable LTV after liquidation, in 18 decimals points\n        uint256 liquidationTargetLtv0;\n\n        /// @notice Liquidation fee for the first token in 18 decimals points. Liquidation fee is what liquidator earns\n        /// for repaying insolvent loan.\n        uint256 liquidationFee0;\n\n        /// @notice Flashloan fee sets the cost of taking a flashloan in 18 decimals points\n        uint256 flashloanFee0;\n\n        /// @notice Indicates if a beforeQuote on oracle contract should be called before quoting price\n        bool callBeforeQuote0;\n\n        /// @notice Address of the second token\n        address token1;\n\n        /// @notice Address of the solvency oracle. Solvency oracle is used to calculate LTV when deciding if borrower\n        /// is solvent or should be liquidated. Solvency oracle is optional and if not set price of 1 will be assumed.\n        address solvencyOracle1;\n\n        /// @notice Address of the maxLtv oracle. Max LTV oracle is used to calculate LTV when deciding if borrower\n        /// can borrow given amount of assets. Max LTV oracle is optional and if not set it defaults to solvency\n        /// oracle. If neither is set price of 1 will be assumed.\n        address maxLtvOracle1;\n\n        /// @notice Address of the interest rate model\n        address interestRateModel1;\n\n        /// @notice Maximum LTV for first token. maxLTV is in 18 decimals points and is used to determine,\n        /// if borrower can borrow given amount of assets. maxLtv is in 18 decimals points\n        uint256 maxLtv1;\n\n        /// @notice Liquidation threshold for first token. LT is used to calculate solvency. LT is in 18 decimals points\n        uint256 lt1;\n\n        /// @notice minimal acceptable LTV after liquidation, in 18 decimals points\n        uint256 liquidationTargetLtv1;\n\n        /// @notice Liquidation fee is what liquidator earns for repaying insolvent loan.\n        uint256 liquidationFee1;\n\n        /// @notice Flashloan fee sets the cost of taking a flashloan in 18 decimals points\n        uint256 flashloanFee1;\n\n        /// @notice Indicates if a beforeQuote on oracle contract should be called before quoting price\n        bool callBeforeQuote1;\n    }\n\n    struct ConfigData {\n        uint256 daoFee;\n        uint256 deployerFee;\n        address silo;\n        address token;\n        address protectedShareToken;\n        address collateralShareToken;\n        address debtShareToken;\n        address solvencyOracle;\n        address maxLtvOracle;\n        address interestRateModel;\n        uint256 maxLtv;\n        uint256 lt;\n        uint256 liquidationTargetLtv;\n        uint256 liquidationFee;\n        uint256 flashloanFee;\n        address hookReceiver;\n        bool callBeforeQuote;\n    }\n\n    struct DepositConfig {\n        address silo;\n        address token;\n        address collateralShareToken;\n        address protectedShareToken;\n        uint256 daoFee;\n        uint256 deployerFee;\n        address interestRateModel;\n    }\n\n    error OnlySilo();\n    error OnlySiloOrTokenOrHookReceiver();\n    error WrongSilo();\n    error OnlyDebtShareToken();\n    error DebtExistInOtherSilo();\n    error FeeTooHigh();\n    error Deprecated();\n\n    /// @dev It should be called on debt transfer (debt share token transfer).\n    /// In the case if the`_recipient` doesn't have configured a collateral silo,\n    /// it will be set to the collateral silo of the `_sender`.\n    /// @param _sender sender address\n    /// @param _recipient recipient address\n    function onDebtTransfer(address _sender, address _recipient) external;\n\n    /// @notice deprecated\n    function setThisSiloAsCollateralSilo(address _borrower) external returns (bool collateralSiloChanged);\n\n    /// @notice Set collateral silo\n    /// @dev Revert if msg.sender is not a SILO_0 or SILO_1.\n    /// @dev Always set collateral silo opposite to the msg.sender.\n    /// @param _borrower borrower address\n    /// @return collateralSiloChanged TRUE if collateral silo changed\n    function setOtherSiloAsCollateralSilo(address _borrower) external returns (bool collateralSiloChanged);\n\n    /// @notice Accrue interest for the silo\n    /// @param _silo silo for which accrue interest\n    function accrueInterestForSilo(address _silo) external;\n\n    /// @notice Accrue interest for both silos (SILO_0 and SILO_1 in a config)\n    function accrueInterestForBothSilos() external;\n\n    /// @notice Retrieves the collateral silo for a specific borrower.\n    /// @dev As a user can deposit into `Silo0` and `Silo1`, this property specifies which Silo\n    /// will be used as collateral for the debt. Later on, it will be used for max LTV and solvency checks.\n    /// After being set, the collateral silo is never set to `address(0)` again but such getters as\n    /// `getConfigsForSolvency`, `getConfigsForBorrow`, `getConfigsForWithdraw` will return empty\n    /// collateral silo config if borrower doesn't have debt.\n    ///\n    /// In the SiloConfig collateral silo is set by the following functions:\n    /// `onDebtTransfer` - only if the recipient doesn't have collateral silo set (inherits it from the sender)\n    /// This function is called on debt share token transfer (debt transfer).\n    /// `setOtherSiloAsCollateralSilo` - sets the opposite silo as collateral from the one that calls the function.\n    ///\n    /// In the Silo collateral silo is set by the following functions:\n    /// `borrow` - always sets opposite silo as collateral.\n    /// If Silo0 borrows, then Silo1 will be collateral and vice versa.\n    /// @param _borrower The address of the borrower for which the collateral silo is being retrieved\n    /// @return collateralSilo The address of the collateral silo for the specified borrower\n    function borrowerCollateralSilo(address _borrower) external view returns (address collateralSilo);\n\n    /// @notice Retrieves the silo ID\n    /// @dev Each silo is assigned a unique ID. ERC-721 token is minted with identical ID to deployer.\n    /// An owner of that token receives the deployer fees.\n    /// @return siloId The ID of the silo\n    function SILO_ID() external view returns (uint256 siloId); // solhint-disable-line func-name-mixedcase\n\n    /// @notice Retrieves the addresses of the two silos\n    /// @return silo0 The address of the first silo\n    /// @return silo1 The address of the second silo\n    function getSilos() external view returns (address silo0, address silo1);\n\n    /// @notice Retrieves the asset associated with a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which the associated asset is being retrieved\n    /// @return asset The address of the asset associated with the specified silo\n    function getAssetForSilo(address _silo) external view returns (address asset);\n\n    /// @notice Verifies if the borrower has debt in other silo by checking the debt share token balance\n    /// @param _thisSilo The address of the silo in respect of which the debt is checked\n    /// @param _borrower The address of the borrower for which the debt is checked\n    /// @return hasDebt true if the borrower has debt in other silo\n    function hasDebtInOtherSilo(address _thisSilo, address _borrower) external view returns (bool hasDebt);\n\n    /// @notice Retrieves the debt silo associated with a specific borrower\n    /// @dev This function reverts if debt present in two silo (should not happen)\n    /// @param _borrower The address of the borrower for which the debt silo is being retrieved\n    function getDebtSilo(address _borrower) external view returns (address debtSilo);\n\n    /// @notice Retrieves configuration data for both silos. First config is for the silo that is asking for configs.\n    /// @param borrower borrower address for which debtConfig will be returned\n    /// @return collateralConfig The configuration data for collateral silo (empty if there is no debt).\n    /// @return debtConfig The configuration data for debt silo (empty if there is no debt).\n    function getConfigsForSolvency(address borrower)\n        external\n        view\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig);\n\n    /// @notice Retrieves configuration data for a specific silo\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _silo The address of the silo for which configuration data is being retrieved\n    /// @return config The configuration data for the specified silo\n    function getConfig(address _silo) external view returns (ConfigData memory config);\n\n    /// @notice Retrieves configuration data for a specific silo for withdraw fn.\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _silo The address of the silo for which configuration data is being retrieved\n    /// @return depositConfig The configuration data for the specified silo (always config for `_silo`)\n    /// @return collateralConfig The configuration data for the collateral silo (empty if there is no debt)\n    /// @return debtConfig The configuration data for the debt silo (empty if there is no debt)\n    function getConfigsForWithdraw(address _silo, address _borrower) external view returns (\n        DepositConfig memory depositConfig,\n        ConfigData memory collateralConfig,\n        ConfigData memory debtConfig\n    );\n\n    /// @notice Retrieves configuration data for a specific silo for borrow fn.\n    /// @dev This function reverts for incorrect silo address input.\n    /// @param _debtSilo The address of the silo for which configuration data is being retrieved\n    /// @return collateralConfig The configuration data for the collateral silo (always other than `_debtSilo`)\n    /// @return debtConfig The configuration data for the debt silo (always config for `_debtSilo`)\n    function getConfigsForBorrow(address _debtSilo)\n        external\n        view\n        returns (ConfigData memory collateralConfig, ConfigData memory debtConfig);\n\n    /// @notice Retrieves fee-related information for a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which fee-related information is being retrieved.\n    /// @return daoFee The DAO fee percentage in 18 decimals points.\n    /// @return deployerFee The deployer fee percentage in 18 decimals points.\n    /// @return flashloanFee The flashloan fee percentage in 18 decimals points.\n    /// @return asset The address of the asset associated with the specified silo.\n    function getFeesWithAsset(address _silo)\n        external\n        view\n        returns (uint256 daoFee, uint256 deployerFee, uint256 flashloanFee, address asset);\n\n    /// @notice Retrieves share tokens associated with a specific silo\n    /// @dev This function reverts for incorrect silo address input\n    /// @param _silo The address of the silo for which share tokens are being retrieved\n    /// @return protectedShareToken The address of the protected (non-borrowable) share token\n    /// @return collateralShareToken The address of the collateral share token\n    /// @return debtShareToken The address of the debt share token\n    function getShareTokens(address _silo)\n        external\n        view\n        returns (address protectedShareToken, address collateralShareToken, address debtShareToken);\n\n    /// @notice Retrieves the share token and the silo token associated with a specific silo\n    /// @param _silo The address of the silo for which the share token and silo token are being retrieved\n    /// @param _collateralType The type of collateral\n    /// @return shareToken The address of the share token (collateral or protected collateral)\n    /// @return asset The address of the silo token\n    function getCollateralShareTokenAndAsset(address _silo, ISilo.CollateralType _collateralType)\n        external\n        view\n        returns (address shareToken, address asset);\n\n    /// @notice Retrieves the share token and the silo token associated with a specific silo\n    /// @param _silo The address of the silo for which the share token and silo token are being retrieved\n    /// @return shareToken The address of the share token (debt)\n    /// @return asset The address of the silo token\n    function getDebtShareTokenAndAsset(address _silo)\n        external\n        view\n        returns (address shareToken, address asset);\n}\n"
    },
    "silo-core/contracts/interfaces/IHookReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\ninterface IHookReceiver {\n    struct HookConfig {\n        uint24 hooksBefore;\n        uint24 hooksAfter;\n    }\n\n    event HookConfigured(address silo, uint24 hooksBefore, uint24 hooksAfter);\n\n    /// @dev Revert if provided silo configuration during initialization is empty\n    error EmptySiloConfig();\n    /// @dev Revert if the hook receiver is already configured/initialized\n    error AlreadyConfigured();\n    /// @dev Revert if the caller is not a silo\n    error OnlySilo();\n    /// @dev Revert if the caller is not a silo or a share token\n    error OnlySiloOrShareToken();\n\n    /// @notice Initialize a hook receiver\n    /// @param _siloConfig Silo configuration with all the details about the silo\n    /// @param _data Data to initialize the hook receiver (if needed)\n    function initialize(ISiloConfig _siloConfig, bytes calldata _data) external;\n\n    /// @notice state of Silo before action, can be also without interest, if you need them, call silo.accrueInterest()\n    function beforeAction(address _silo, uint256 _action, bytes calldata _input) external;\n\n    function afterAction(address _silo, uint256 _action, bytes calldata _inputAndOutput) external;\n\n    /// @notice return hooksBefore and hooksAfter configuration\n    function hookReceiverConfig(address _silo) external view returns (uint24 hooksBefore, uint24 hooksAfter);\n}\n"
    },
    "silo-core/contracts/interfaces/ISilo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC4626, IERC20, IERC20Metadata} from \"openzeppelin5/interfaces/IERC4626.sol\";\n\nimport {IERC3156FlashLender} from \"./IERC3156FlashLender.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\nimport {ISiloFactory} from \"./ISiloFactory.sol\";\n\nimport {IHookReceiver} from \"./IHookReceiver.sol\";\n\n// solhint-disable ordering\ninterface ISilo is IERC20, IERC4626, IERC3156FlashLender {\n    /// @dev Interest accrual happens on each deposit/withdraw/borrow/repay. View methods work on storage that might be\n    ///      outdate. Some calculations require accrued interest to return current state of Silo. This struct is used\n    ///      to make a decision inside functions if interest should be accrued in memory to work on updated values.\n    enum AccrueInterestInMemory {\n        No,\n        Yes\n    }\n\n    /// @dev Silo has two separate oracles for solvency and maxLtv calculations. MaxLtv oracle is optional. Solvency\n    ///      oracle can also be optional if asset is used as denominator in Silo config. For example, in ETH/USDC Silo\n    ///      one could setup only solvency oracle for ETH that returns price in USDC. Then USDC does not need an oracle\n    ///      because it's used as denominator for ETH and it's \"price\" can be assume as 1.\n    enum OracleType {\n        Solvency,\n        MaxLtv\n    }\n\n    /// @dev There are 3 types of accounting in the system: for non-borrowable collateral deposit called \"protected\",\n    ///      for borrowable collateral deposit called \"collateral\" and for borrowed tokens called \"debt\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum AssetType {\n        Protected, // default\n        Collateral,\n        Debt\n    }\n\n    /// @dev There are 2 types of accounting in the system: for non-borrowable collateral deposit called \"protected\" and\n    ///      for borrowable collateral deposit called \"collateral\". System does\n    ///      identical calculations for each type of accounting but it uses different data. To avoid code duplication\n    ///      this enum is used to decide which data should be read.\n    enum CollateralType {\n        Protected, // default\n        Collateral\n    }\n\n    /// @dev Types of calls that can be made by the hook receiver on behalf of Silo via `callOnBehalfOfSilo` fn\n    enum CallType {\n        Call, // default\n        Delegatecall\n    }\n\n    /// @param _assets Amount of assets the user wishes to withdraw. Use 0 if shares are provided.\n    /// @param _shares Shares the user wishes to burn in exchange for the withdrawal. Use 0 if assets are provided.\n    /// @param _receiver Address receiving the withdrawn assets\n    /// @param _owner Address of the owner of the shares being burned\n    /// @param _spender Address executing the withdrawal; may be different than `_owner` if an allowance was set\n    /// @param _collateralType Type of the asset being withdrawn (Collateral or Protected)\n    struct WithdrawArgs {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        ISilo.CollateralType collateralType;\n    }\n\n    /// @param assets Number of assets the borrower intends to borrow. Use 0 if shares are provided.\n    /// @param shares Number of shares corresponding to the assets that the borrower intends to borrow. Use 0 if\n    /// assets are provided.\n    /// @param receiver Address that will receive the borrowed assets\n    /// @param borrower The user who is borrowing the assets\n    struct BorrowArgs {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n    }\n\n    /// @param shares Amount of shares the user wishes to transit.\n    /// @param owner owner of the shares after transition.\n    /// @param transitionFrom type of collateral that will be transitioned.\n    struct TransitionCollateralArgs {\n        uint256 shares;\n        address owner;\n        ISilo.CollateralType transitionFrom;\n    }\n\n    struct UtilizationData {\n        /// @dev COLLATERAL: Amount of asset token that has been deposited to Silo plus interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        uint256 collateralAssets;\n        /// @dev DEBT: Amount of asset token that has been borrowed plus accrued interest.\n        uint256 debtAssets;\n        /// @dev timestamp of the last interest accrual\n        uint64 interestRateTimestamp;\n    }\n\n    /// @dev Interest and revenue may be rounded down to zero if the underlying token's decimal is low.\n    /// Because of that, we need to store fractions for further calculation to minimize losses.\n    struct Fractions {\n        /// @dev interest value that we could not convert to full token in 36 decimals, max value for it is 1e18.\n        /// this value was not yet apply as interest for borrowers\n        uint64 interest;\n        /// @dev revenue value that we could not convert to full token in 36 decimals, max value for it is 1e18.\n        uint64 revenue;\n    }\n\n    struct SiloStorage {\n        /// @param daoAndDeployerRevenue Current amount of assets (fees) accrued by DAO and Deployer\n        /// but not yet withdrawn\n        uint192 daoAndDeployerRevenue;\n        /// @dev timestamp of the last interest accrual\n        uint64 interestRateTimestamp;\n        /// @dev Interest and revenue fractions for more precise calculations\n        Fractions fractions;\n\n        /// @dev silo is just for one asset,\n        /// but this one asset can be of three types: mapping key is uint256(AssetType), so we store `assets` by type.\n        /// Assets based on type:\n        /// - PROTECTED COLLATERAL: Amount of asset token that has been deposited to Silo that can be ONLY used\n        /// as collateral. These deposits do NOT earn interest and CANNOT be borrowed.\n        /// - COLLATERAL: Amount of asset token that has been deposited to Silo plus interest earned by depositors.\n        /// It also includes token amount that has been borrowed.\n        /// - DEBT: Amount of asset token that has been borrowed plus accrued interest.\n        /// `totalAssets` can have outdated value (without interest), if you doing view call (of off-chain call)\n        /// please use getters eg `getCollateralAssets()` to fetch value that includes interest.\n        mapping(AssetType assetType => uint256 assets) totalAssets;\n    }\n\n    /// @notice Emitted on protected deposit\n    /// @param sender wallet address that deposited asset\n    /// @param owner wallet address that received shares in Silo\n    /// @param assets amount of asset that was deposited\n    /// @param shares amount of shares that was minted\n    event DepositProtected(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @notice Emitted on protected withdraw\n    /// @param sender wallet address that sent transaction\n    /// @param receiver wallet address that received asset\n    /// @param owner wallet address that owned asset\n    /// @param assets amount of asset that was withdrew\n    /// @param shares amount of shares that was burn\n    event WithdrawProtected(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Emitted on borrow\n    /// @param sender wallet address that sent transaction\n    /// @param receiver wallet address that received asset\n    /// @param owner wallet address that owes assets\n    /// @param assets amount of asset that was borrowed\n    /// @param shares amount of shares that was minted\n    event Borrow(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /// @notice Emitted on repayment\n    /// @param sender wallet address that repaid asset\n    /// @param owner wallet address that owed asset\n    /// @param assets amount of asset that was repaid\n    /// @param shares amount of shares that was burn\n    event Repay(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    /// @notice emitted only when collateral has been switched to other one\n    event CollateralTypeChanged(address indexed borrower);\n\n    event HooksUpdated(uint24 hooksBefore, uint24 hooksAfter);\n\n    event AccruedInterest(uint256 hooksBefore);\n\n    event FlashLoan(uint256 amount);\n\n    event WithdrawnFees(uint256 daoFees, uint256 deployerFees, bool redirectedDeployerFees);\n\n    event DeployerFeesRedirected(uint256 deployerFees);\n\n    error UnsupportedFlashloanToken();\n    error FlashloanAmountTooBig();\n    error NothingToWithdraw();\n    error ProtectedProtection();\n    error NotEnoughLiquidity();\n    error NotSolvent();\n    error BorrowNotPossible();\n    error EarnedZero();\n    error FlashloanFailed();\n    error AboveMaxLtv();\n    error SiloInitialized();\n    error OnlyHookReceiver();\n    error NoLiquidity();\n    error InputCanBeAssetsOrShares();\n    error CollateralSiloAlreadySet();\n    error RepayTooHigh();\n    error ZeroAmount();\n    error InputZeroShares();\n    error ReturnZeroAssets();\n    error ReturnZeroShares();\n    error Deprecated();\n\n    /// @return siloFactory The associated factory of the silo\n    function factory() external view returns (ISiloFactory siloFactory);\n\n    /// @notice Method for HookReceiver only to call on behalf of Silo\n    /// @param _target address of the contract to call\n    /// @param _value amount of ETH to send\n    /// @param _callType type of the call (Call or Delegatecall)\n    /// @param _input calldata for the call\n    function callOnBehalfOfSilo(address _target, uint256 _value, CallType _callType, bytes calldata _input)\n        external\n        payable\n        returns (bool success, bytes memory result);\n\n    /// @notice Initialize Silo\n    /// @param _siloConfig address of ISiloConfig with full config for this Silo\n    function initialize(ISiloConfig _siloConfig) external;\n\n    /// @notice Update hooks configuration for Silo\n    /// @dev This function must be called after the hooks configuration is changed in the hook receiver\n    function updateHooks() external;\n\n    /// @notice Fetches the silo configuration contract\n    /// @return siloConfig Address of the configuration contract associated with the silo\n    function config() external view returns (ISiloConfig siloConfig);\n\n    /// @notice Fetches the utilization data of the silo used by IRM\n    function utilizationData() external view returns (UtilizationData memory utilizationData);\n\n    /// @notice Fetches the real (available to borrow) liquidity in the silo, it does include interest\n    /// @return liquidity The amount of liquidity\n    function getLiquidity() external view returns (uint256 liquidity);\n\n    /// @notice Determines if a borrower is solvent\n    /// @param _borrower Address of the borrower to check for solvency\n    /// @return True if the borrower is solvent, otherwise false\n    function isSolvent(address _borrower) external view returns (bool);\n\n    /// @notice Retrieves the raw total amount of assets based on provided type (direct storage access)\n    function getTotalAssetsStorage(AssetType _assetType) external view returns (uint256);\n\n    /// @notice Direct storage access to silo storage\n    /// @dev See struct `SiloStorage` for more details\n    function getSiloStorage()\n        external\n        view\n        returns (\n            uint192 daoAndDeployerRevenue,\n            uint64 interestRateTimestamp,\n            uint256 protectedAssets,\n            uint256 collateralAssets,\n            uint256 debtAssets\n        );\n\n    /// @notice Direct access to silo storage fractions variables\n    function getFractionsStorage() external view returns (Fractions memory fractions);\n\n    /// @notice Retrieves the total amount of collateral (borrowable) assets with interest\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    function getCollateralAssets() external view returns (uint256 totalCollateralAssets);\n\n    /// @notice Retrieves the total amount of debt assets with interest\n    /// @return totalDebtAssets The total amount of assets of type 'Debt'\n    function getDebtAssets() external view returns (uint256 totalDebtAssets);\n\n    /// @notice Retrieves the total amounts of collateral and protected (non-borrowable) assets\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    /// @return totalProtectedAssets The total amount of protected (non-borrowable) assets\n    function getCollateralAndProtectedTotalsStorage()\n        external\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalProtectedAssets);\n\n    /// @notice Retrieves the total amounts of collateral and debt assets\n    /// @return totalCollateralAssets The total amount of assets of type 'Collateral'\n    /// @return totalDebtAssets The total amount of debt assets of type 'Debt'\n    function getCollateralAndDebtTotalsStorage()\n        external\n        view\n        returns (uint256 totalCollateralAssets, uint256 totalDebtAssets);\n\n    /// @notice Implements IERC4626.convertToShares for each asset type\n    function convertToShares(uint256 _assets, AssetType _assetType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.convertToAssets for each asset type\n    function convertToAssets(uint256 _shares, AssetType _assetType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.previewDeposit for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewDeposit(uint256 _assets, CollateralType _collateralType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.deposit for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function deposit(uint256 _assets, address _receiver, CollateralType _collateralType)\n        external\n        returns (uint256 shares);\n\n    /// @notice Implements IERC4626.previewMint for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewMint(uint256 _shares, CollateralType _collateralType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.mint for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function mint(uint256 _shares, address _receiver, CollateralType _collateralType) external returns (uint256 assets);\n\n    /// @notice Implements IERC4626.maxWithdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function maxWithdraw(address _owner, CollateralType _collateralType) external view returns (uint256 maxAssets);\n\n    /// @notice Implements IERC4626.previewWithdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewWithdraw(uint256 _assets, CollateralType _collateralType) external view returns (uint256 shares);\n\n    /// @notice Implements IERC4626.withdraw for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function withdraw(uint256 _assets, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        returns (uint256 shares);\n\n    /// @notice Implements IERC4626.maxRedeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function maxRedeem(address _owner, CollateralType _collateralType) external view returns (uint256 maxShares);\n\n    /// @notice Implements IERC4626.previewRedeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function previewRedeem(uint256 _shares, CollateralType _collateralType) external view returns (uint256 assets);\n\n    /// @notice Implements IERC4626.redeem for protected (non-borrowable) collateral and collateral\n    /// @dev Reverts for debt asset type\n    function redeem(uint256 _shares, address _receiver, address _owner, CollateralType _collateralType)\n        external\n        returns (uint256 assets);\n\n    /// @notice Calculates the maximum amount of assets that can be borrowed by the given address\n    /// @param _borrower Address of the potential borrower\n    /// @return maxAssets Maximum amount of assets that the borrower can borrow, this value is underestimated\n    /// That means, in some cases when you borrow maxAssets, you will be able to borrow again eg. up to 2wei\n    /// Reason for underestimation is to return value that will not cause borrow revert\n    function maxBorrow(address _borrower) external view returns (uint256 maxAssets);\n\n    /// @notice Previews the amount of shares equivalent to the given asset amount for borrowing\n    /// @param _assets Amount of assets to preview the equivalent shares for\n    /// @return shares Amount of shares equivalent to the provided asset amount\n    function previewBorrow(uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Allows an address to borrow a specified amount of assets\n    /// @param _assets Amount of assets to borrow\n    /// @param _receiver Address receiving the borrowed assets\n    /// @param _borrower Address responsible for the borrowed assets\n    /// @return shares Amount of shares equivalent to the borrowed assets\n    function borrow(uint256 _assets, address _receiver, address _borrower)\n        external returns (uint256 shares);\n\n    /// @notice Calculates the maximum amount of shares that can be borrowed by the given address\n    /// @param _borrower Address of the potential borrower\n    /// @return maxShares Maximum number of shares that the borrower can borrow\n    function maxBorrowShares(address _borrower) external view returns (uint256 maxShares);\n\n    /// @notice Previews the amount of assets equivalent to the given share amount for borrowing\n    /// @param _shares Amount of shares to preview the equivalent assets for\n    /// @return assets Amount of assets equivalent to the provided share amount\n    function previewBorrowShares(uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice deprecated\n    function maxBorrowSameAsset(address _borrower) external view returns (uint256 maxAssets);\n\n    /// @notice deprecated\n    function borrowSameAsset(uint256 _assets, address _receiver, address _borrower)\n        external returns (uint256 shares);\n\n    /// @notice Allows a user to borrow assets based on the provided share amount\n    /// @param _shares Amount of shares to borrow against\n    /// @param _receiver Address to receive the borrowed assets\n    /// @param _borrower Address responsible for the borrowed assets\n    /// @return assets Amount of assets borrowed\n    function borrowShares(uint256 _shares, address _receiver, address _borrower)\n        external\n        returns (uint256 assets);\n\n    /// @notice Calculates the maximum amount an address can repay based on their debt shares\n    /// @param _borrower Address of the borrower\n    /// @return assets Maximum amount of assets the borrower can repay\n    function maxRepay(address _borrower) external view returns (uint256 assets);\n\n    /// @notice Provides an estimation of the number of shares equivalent to a given asset amount for repayment\n    /// @param _assets Amount of assets to be repaid\n    /// @return shares Estimated number of shares equivalent to the provided asset amount\n    function previewRepay(uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Repays a given asset amount and returns the equivalent number of shares\n    /// @param _assets Amount of assets to be repaid\n    /// @param _borrower Address of the borrower whose debt is being repaid\n    /// @return shares The equivalent number of shares for the provided asset amount\n    function repay(uint256 _assets, address _borrower) external returns (uint256 shares);\n\n    /// @notice Calculates the maximum number of shares that can be repaid for a given borrower\n    /// @param _borrower Address of the borrower\n    /// @return shares The maximum number of shares that can be repaid for the borrower\n    function maxRepayShares(address _borrower) external view returns (uint256 shares);\n\n    /// @notice Provides a preview of the equivalent assets for a given number of shares to repay\n    /// @param _shares Number of shares to preview repayment for\n    /// @return assets Equivalent assets for the provided shares\n    function previewRepayShares(uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice Allows a user to repay a loan using shares instead of assets\n    /// @param _shares The number of shares the borrower wants to repay with\n    /// @param _borrower The address of the borrower for whom to repay the loan\n    /// @return assets The equivalent assets amount for the provided shares\n    function repayShares(uint256 _shares, address _borrower) external returns (uint256 assets);\n\n    /// @notice Transitions assets between borrowable (collateral) and non-borrowable (protected) states\n    /// @dev This function allows assets to move between collateral and protected (non-borrowable) states without\n    /// leaving the protocol\n    /// @param _shares Amount of shares to be transitioned\n    /// @param _owner Owner of the assets being transitioned\n    /// @param _transitionFrom Specifies if the transition is from collateral or protected assets\n    /// @return assets Amount of assets transitioned\n    function transitionCollateral(uint256 _shares, address _owner, CollateralType _transitionFrom)\n        external\n        returns (uint256 assets);\n\n    /// @notice deprecated\n    function switchCollateralToThisSilo() external;\n\n    /// @notice Accrues interest for the asset and returns the accrued interest amount\n    /// @return accruedInterest The total interest accrued during this operation\n    function accrueInterest() external returns (uint256 accruedInterest);\n\n    /// @notice only for SiloConfig\n    function accrueInterestForConfig(\n        address _interestRateModel,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    ) external;\n\n    /// @notice Withdraws earned fees and distributes them to the DAO and deployer fee receivers\n    function withdrawFees() external;\n}\n"
    },
    "silo-core/contracts/interfaces/IVersioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IVersioned {\n    /// @notice Returns the version of the contract\n    /// @return version The version of the contract in format \"SiloLens v3.17.0\"\n    function VERSION() external pure returns (string memory version); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "silo-core/contracts/hooks/gauge/GaugeHookReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\n// solhint-disable ordering\n\nimport {Ownable1and2Steps} from \"common/access/Ownable1and2Steps.sol\";\nimport {IShareToken} from \"silo-core/contracts/interfaces/IShareToken.sol\";\nimport {ISiloConfig} from \"silo-core/contracts/interfaces/ISiloConfig.sol\";\nimport {IPartialLiquidation} from \"silo-core/contracts/interfaces/IPartialLiquidation.sol\";\nimport {Hook} from \"silo-core/contracts/lib/Hook.sol\";\nimport {ISiloIncentivesController} from \"silo-core/contracts/incentives/interfaces/ISiloIncentivesController.sol\";\nimport {IGaugeHookReceiver, IHookReceiver} from \"silo-core/contracts/interfaces/IGaugeHookReceiver.sol\";\nimport {BaseHookReceiver} from \"silo-core/contracts/hooks/_common/BaseHookReceiver.sol\";\n\n/// @notice Silo share token hook receiver for the gauge.\n/// It notifies the gauge (if configured) about any balance update in the Silo share token.\nabstract contract GaugeHookReceiver is BaseHookReceiver, IGaugeHookReceiver, Ownable1and2Steps {\n    using Hook for uint256;\n    using Hook for bytes;\n    \n    mapping(IShareToken => ISiloIncentivesController) public configuredGauges;\n\n    constructor() Ownable1and2Steps(msg.sender) {\n        // lock implementation\n        _transferOwnership(address(0));\n    }\n\n    /// @inheritdoc IGaugeHookReceiver\n    function setGauge(ISiloIncentivesController _gauge, IShareToken _shareToken) external virtual onlyOwner {\n        require(address(_gauge) != address(0), EmptyGaugeAddress());\n        require(_gauge.SHARE_TOKEN() == address(_shareToken), WrongGaugeShareToken());\n\n        address configuredGauge = address(configuredGauges[_shareToken]);\n\n        require(configuredGauge == address(0), GaugeAlreadyConfigured());\n\n        address silo = address(_shareToken.silo());\n\n        uint256 tokenType = _getTokenType(silo, address(_shareToken));\n        uint256 hooksAfter = _getHooksAfter(silo);\n\n        uint256 action = tokenType | Hook.SHARE_TOKEN_TRANSFER;\n        hooksAfter = hooksAfter.addAction(action);\n\n        _setHookConfig(silo, uint24(_getHooksBefore(silo)), uint24(hooksAfter));\n\n        configuredGauges[_shareToken] = _gauge;\n\n        emit GaugeConfigured(address(_gauge), address(_shareToken));\n    }\n\n    /// @inheritdoc IGaugeHookReceiver\n    function removeGauge(IShareToken _shareToken) external virtual onlyOwner {\n        ISiloIncentivesController configuredGauge = configuredGauges[_shareToken];\n\n        require(address(configuredGauge) != address(0), GaugeIsNotConfigured());\n\n        delete configuredGauges[_shareToken];\n\n        emit GaugeRemoved(address(_shareToken));\n    }\n\n    /// @inheritdoc IHookReceiver\n    function afterAction(address _silo, uint256 _action, bytes calldata _inputAndOutput)\n        public\n        virtual\n        override\n    {\n        ISiloIncentivesController theGauge = configuredGauges[IShareToken(msg.sender)];\n\n        if (theGauge == ISiloIncentivesController(address(0))) return;\n        if (!_getHooksAfter(_silo).matchAction(_action)) return;\n\n        Hook.AfterTokenTransfer memory input = _inputAndOutput.afterTokenTransferDecode();\n\n        theGauge.afterTokenTransfer(\n            input.sender,\n            input.senderBalance,\n            input.recipient,\n            input.recipientBalance,\n            input.totalSupply,\n            input.amount\n        );\n    }\n\n    /// @notice Get the token type for the share token\n    /// @param _silo Silo address for which tokens was deployed\n    /// @param _shareToken Share token address\n    /// @dev Revert if wrong silo\n    /// @dev Revert if the share token is not one of the collateral, protected or debt tokens\n    function _getTokenType(address _silo, address _shareToken) internal view virtual returns (uint256) {\n        (\n            address protectedShareToken,\n            address collateralShareToken,\n            address debtShareToken\n        ) = siloConfig.getShareTokens(_silo);\n\n        if (_shareToken == collateralShareToken) return Hook.COLLATERAL_TOKEN;\n        if (_shareToken == protectedShareToken) return Hook.PROTECTED_TOKEN;\n        if (_shareToken == debtShareToken) return Hook.DEBT_TOKEN;\n\n        revert InvalidShareToken();\n    }\n\n    /// @notice Set the owner of the hook receiver\n    /// @param _owner Owner address\n    function __GaugeHookReceiver_init(address _owner) // solhint-disable-line func-name-mixedcase\n        internal\n        onlyInitializing\n        virtual\n    {\n        require(_owner != address(0), OwnerIsZeroAddress());\n\n        _transferOwnership(_owner);\n    }\n}\n"
    },
    "silo-core/contracts/hooks/defaulting/PartialLiquidationByDefaulting.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloIncentivesController} from \"silo-core/contracts/incentives/interfaces/ISiloIncentivesController.sol\";\nimport {IGaugeHookReceiver, IHookReceiver} from \"silo-core/contracts/interfaces/IGaugeHookReceiver.sol\";\nimport {IPartialLiquidationByDefaulting} from \"silo-core/contracts/interfaces/IPartialLiquidationByDefaulting.sol\";\n\nimport {SiloStorageLib} from \"silo-core/contracts/lib/SiloStorageLib.sol\";\nimport {PartialLiquidationLib} from \"silo-core/contracts/hooks/liquidation/lib/PartialLiquidationLib.sol\";\n\nimport {\n    PartialLiquidation,\n    Rounding,\n    SiloMathLib,\n    ISiloConfig,\n    ISilo,\n    IShareToken,\n    PartialLiquidationExecLib,\n    RevertLib,\n    CallBeforeQuoteLib\n} from \"../liquidation/PartialLiquidation.sol\";\nimport {DefaultingSiloLogic} from \"./DefaultingSiloLogic.sol\";\nimport {Whitelist} from \"silo-core/contracts/hooks/_common/Whitelist.sol\";\n\n// solhint-disable ordering\n\n/// @title PartialLiquidation module for executing liquidations\n/// @dev if we need additional hook functionality, this contract should be included as parent\nabstract contract PartialLiquidationByDefaulting is IPartialLiquidationByDefaulting, PartialLiquidation, Whitelist {\n    using CallBeforeQuoteLib for ISiloConfig.ConfigData;\n\n    /// @inheritdoc IPartialLiquidationByDefaulting\n    uint256 public constant KEEPER_FEE = 0.2e18;\n\n    /// @inheritdoc IPartialLiquidationByDefaulting\n    address public immutable LIQUIDATION_LOGIC;\n\n    /// @inheritdoc IPartialLiquidationByDefaulting\n    uint256 public constant LT_MARGIN_FOR_DEFAULTING = 0.025e18;\n\n    uint256 internal constant _DECIMALS_PRECISION = 1e18;\n\n    constructor() {\n        LIQUIDATION_LOGIC = address(new DefaultingSiloLogic());\n    }\n\n    function __PartialLiquidationByDefaulting_init(address _owner) // solhint-disable-line func-name-mixedcase\n        internal\n        virtual\n        onlyInitializing\n    {\n        __Whitelist_init(_owner);\n\n        validateDefaultingCollateral();\n    }\n\n    /// @inheritdoc IPartialLiquidationByDefaulting\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function liquidationCallByDefaulting(address _borrower)\n        external\n        virtual\n        nonReentrant\n        onlyAllowedOrPublic\n        returns (uint256 withdrawCollateral, uint256 repayDebtAssets)\n    {\n        ISiloConfig siloConfigCached = siloConfig;\n\n        require(address(siloConfigCached) != address(0), EmptySiloConfig());\n\n        siloConfigCached.turnOnReentrancyProtection();\n\n        (ISiloConfig.ConfigData memory collateralConfig, ISiloConfig.ConfigData memory debtConfig) =\n            _fetchConfigs(siloConfigCached, _borrower);\n\n        collateralConfig.lt += LT_MARGIN_FOR_DEFAULTING;\n\n        CallParams memory params;\n\n        (\n            params.withdrawAssetsFromCollateral, params.withdrawAssetsFromProtected, repayDebtAssets, params.customError\n        ) = PartialLiquidationExecLib.getExactLiquidationAmounts({\n            _collateralConfig: collateralConfig,\n            _debtConfig: debtConfig,\n            _user: _borrower,\n            _maxDebtToCover: type(uint256).max,\n            _liquidationFee: collateralConfig.liquidationFee\n        });\n\n        RevertLib.revertIfError(params.customError);\n\n        // calculate split between keeper and lenders\n        (params.collateralSharesTotal, params.collateralSharesForKeeper, params.collateralSharesForLenders) =\n            _getKeeperAndLenderSharesSplit({\n                _silo: collateralConfig.silo,\n                _shareToken: collateralConfig.collateralShareToken,\n                _liquidationFee: collateralConfig.liquidationFee,\n                _assetsToLiquidate: params.withdrawAssetsFromCollateral,\n                _collateralType: ISilo.CollateralType.Collateral\n            });\n\n        (params.protectedSharesTotal, params.protectedSharesForKeeper, params.protectedSharesForLenders) =\n            _getKeeperAndLenderSharesSplit({\n                _silo: collateralConfig.silo,\n                _shareToken: collateralConfig.protectedShareToken,\n                _liquidationFee: collateralConfig.liquidationFee,\n                _assetsToLiquidate: params.withdrawAssetsFromProtected,\n                _collateralType: ISilo.CollateralType.Protected\n            });\n\n        _liquidateByDistributingCollateral({\n            _borrower: _borrower,\n            _debtSilo: debtConfig.silo,\n            _shareToken: collateralConfig.collateralShareToken,\n            _withdrawSharesForLenders: params.collateralSharesForLenders,\n            _withdrawSharesForKeeper: params.collateralSharesForKeeper\n        });\n\n        _liquidateByDistributingCollateral({\n            _borrower: _borrower,\n            _debtSilo: debtConfig.silo,\n            _shareToken: collateralConfig.protectedShareToken,\n            _withdrawSharesForLenders: params.protectedSharesForLenders,\n            _withdrawSharesForKeeper: params.protectedSharesForKeeper\n        });\n\n        // calculate total withdrawn collateral\n\n        if (params.collateralSharesTotal != 0) {\n            withdrawCollateral = ISilo(collateralConfig.silo).previewRedeem(\n                params.collateralSharesTotal, ISilo.CollateralType.Collateral\n            );\n        }\n\n        if (params.protectedSharesTotal != 0) {\n            withdrawCollateral += ISilo(collateralConfig.silo).previewRedeem(\n                params.protectedSharesTotal, ISilo.CollateralType.Protected\n            );\n        }\n\n        _deductDefaultedDebtFromCollateral(debtConfig.silo, repayDebtAssets);\n\n        siloConfigCached.turnOffReentrancyProtection();\n\n        // settle debt without transferring tokens to silo, by defaulting on debt repayment\n\n        // during actual repay we have conversion assets -> shares -> assets, so we can loose some precision\n        // it is possible to deduct 1 wei less from debtTotalAssets than from collateralTotalAssets because of rounding\n        (, repayDebtAssets) = _repayDebtByDefaulting(debtConfig.silo, repayDebtAssets, _borrower);\n\n        emit LiquidationCall(msg.sender, debtConfig.silo, _borrower, repayDebtAssets, withdrawCollateral, true);\n    }\n\n    function getKeeperAndLenderSharesSplit(\n        uint256 _assetsToLiquidate,\n        ISilo.CollateralType _collateralType\n    ) external view virtual returns (uint256 totalSharesToLiquidate, uint256 keeperShares, uint256 lendersShares) {\n        (address silo, address shareToken, uint256 liquidationFee) = _resolveSplitData(_collateralType);\n\n        (totalSharesToLiquidate, keeperShares, lendersShares) = _getKeeperAndLenderSharesSplit({\n            _silo: silo,\n            _shareToken: shareToken,\n            _liquidationFee: liquidationFee,\n            _assetsToLiquidate: _assetsToLiquidate,\n            _collateralType: _collateralType\n        });\n    }\n\n    /// @inheritdoc IPartialLiquidationByDefaulting\n    function validateControllerForCollateral(address _silo)\n        public\n        view\n        virtual\n        returns (ISiloIncentivesController controllerCollateral)\n    {\n        (, address collateralShareToken,) = siloConfig.getShareTokens(_silo);\n        require(collateralShareToken != address(0), EmptyCollateralShareToken());\n\n        controllerCollateral = IGaugeHookReceiver(address(this)).configuredGauges(IShareToken(collateralShareToken));\n        require(address(controllerCollateral) != address(0), NoControllerForCollateral());\n    }\n\n    /// @inheritdoc IPartialLiquidationByDefaulting\n    function validateDefaultingCollateral() public view virtual {\n        (address silo0, address silo1) = siloConfig.getSilos();\n\n        ISiloConfig.ConfigData memory config0 = siloConfig.getConfig(silo0);\n        ISiloConfig.ConfigData memory config1 = siloConfig.getConfig(silo1);\n\n        require(config0.lt == 0 || config1.lt == 0, TwoWayMarketNotAllowed());\n\n        if (config0.lt == 0) require(config0.liquidationFee == 0, UnnecessaryLiquidationFee());\n        else require(config1.liquidationFee == 0, UnnecessaryLiquidationFee());\n\n        // to be consistent with validateSiloInitData, we using `<=` for lt check\n        require(\n            config0.lt + LT_MARGIN_FOR_DEFAULTING + config0.liquidationFee <= _DECIMALS_PRECISION, InvalidLTConfig0()\n        );\n        \n        require(\n            config1.lt + LT_MARGIN_FOR_DEFAULTING + config1.liquidationFee <= _DECIMALS_PRECISION, InvalidLTConfig1()\n        );\n    }\n\n    function _deductDefaultedDebtFromCollateral(address _silo, uint256 _assetsToRepay) internal virtual {\n        bytes memory input =\n            abi.encodeWithSelector(DefaultingSiloLogic.deductDefaultedDebtFromCollateral.selector, _assetsToRepay);\n\n        _callOnBehalfOfSilo({\n            _silo: ISilo(_silo),\n            _calldata: input,\n            _errorWhenRevert: DeductDefaultedDebtFromCollateralFailed.selector\n        });\n    }\n\n    function _repayDebtByDefaulting(address _silo, uint256 _assets, address _borrower) \n        internal \n        virtual \n        returns (uint256 shares, uint256 assets) \n    { \n        (bytes memory data) = _callOnBehalfOfSilo({\n            _silo: ISilo(_silo), \n            _calldata: abi.encodeWithSelector(\n                DefaultingSiloLogic.repayDebtByDefaulting.selector, _assets, _borrower\n            ), \n            _errorWhenRevert: RepayDebtByDefaultingFailed.selector\n        });\n\n        (shares, assets) = abi.decode(data, (uint256, uint256));\n    }\n\n    function _callOnBehalfOfSilo(ISilo _silo, bytes memory _calldata, bytes4 _errorWhenRevert) \n        internal\n        virtual\n        returns (bytes memory data) \n    {\n        bool success;\n\n        (success, data) = _silo.callOnBehalfOfSilo({\n            _target: LIQUIDATION_LOGIC,\n            _value: 0,\n            _callType: ISilo.CallType.Delegatecall,\n            _input: _calldata\n        });\n\n        if (!success) RevertLib.revertBytes(data, _errorWhenRevert);\n    }\n\n    function _liquidateByDistributingCollateral(\n        address _borrower,\n        address _debtSilo,\n        address _shareToken,\n        uint256 _withdrawSharesForLenders,\n        uint256 _withdrawSharesForKeeper\n    ) internal virtual {\n        ISiloIncentivesController controllerCollateral = validateControllerForCollateral(_debtSilo);\n\n        // distribute collateral shares to lenders\n        if (_withdrawSharesForLenders > 0) {\n            IShareToken(_shareToken).forwardTransferFromNoChecks(\n                _borrower, address(controllerCollateral), _withdrawSharesForLenders\n            );\n\n            controllerCollateral.immediateDistribution(_shareToken, _withdrawSharesForLenders);\n        }\n\n        // distribute collateral shares to keeper\n        if (_withdrawSharesForKeeper > 0) {\n            IShareToken(_shareToken).forwardTransferFromNoChecks(_borrower, msg.sender, _withdrawSharesForKeeper);\n        }\n    }\n\n    function _fetchConfigs(ISiloConfig _siloConfigCached, address _borrower)\n        internal\n        virtual\n        returns (ISiloConfig.ConfigData memory collateralConfig, ISiloConfig.ConfigData memory debtConfig)\n    {\n        (collateralConfig, debtConfig) = _siloConfigCached.getConfigsForSolvency(_borrower);\n\n        require(debtConfig.silo != address(0), UserIsSolvent());\n\n        ISilo(debtConfig.silo).accrueInterest();\n\n        if (collateralConfig.silo != debtConfig.silo) {\n            ISilo(collateralConfig.silo).accrueInterest();\n            collateralConfig.callSolvencyOracleBeforeQuote();\n            debtConfig.callSolvencyOracleBeforeQuote();\n        }\n    }\n\n    // solhint-disable function-max-lines\n    function _getKeeperAndLenderSharesSplit(\n        address _silo,\n        address _shareToken,\n        uint256 _liquidationFee,\n        uint256 _assetsToLiquidate,\n        ISilo.CollateralType _collateralType\n    ) internal view virtual returns (uint256 totalSharesToLiquidate, uint256 keeperShares, uint256 lendersShares) {\n        if (_assetsToLiquidate == 0) return (0, 0, 0);\n\n        uint256 totalAssets = ISilo(_silo).getTotalAssetsStorage(ISilo.AssetType(uint8(_collateralType)));\n        uint256 totalShares = IShareToken(_shareToken).totalSupply();\n\n        // assets were calculating with rounding down for withdraw,\n        // if we want to go back to shares, we can round up,\n        // however we choose to have exact results as we get via original liquidation, so we are using same direction\n        totalSharesToLiquidate = SiloMathLib.convertToShares({\n            _assets: _assetsToLiquidate,\n            _totalAssets: totalAssets,\n            _totalShares: totalShares,\n            _rounding: Rounding.LIQUIDATE_TO_SHARES,\n            _assetType: ISilo.AssetType(uint8(_collateralType))\n        });\n\n        // c - collateral that equals debt value\n        // f - liquidation fee\n        // CL - total collateral to liquidate\n        // kf - keeper fee\n        // kp - keeper part\n        // D - normalization divider\n\n        // c + c * f = CL\n        // c * (1 + f) = CL\n        // c = CL / (1 + f)\n\n        // kp = c * f * kf => f * kf * CL / (1 + f)\n\n        // final pseudo code is:\n\n        // kp = f * kf * CL / (1 + f)\n        // kp = muldiv(f * kf, CL, (1 + f), R)\n\n        // R - rounding, we want to round down for keeper\n        keeperShares = Math.mulDiv(\n            _liquidationFee * KEEPER_FEE,\n            totalSharesToLiquidate,\n            PartialLiquidationLib._PRECISION_DECIMALS,\n            Math.Rounding.Floor\n        ) / (PartialLiquidationLib._PRECISION_DECIMALS + _liquidationFee);\n\n        lendersShares = totalSharesToLiquidate - keeperShares;\n    }\n\n    function _resolveSplitData(ISilo.CollateralType _collateralType)\n        internal\n        view\n        virtual\n        returns (address silo, address shareToken, uint256 liquidationFee)\n    {\n        ISiloConfig configCached = siloConfig;\n        (address silo0, address silo1) = configCached.getSilos();\n        silo = silo0;\n        ISiloConfig.ConfigData memory collateralConfig = configCached.getConfig(silo0);\n\n        if (collateralConfig.lt == 0) {\n            // if LT is 0, then this can not be collateral, so we pull other config\n            collateralConfig = configCached.getConfig(silo1);\n            silo = silo1;\n        }\n\n        shareToken = _collateralType == ISilo.CollateralType.Collateral\n            ? collateralConfig.collateralShareToken\n            : collateralConfig.protectedShareToken;\n\n        liquidationFee = collateralConfig.liquidationFee;\n    }\n}\n"
    },
    "silo-core/contracts/hooks/_common/BaseHookReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {Initializable} from \"openzeppelin5/proxy/utils/Initializable.sol\";\n\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\nimport {IHookReceiver} from \"silo-core/contracts/interfaces/IHookReceiver.sol\";\nimport {ISiloConfig} from \"silo-core/contracts/interfaces/ISiloConfig.sol\";\n\nabstract contract BaseHookReceiver is IHookReceiver, Initializable {\n    ISiloConfig public siloConfig;\n\n    mapping(address silo => HookConfig) private _hookConfig;\n\n    modifier onlySilo() {\n        require(_isSilo(msg.sender), OnlySilo());\n        _;\n    }\n\n    modifier onlySiloOrShareToken() {\n        require(_isSiloOrShareToken(msg.sender), OnlySiloOrShareToken());\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @inheritdoc IHookReceiver\n    function hookReceiverConfig(address _silo)\n        external\n        view\n        virtual\n        returns (uint24 hooksBefore, uint24 hooksAfter)\n    {\n        (hooksBefore, hooksAfter) = _hookReceiverConfig(_silo);\n    }\n\n    /// @notice Set the silo config\n    /// @param _config Silo config\n    function __BaseHookReceiver_init(ISiloConfig _config) // solhint-disable-line func-name-mixedcase\n        internal\n        onlyInitializing\n        virtual\n    {\n        require(address(_config) != address(0), EmptySiloConfig());\n        require(address(siloConfig) == address(0), AlreadyConfigured());\n\n        siloConfig = _config;\n    }\n\n    /// @notice Set the hook config\n    /// @param _silo Silo address\n    /// @param _hooksBefore Hooks before\n    /// @param _hooksAfter Hooks after\n    function _setHookConfig(address _silo, uint24 _hooksBefore, uint24 _hooksAfter) internal virtual {\n        _hookConfig[_silo] = HookConfig(_hooksBefore, _hooksAfter);\n        emit HookConfigured(_silo, _hooksBefore, _hooksAfter);\n\n        ISilo(_silo).updateHooks();\n    }\n\n    /// @notice Get the hook config\n    /// @param _silo Silo address\n    /// @return hooksBefore Hooks before\n    /// @return hooksAfter Hooks after\n    function _hookReceiverConfig(address _silo) internal view virtual returns (uint24 hooksBefore, uint24 hooksAfter) {\n        HookConfig memory hookConfig = _hookConfig[_silo];\n\n        hooksBefore = hookConfig.hooksBefore;\n        hooksAfter = hookConfig.hooksAfter;\n    }\n\n    /// @notice Get the hooks before\n    /// @param _silo Silo address\n    /// @return hooksBefore Hooks before\n    function _getHooksBefore(address _silo) internal view virtual returns (uint256 hooksBefore) {\n        hooksBefore = _hookConfig[_silo].hooksBefore;\n    }\n\n    /// @notice Get the hooks after\n    /// @param _silo Silo address\n    /// @return hooksAfter Hooks after\n    function _getHooksAfter(address _silo) internal view virtual returns (uint256 hooksAfter) {\n        hooksAfter = _hookConfig[_silo].hooksAfter;\n    }\n\n    /// @notice Check if the address is a Silo\n    /// @param _addr Address to check\n    /// @return result True if the address is a Silo, false otherwise\n    function _isSilo(address _addr) internal view virtual returns (bool result) {\n        (address silo0, address silo1) = siloConfig.getSilos();\n        result = _addr == silo0 || _addr == silo1;\n    }\n\n    /// @notice Check if the address is a Silo or a share token\n    /// @param _addr Address to check\n    /// @return result True if the address is a Silo or a share token, false otherwise\n    function _isSiloOrShareToken(address _addr) internal view virtual returns (bool result) {\n        (address silo0, address silo1) = siloConfig.getSilos();\n\n        if (_addr == silo0 || _addr == silo1) return true;\n\n        address protectedCollateralShareToken;\n        address debtShareToken;\n\n        (protectedCollateralShareToken,, debtShareToken) = siloConfig.getShareTokens(silo0);\n        if (_addr == protectedCollateralShareToken || _addr == debtShareToken) return true;\n\n        (protectedCollateralShareToken,, debtShareToken) = siloConfig.getShareTokens(silo1);\n        if (_addr == protectedCollateralShareToken || _addr == debtShareToken) return true;\n\n        return false;\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/ICrossReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ICrossReentrancyGuard {\n    error CrossReentrantCall();\n    error CrossReentrancyNotActive();\n\n    /// @notice only silo method for cross Silo reentrancy\n    function turnOnReentrancyProtection() external;\n\n    /// @notice only silo method for cross Silo reentrancy\n    function turnOffReentrancyProtection() external;\n\n    /// @notice view method for checking cross Silo reentrancy flag\n    /// @return entered true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n    /// `nonReentrant` function in the call stack.\n    function reentrancyGuardEntered() external view returns (bool entered);\n}"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC-4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "silo-core/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC3156FlashBorrower} from \"./IERC3156FlashBorrower.sol\";\n\n/// @notice https://eips.ethereum.org/EIPS/eip-3156\ninterface IERC3156FlashLender {\n    /// @notice Protected deposits are not available for a flash loan.\n    /// During the execution of the flashloan, Silo methods are not taking into consideration the fact,\n    /// that some (or all) tokens were transferred as flashloan, therefore some methods can return invalid state\n    /// eg. maxWithdraw can return amount that are not available to withdraw during flashlon.\n    /// @dev Initiate a flash loan.\n    /// @param _receiver The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(IERC3156FlashBorrower _receiver, address _token, uint256 _amount, bytes calldata _data)\n        external\n        returns (bool);\n\n    /// @dev The amount of currency available to be lent.\n    /// @param _token The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address _token) external view returns (uint256);\n\n    /// @dev The fee to be charged for a given loan.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address _token, uint256 _amount) external view returns (uint256);\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC721} from \"openzeppelin5/interfaces/IERC721.sol\";\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\n\ninterface ISiloFactory is IERC721 {\n    struct Range {\n        uint128 min;\n        uint128 max;\n    }\n\n    /// @notice Emitted on the creation of a Silo.\n    /// @param implementation Address of the Silo implementation.\n    /// @param token0 Address of the first Silo token.\n    /// @param token1 Address of the second Silo token.\n    /// @param silo0 Address of the first Silo.\n    /// @param silo1 Address of the second Silo.\n    /// @param siloConfig Address of the SiloConfig.\n    event NewSilo(\n        address indexed implementation,\n        address indexed token0,\n        address indexed token1,\n        address silo0,\n        address silo1,\n        address siloConfig\n    );\n\n    /// @notice Emitted on the creation of a Silo, note that collateral share token == silo\n    event NewSiloShareTokens(\n        address indexed protectedShareToken, \n        address indexed collateralShareToken,\n        address indexed debtShareToken\n    );\n\n    event NewSiloHook(address indexed silo, address indexed hook);\n\n    event BaseURI(string newBaseURI);\n\n    /// @notice Emitted on the update of DAO fee.\n    /// @param minDaoFee Value of the new minimal DAO fee.\n    /// @param maxDaoFee Value of the new maximal DAO fee.\n    event DaoFeeChanged(uint128 minDaoFee, uint128 maxDaoFee);\n\n    /// @notice Emitted on the update of max deployer fee.\n    /// @param maxDeployerFee Value of the new max deployer fee.\n    event MaxDeployerFeeChanged(uint256 maxDeployerFee);\n\n    /// @notice Emitted on the update of max flashloan fee.\n    /// @param maxFlashloanFee Value of the new max flashloan fee.\n    event MaxFlashloanFeeChanged(uint256 maxFlashloanFee);\n\n    /// @notice Emitted on the update of max liquidation fee.\n    /// @param maxLiquidationFee Value of the new max liquidation fee.\n    event MaxLiquidationFeeChanged(uint256 maxLiquidationFee);\n\n    /// @notice Emitted on the change of DAO fee receiver.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChanged(address daoFeeReceiver);\n\n    /// @notice Emitted on the change of DAO fee receiver for particular silo\n    /// @param silo Address for which new DAO fee receiver is set.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChangedForSilo(address silo, address daoFeeReceiver);\n\n    /// @notice Emitted on the change of DAO fee receiver for particular asset\n    /// @param asset Address for which new DAO fee receiver is set.\n    /// @param daoFeeReceiver Address of the new DAO fee receiver.\n    event DaoFeeReceiverChangedForAsset(address asset, address daoFeeReceiver);\n\n    error MissingHookReceiver();\n    error ZeroAddress();\n    error DaoFeeReceiverZeroAddress();\n    error SameDaoFeeReceiver();\n    error EmptyToken0();\n    error EmptyToken1();\n    error MaxFeeExceeded();\n    error InvalidFeeRange();\n    error SameAsset();\n    error SameRange();\n    error InvalidIrm();\n    error InvalidMaxLtv();\n    error InvalidLt();\n    error InvalidDeployer();\n    error DaoMinRangeExceeded();\n    error DaoMaxRangeExceeded();\n    error MaxDeployerFeeExceeded();\n    error MaxFlashloanFeeExceeded();\n    error MaxLiquidationFeeExceeded();\n    error InvalidCallBeforeQuote();\n    error OracleMisconfiguration();\n    error InvalidQuoteToken();\n    error HookIsZeroAddress();\n    error LiquidationTargetLtvTooHigh();\n    error NotYourSilo();\n    error ConfigMismatchSilo();\n    error ConfigMismatchShareProtectedToken();\n    error ConfigMismatchShareDebtToken();\n    error ConfigMismatchShareCollateralToken();\n\n    /// @notice Create a new Silo.\n    /// @param _siloConfig Silo configuration.\n    /// @param _siloImpl Address of the `Silo` implementation.\n    /// @param _shareProtectedCollateralTokenImpl Address of the `ShareProtectedCollateralToken` implementation.\n    /// @param _shareDebtTokenImpl Address of the `ShareDebtToken` implementation.\n    /// @param _deployer Address of the deployer.\n    /// @param _creator Address of the creator.\n    function createSilo(\n        ISiloConfig _siloConfig,\n        address _siloImpl,\n        address _shareProtectedCollateralTokenImpl,\n        address _shareDebtTokenImpl,\n        address _deployer,\n        address _creator\n    )\n        external;\n\n    /// @notice NFT ownership represents the deployer fee receiver for the each Silo ID.  After burning, \n    /// the deployer fee is sent to the DAO. Burning doesn't affect Silo's behavior. It is only about fee distribution.\n    /// @param _siloIdToBurn silo ID to burn.\n    function burn(uint256 _siloIdToBurn) external;\n\n    /// @notice Update the value of DAO fee. Updated value will be used only for a new Silos.\n    /// Previously deployed SiloConfigs are immutable.\n    /// @param _minFee Value of the new DAO minimal fee.\n    /// @param _maxFee Value of the new DAO maximal fee.\n    function setDaoFee(uint128 _minFee, uint128 _maxFee) external;\n\n    /// @notice Set the default DAO fee receiver.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiver(address _newDaoFeeReceiver) external;\n\n    /// @notice Set the new DAO fee receiver for asset, this setup will be used when fee receiver for silo is empty.\n    /// @param _asset Address for which new DAO fee receiver is set.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiverForAsset(address _asset, address _newDaoFeeReceiver) external;\n\n    /// @notice Set the new DAO fee receiver for silo. This setup has highest priority.\n    /// @param _silo Address for which new DAO fee receiver is set.\n    /// @param _newDaoFeeReceiver Address of the new DAO fee receiver.\n    function setDaoFeeReceiverForSilo(address _silo, address _newDaoFeeReceiver) external;\n\n    /// @notice Update the value of max deployer fee. Updated value will be used only for a new Silos max deployer\n    /// fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxDeployerFee Value of the new max deployer fee.\n    function setMaxDeployerFee(uint256 _newMaxDeployerFee) external;\n\n    /// @notice Update the value of max flashloan fee. Updated value will be used only for a new Silos max flashloan\n    /// fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxFlashloanFee Value of the new max flashloan fee.\n    function setMaxFlashloanFee(uint256 _newMaxFlashloanFee) external;\n\n    /// @notice Update the value of max liquidation fee. Updated value will be used only for a new Silos max\n    /// liquidation fee validation. Previously deployed SiloConfigs are immutable.\n    /// @param _newMaxLiquidationFee Value of the new max liquidation fee.\n    function setMaxLiquidationFee(uint256 _newMaxLiquidationFee) external;\n   \n    /// @notice Update the base URI.\n    /// @param _newBaseURI Value of the new base URI.\n    function setBaseURI(string calldata _newBaseURI) external;\n\n    /// @notice Acceptable DAO fee range for new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function daoFeeRange() external view returns (Range memory);\n\n    /// @notice Max deployer fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxDeployerFee() external view returns (uint256);\n\n    /// @notice Max flashloan fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxFlashloanFee() external view returns (uint256);\n\n    /// @notice Max liquidation fee for a new Silos. Denominated in 18 decimals points. 1e18 == 100%.\n    function maxLiquidationFee() external view returns (uint256);\n\n    /// @notice The recipient of DAO fees.\n    function daoFeeReceiver() external view returns (address);\n\n    /// @notice Get SiloConfig address by Silo id.\n    function idToSiloConfig(uint256 _id) external view returns (address);\n\n    /// @notice Get the counter of silos created by the wallet.\n    function creatorSiloCounter(address _creator) external view returns (uint256);\n\n    /// @notice Do not use this method to check if silo is secure. Anyone can deploy silo with any configuration\n    /// and implementation. Most critical part of verification would be to check who deployed it.\n    /// @dev True if the address was deployed using SiloFactory.\n    function isSilo(address _silo) external view returns (bool);\n\n    /// @notice Id of a next Silo to be deployed. This is an ID of non-existing Silo outside of createSilo\n    /// function call. ID of a first Silo is 1.\n    function getNextSiloId() external view returns (uint256);\n\n    /// @notice Get the DAO and deployer fee receivers for a particular Silo address.\n    /// @param _silo Silo address.\n    /// @return dao DAO fee receiver.\n    /// @return deployer Deployer fee receiver.\n    function getFeeReceivers(address _silo) external view returns (address dao, address deployer);\n\n    /// @notice Validate InitData for a new Silo. Config will be checked for the fee limits, missing parameters.\n    /// @param _initData Silo init data.\n    function validateSiloInitData(ISiloConfig.InitData memory _initData) external view returns (bool);\n}\n"
    },
    "common/access/Ownable1and2Steps.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {Ownable2Step, Ownable} from \"openzeppelin5/access/Ownable2Step.sol\";\n\n/// @dev This contract is a wrapper around Ownable2Step that allows for 1-step ownership transfer\nabstract contract Ownable1and2Steps is Ownable2Step {\n    constructor(address _initialOwner) Ownable(_initialOwner) {}\n\n    /// @notice Transfer ownership to a new address. Pending ownership transfer will be canceled.\n    /// @param newOwner The new owner of the contract\n    function transferOwnership1Step(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n\n        Ownable2Step._transferOwnership(newOwner);\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/IShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {ISiloConfig} from \"./ISiloConfig.sol\";\nimport {ISilo} from \"./ISilo.sol\";\n\ninterface IShareToken is IERC20Metadata {\n    struct HookSetup {\n        /// @param this is the same as in siloConfig\n        address hookReceiver;\n        /// @param hooks bitmap\n        uint24 hooksBefore;\n        /// @param hooks bitmap\n        uint24 hooksAfter;\n        /// @param tokenType must be one of this hooks values: COLLATERAL_TOKEN, PROTECTED_TOKEN, DEBT_TOKEN\n        uint24 tokenType;\n    }\n\n    struct ShareTokenStorage {\n        /// @notice Silo address for which tokens was deployed\n        ISilo silo;\n\n        /// @dev cached silo config address\n        ISiloConfig siloConfig;\n\n        /// @notice Copy of hooks setup from SiloConfig for optimisation purposes\n        HookSetup hookSetup;\n\n        bool transferWithChecks;\n    }\n\n    /// @notice Emitted every time receiver is notified about token transfer\n    /// @param notificationReceiver receiver address\n    /// @param success false if TX reverted on `notificationReceiver` side, otherwise true\n    event NotificationSent(address indexed notificationReceiver, bool success);\n\n    error OnlySilo();\n    error OnlySiloConfig();\n    error OwnerIsZero();\n    error RecipientIsZero();\n    error AmountExceedsAllowance();\n    error RecipientNotSolventAfterTransfer();\n    error SenderNotSolventAfterTransfer();\n    error ZeroTransfer();\n\n    /// @notice method for SiloConfig to synchronize hooks\n    /// @param _hooksBefore hooks bitmap to trigger hooks BEFORE action\n    /// @param _hooksAfter hooks bitmap to trigger hooks AFTER action\n    function synchronizeHooks(uint24 _hooksBefore, uint24 _hooksAfter) external;\n\n    /// @notice Mint method for Silo to create debt\n    /// @param _owner wallet for which to mint token\n    /// @param _spender wallet that asks for mint\n    /// @param _amount amount of token to be minted\n    function mint(address _owner, address _spender, uint256 _amount) external;\n\n    /// @notice Burn method for Silo to close debt\n    /// @param _owner wallet for which to burn token\n    /// @param _spender wallet that asks for burn\n    /// @param _amount amount of token to be burned\n    function burn(address _owner, address _spender, uint256 _amount) external;\n\n    /// @notice TransferFrom method for liquidation\n    /// @param _from wallet from which we transferring tokens\n    /// @param _to wallet that will get tokens\n    /// @param _amount amount of token to transfer\n    function forwardTransferFromNoChecks(address _from, address _to, uint256 _amount) external;\n\n    /// @dev Returns the amount of tokens owned by `account`.\n    /// @param _account address for which to return data\n    /// @return balance of the _account\n    /// @return totalSupply total supply of the token\n    function balanceOfAndTotalSupply(address _account) external view returns (uint256 balance, uint256 totalSupply);\n\n    /// @notice Returns silo address for which token was deployed\n    /// @return silo address\n    function silo() external view returns (ISilo silo);\n\n    function siloConfig() external view returns (ISiloConfig silo);\n\n    /// @notice Returns hook setup\n    function hookSetup() external view returns (HookSetup memory);\n\n    /// @notice Returns hook receiver address\n    function hookReceiver() external view returns (address);\n\n    /// @dev offset value uses by vaults to calculate the conversion rate between assets and shares\n    /// it determines how many shares are minted for 1 asset eg. with offset 3, 1 asset = 1000 shares\n    /// notice, that 1:1000 ratio can change for collateral shares when shares value changes eg due to interest accrual.\n    /// see openzeppelin contract: contracts/token/ERC20/extensions/ERC4626.sol for more details about offset\n    /// @notice this method is available since Silo Core v4.0.0\n    function decimalsOffset() external view returns (uint256);\n}\n"
    },
    "silo-core/contracts/interfaces/IPartialLiquidation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IPartialLiquidation {\n    struct HookSetup {\n        /// @param this is the same as in siloConfig\n        address hookReceiver;\n        /// @param hooks bitmap\n        uint24 hooksBefore;\n        /// @param hooks bitmap\n        uint24 hooksAfter;\n    }\n\n    /// @dev Emitted when a borrower is liquidated.\n    /// @param liquidator The address of the liquidator\n    /// @param silo The address of the silo on which position was liquidated\n    /// @param borrower The address of the borrower\n    /// @param repayDebtAssets Repay amount\n    /// @param withdrawCollateral Total (collateral + protected) withdraw amount, in case `receiveSToken` is TRUE\n    /// then this is estimated withdraw, and representation of this amount in sToken was transferred\n    /// @param receiveSToken True if the liquidators wants to receive the collateral sTokens, `false` if he wants\n    /// to receive the underlying collateral asset directly. This flag is ignored in case when it's not possible \n    /// to convert shares to assets, eg 999 shares => 0 assets, in that case liquidator will receive this dust shares \n    /// directly, shares that can be withdawable as assets will be transferred to liquidator as usual.\n    event LiquidationCall(\n        address indexed liquidator,\n        address indexed silo,\n        address indexed borrower,\n        uint256 repayDebtAssets,\n        uint256 withdrawCollateral,\n        bool receiveSToken\n    );\n\n    error UnexpectedCollateralToken();\n    error UnexpectedDebtToken();\n    error NoDebtToCover();\n    error FullLiquidationRequired();\n    error UserIsSolvent();\n    error UnknownRatio();\n    error NoRepayAssets();\n    error NoCollateralToLiquidate();\n\n    /// @notice Function to liquidate insolvent position\n    /// - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n    ///   an equivalent amount in `collateralAsset` plus a liquidation fee to cover market risk\n    /// @dev this method reverts when:\n    /// - `_maxDebtToCover` is zero\n    /// - `_collateralAsset` is not `_user` collateral token (note, that user can have both tokens in Silo, but only one\n    ///   is for backing debt\n    /// - `_debtAsset` is not a token that `_user` borrow\n    /// - `_user` is solvent and there is no debt to cover\n    /// - `_maxDebtToCover` is set to cover only part of the debt but full liquidation is required\n    /// - when not enough liquidity to transfer from `_user` collateral to liquidator\n    ///   (use `_receiveSToken == true` in that case)\n    /// @param _collateralAsset The address of the underlying asset used as collateral, to receive as result\n    /// @param _debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n    /// @param _user The address of the borrower getting liquidated\n    /// @param _maxDebtToCover The maximum debt amount of borrowed `asset` the liquidator wants to cover,\n    /// in case this amount is too big, it will be reduced to maximum allowed liquidation amount\n    /// @param _receiveSToken True if the liquidators wants to receive the collateral sTokens, `false` if he wants\n    /// to receive the underlying collateral asset directly. \n    /// `_receiveSToken` is ignored in case when it's not possible to convert shares to assets, \n    /// eg 999 shares => 0 assets.\n    /// @return withdrawCollateral collateral that was send to `msg.sender`, in case of `_receiveSToken` is TRUE,\n    /// `withdrawCollateral` will be estimated, on redeem one can expect this value to be rounded down\n    /// @return repayDebtAssets actual debt value that was repaid by `msg.sender`\n    function liquidationCall(\n        address _collateralAsset,\n        address _debtAsset,\n        address _user,\n        uint256 _maxDebtToCover,\n        bool _receiveSToken\n    )\n        external\n        returns (uint256 withdrawCollateral, uint256 repayDebtAssets);\n\n    /// @dev debt is keep growing over time, so when dApp use this view to calculate max, tx should never revert\n    /// because actual max can be only higher\n    /// @return collateralToLiquidate underestimated amount of collateral liquidator will get\n    /// @return debtToRepay debt amount needed to be repay to get `collateralToLiquidate`\n    /// @return sTokenRequired TRUE, when liquidation with underlying asset is not possible because of not enough\n    /// liquidity\n    function maxLiquidation(address _borrower)\n        external\n        view\n        returns (uint256 collateralToLiquidate, uint256 debtToRepay, bool sTokenRequired);\n}\n"
    },
    "silo-core/contracts/lib/Hook.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.28;\n\nimport {ISilo} from \"../interfaces/ISilo.sol\";\n\n// solhint-disable private-vars-leading-underscore\nlibrary Hook {\n    /// @notice The data structure for the deposit hook\n    /// @param assets The amount of assets deposited\n    /// @param shares The amount of shares deposited\n    /// @param receiver The receiver of the deposit\n    struct BeforeDepositInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n    }\n\n    /// @notice The data structure for the deposit hook\n    /// @param assets The amount of assets deposited\n    /// @param shares The amount of shares deposited\n    /// @param receiver The receiver of the deposit\n    /// @param receivedAssets The exact amount of assets being deposited\n    /// @param mintedShares The exact amount of shares being minted\n    struct AfterDepositInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        uint256 receivedAssets;\n        uint256 mintedShares;\n    }\n\n    /// @notice The data structure for the withdraw hook\n    /// @param assets The amount of assets withdrawn\n    /// @param shares The amount of shares withdrawn\n    /// @param receiver The receiver of the withdrawal\n    /// @param owner The owner of the shares\n    /// @param spender The spender of the shares\n    struct BeforeWithdrawInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n    }\n\n    /// @notice The data structure for the withdraw hook\n    /// @param assets The amount of assets withdrawn\n    /// @param shares The amount of shares withdrawn\n    /// @param receiver The receiver of the withdrawal\n    /// @param owner The owner of the shares\n    /// @param spender The spender of the shares\n    /// @param withdrawnAssets The exact amount of assets being withdrawn\n    /// @param withdrawnShares The exact amount of shares being withdrawn\n    struct AfterWithdrawInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        uint256 withdrawnAssets;\n        uint256 withdrawnShares;\n    }\n\n    /// @notice The data structure for the share token transfer hook\n    /// @param sender The sender of the transfer (address(0) on mint)\n    /// @param recipient The recipient of the transfer (address(0) on burn)\n    /// @param amount The amount of tokens transferred/minted/burned\n    /// @param senderBalance The balance of the sender after the transfer (empty on mint)\n    /// @param recipientBalance The balance of the recipient after the transfer (empty on burn)\n    /// @param totalSupply The total supply of the share token\n    struct AfterTokenTransfer {\n        address sender;\n        address recipient;\n        uint256 amount;\n        uint256 senderBalance;\n        uint256 recipientBalance;\n        uint256 totalSupply;\n    }\n\n    /// @notice The data structure for the before borrow hook\n    /// @param assets The amount of assets to borrow\n    /// @param shares The amount of shares to borrow\n    /// @param receiver The receiver of the borrow\n    /// @param borrower The borrower of the assets\n    /// @param _spender Address which initiates the borrowing action on behalf of the borrower\n    struct BeforeBorrowInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n    }\n\n    /// @notice The data structure for the after borrow hook\n    /// @param assets The amount of assets borrowed\n    /// @param shares The amount of shares borrowed\n    /// @param receiver The receiver of the borrow\n    /// @param borrower The borrower of the assets\n    /// @param spender Address which initiates the borrowing action on behalf of the borrower\n    /// @param borrowedAssets The exact amount of assets being borrowed\n    /// @param borrowedShares The exact amount of shares being borrowed\n    struct AfterBorrowInput {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        uint256 borrowedAssets;\n        uint256 borrowedShares;\n    }\n\n    /// @notice The data structure for the before repay hook\n    /// @param assets The amount of assets to repay\n    /// @param shares The amount of shares to repay\n    /// @param borrower The borrower of the assets\n    /// @param repayer The repayer of the assets\n    struct BeforeRepayInput {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n    }\n\n    /// @notice The data structure for the after repay hook\n    /// @param assets The amount of assets to repay\n    /// @param shares The amount of shares to repay\n    /// @param borrower The borrower of the assets\n    /// @param repayer The repayer of the assets\n    /// @param repaidAssets The exact amount of assets being repaid\n    /// @param repaidShares The exact amount of shares being repaid\n    struct AfterRepayInput {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n        uint256 repaidAssets;\n        uint256 repaidShares;\n    }\n\n    /// @notice The data structure for the before flash loan hook\n    /// @param receiver The flash loan receiver\n    /// @param token The flash loan token\n    /// @param amount Requested amount of tokens\n    struct BeforeFlashLoanInput {\n        address receiver;\n        address token;\n        uint256 amount;\n    }\n\n    /// @notice The data structure for the after flash loan hook\n    /// @param receiver The flash loan receiver\n    /// @param token The flash loan token\n    /// @param amount Received amount of tokens\n    /// @param fee The flash loan fee\n    struct AfterFlashLoanInput {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint256 fee;\n    }\n\n    /// @notice The data structure for the before transition collateral hook\n    /// @param shares The amount of shares to transition\n    struct BeforeTransitionCollateralInput {\n        uint256 shares;\n        address owner;\n    }\n\n    /// @notice The data structure for the after transition collateral hook\n    /// @param shares The amount of shares to transition\n    struct AfterTransitionCollateralInput {\n        uint256 shares;\n        address owner;\n        uint256 assets;\n    }\n\n    /// @notice The data structure for the switch collateral hook\n    /// @param user The user switching collateral\n    struct SwitchCollateralInput {\n        address user;\n    }\n\n    /// @notice Supported hooks\n    /// @dev The hooks are stored as a bitmap and can be combined with bitwise OR\n    uint256 internal constant NONE = 0;\n    uint256 internal constant DEPOSIT = 2 ** 1;\n    uint256 internal constant BORROW = 2 ** 2;\n    uint256 internal constant BORROW_SAME_ASSET = 2 ** 3; // deprecated\n    uint256 internal constant REPAY = 2 ** 4;\n    uint256 internal constant WITHDRAW = 2 ** 5;\n    uint256 internal constant FLASH_LOAN = 2 ** 6;\n    uint256 internal constant TRANSITION_COLLATERAL = 2 ** 7;\n    uint256 internal constant SWITCH_COLLATERAL = 2 ** 8; // deprecated\n    uint256 internal constant SHARE_TOKEN_TRANSFER = 2 ** 10;\n    uint256 internal constant COLLATERAL_TOKEN = 2 ** 11;\n    uint256 internal constant PROTECTED_TOKEN = 2 ** 12;\n    uint256 internal constant DEBT_TOKEN = 2 ** 13;\n\n    // note: currently we can support hook value up to 2 ** 23,\n    // because for optimisation purposes, we storing hooks as uint24\n\n    // For decoding packed data\n    uint256 private constant PACKED_ADDRESS_LENGTH = 20;\n    uint256 private constant PACKED_FULL_LENGTH = 32;\n    uint256 private constant PACKED_ENUM_LENGTH = 1;\n    uint256 private constant PACKED_BOOL_LENGTH = 1;\n\n    error FailedToParseBoolean();\n    error InvalidTokenType();\n\n    /// @notice Checks if the action has a specific hook\n    /// @param _action The action\n    /// @param _expectedHook The expected hook\n    /// @dev The function returns true if the action has the expected hook.\n    /// As hooks actions can be combined with bitwise OR, the following examples are valid:\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, WITHDRAW) == true`\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, COLLATERAL_TOKEN) == true`\n    /// `matchAction(WITHDRAW | COLLATERAL_TOKEN, WITHDRAW | COLLATERAL_TOKEN) == true`\n    function matchAction(uint256 _action, uint256 _expectedHook) internal pure returns (bool) {\n        return (_action & _expectedHook) == _expectedHook;\n    }\n\n    /// @notice Adds a hook to an action\n    /// @param _action The action\n    /// @param _newAction The new hook to be added\n    function addAction(uint256 _action, uint256 _newAction) internal pure returns (uint256) {\n        return _action | _newAction;\n    }\n\n    /// @dev please be careful with removing actions, because other hooks might using them\n    /// eg when you have `_action = COLLATERAL_TOKEN | PROTECTED_TOKEN | SHARE_TOKEN_TRANSFER`\n    /// and you want to remove action on protected token transfer by doing\n    /// `remove(_action, PROTECTED_TOKEN | SHARE_TOKEN_TRANSFER)`, the result will be `_action=COLLATERAL_TOKEN`\n    /// and it will not trigger collateral token transfer. In this example you should do:\n    /// `remove(_action, PROTECTED_TOKEN)`\n    function removeAction(uint256 _action, uint256 _actionToRemove) internal pure returns (uint256) {\n        return _action & (~_actionToRemove);\n    }\n\n    /// @notice Returns the action for depositing a specific collateral type\n    /// @param _type The collateral type\n    function depositAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return DEPOSIT | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the action for withdrawing a specific collateral type\n    /// @param _type The collateral type\n    function withdrawAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return WITHDRAW | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the action for collateral transition\n    /// @param _type The collateral type\n    function transitionCollateralAction(ISilo.CollateralType _type) internal pure returns (uint256) {\n        return TRANSITION_COLLATERAL | (_type == ISilo.CollateralType.Collateral ? COLLATERAL_TOKEN : PROTECTED_TOKEN);\n    }\n\n    /// @notice Returns the share token transfer action\n    /// @param _tokenType The token type (COLLATERAL_TOKEN || PROTECTED_TOKEN || DEBT_TOKEN)\n    function shareTokenTransfer(uint256 _tokenType) internal pure returns (uint256) {\n        require(\n            _tokenType == COLLATERAL_TOKEN || _tokenType == PROTECTED_TOKEN || _tokenType == DEBT_TOKEN,\n            InvalidTokenType()\n        );\n\n        return SHARE_TOKEN_TRANSFER | _tokenType;\n    }\n\n    /// @dev Decodes packed data from the share token after the transfer hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterTokenTransferDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterTokenTransfer memory input)\n    {\n        address sender;\n        address recipient;\n        uint256 amount;\n        uint256 senderBalance;\n        uint256 recipientBalance;\n        uint256 totalSupply;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            sender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            recipient := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            senderBalance := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            recipientBalance := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            totalSupply := mload(add(packed, pointer))\n        }\n\n        input = AfterTokenTransfer(sender, recipient, amount, senderBalance, recipientBalance, totalSupply);\n    }\n\n    /// @dev Decodes packed data from the deposit hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeDepositDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeDepositInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n        }\n\n        input = BeforeDepositInput(assets, shares, receiver);\n    }\n\n    /// @dev Decodes packed data from the deposit hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterDepositDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterDepositInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        uint256 receivedAssets;\n        uint256 mintedShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            receivedAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            mintedShares := mload(add(packed, pointer))\n        }\n\n        input = AfterDepositInput(assets, shares, receiver, receivedAssets, mintedShares);\n    }\n\n    /// @dev Decodes packed data from the withdraw hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeWithdrawDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeWithdrawInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n        }\n\n        input = BeforeWithdrawInput(assets, shares, receiver, owner, spender);\n    }\n\n    /// @dev Decodes packed data from the withdraw hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterWithdrawDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterWithdrawInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address owner;\n        address spender;\n        uint256 withdrawnAssets;\n        uint256 withdrawnShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            withdrawnAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            withdrawnShares := mload(add(packed, pointer))\n        }\n\n        input = AfterWithdrawInput(assets, shares, receiver, owner, spender, withdrawnAssets, withdrawnShares);\n    }\n\n    /// @dev Decodes packed data from the before borrow hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeBorrowDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeBorrowInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n        }\n\n        input = BeforeBorrowInput(assets, shares, receiver, borrower, spender);\n    }\n\n    /// @dev Decodes packed data from the after borrow hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterBorrowDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterBorrowInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address receiver;\n        address borrower;\n        address spender;\n        uint256 borrowedAssets;\n        uint256 borrowedShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            spender := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            borrowedAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            borrowedShares := mload(add(packed, pointer))\n        }\n\n        input = AfterBorrowInput(assets, shares, receiver, borrower, spender, borrowedAssets, borrowedShares);\n    }\n\n    /// @dev Decodes packed data from the before repay hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeRepayDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeRepayInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            repayer := mload(add(packed, pointer))\n        }\n\n        input = BeforeRepayInput(assets, shares, borrower, repayer);\n    }\n\n    /// @dev Decodes packed data from the after repay hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterRepayDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterRepayInput memory input)\n    {\n        uint256 assets;\n        uint256 shares;\n        address borrower;\n        address repayer;\n        uint256 repaidAssets;\n        uint256 repaidShares;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            assets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            borrower := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            repayer := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            repaidAssets := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            repaidShares := mload(add(packed, pointer))\n        }\n\n        input = AfterRepayInput(assets, shares, borrower, repayer, repaidAssets, repaidShares);\n    }\n\n    /// @dev Decodes packed data from the before flash loan hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeFlashLoanDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeFlashLoanInput memory input)\n    {\n        address receiver;\n        address token;\n        uint256 amount;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            token := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n        }\n\n        input = BeforeFlashLoanInput(receiver, token, amount);\n    }\n\n    /// @dev Decodes packed data from the before flash loan hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterFlashLoanDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterFlashLoanInput memory input)\n    {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint256 fee;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            receiver := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            token := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            amount := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            fee := mload(add(packed, pointer))\n        }\n\n        input = AfterFlashLoanInput(receiver, token, amount, fee);\n    }\n\n    /// @dev Decodes packed data from the transition collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function beforeTransitionCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (BeforeTransitionCollateralInput memory input)\n    {\n        uint256 shares;\n        address owner;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n        }\n\n        input = BeforeTransitionCollateralInput(shares, owner);\n    }\n\n    /// @dev Decodes packed data from the transition collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function afterTransitionCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (AfterTransitionCollateralInput memory input)\n    {\n        uint256 shares;\n        address owner;\n        uint256 assets;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_FULL_LENGTH\n            shares := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_ADDRESS_LENGTH)\n            owner := mload(add(packed, pointer))\n            pointer := add(pointer, PACKED_FULL_LENGTH)\n            assets := mload(add(packed, pointer))\n        }\n\n        input = AfterTransitionCollateralInput(shares, owner, assets);\n    }\n\n    /// @dev Decodes packed data from the switch collateral hook\n    /// @param packed The packed data (via abi.encodePacked)\n    /// @return input decoded\n    function switchCollateralDecode(bytes memory packed)\n        internal\n        pure\n        returns (SwitchCollateralInput memory input)\n    {\n        address user;\n\n        assembly { // solhint-disable-line no-inline-assembly\n            let pointer := PACKED_ADDRESS_LENGTH\n            user := mload(add(packed, pointer))\n        }\n\n        input = SwitchCollateralInput(user);\n    }\n\n    /// @dev Converts a uint8 to a boolean\n    function _toBoolean(uint8 _value) internal pure returns (bool result) {\n        if (_value == 0) {\n            result = false;\n        } else if (_value == 1) {\n            result = true;\n        } else {\n            revert FailedToParseBoolean();\n        }\n    }\n}\n"
    },
    "silo-core/contracts/incentives/interfaces/ISiloIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.28;\n\nimport {IDistributionManager} from \"./IDistributionManager.sol\";\nimport {DistributionTypes} from \"../lib/DistributionTypes.sol\";\n\ninterface ISiloIncentivesController is IDistributionManager {\n    event ClaimerSet(address indexed user, address indexed claimer);\n    event IncentivesProgramCreated(string name);\n    event IncentivesProgramUpdated(string name);\n    event ImmediateDistribution(address indexed rewardToken, bytes32 indexed programId, uint256 amount);\n\n    event RewardsAccrued(\n        address indexed user,\n        address indexed rewardToken,\n        string indexed programName,\n        uint256 amount\n    );\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        address indexed rewardToken,\n        bytes32 programId,\n        address claimer,\n        uint256 amount\n    );\n\n    error InvalidDistributionEnd();\n    error InvalidConfiguration();\n    error IndexOverflowAtEmissionsPerSecond();\n    error InvalidToAddress();\n    error InvalidUserAddress();\n    error ClaimerUnauthorized();\n    error InvalidRewardToken();\n    error IncentivesProgramAlreadyExists();\n    error IncentivesProgramNotFound();\n    error DifferentRewardsTokens();\n    error EmissionPerSecondTooHigh();\n    error EmptyShareToken();\n\n    /**\n     * @dev Silo share token event handler\n     * @param _sender The address of the sender\n     * @param _senderBalance The balance of the sender\n     * @param _recipient The address of the recipient\n     * @param _recipientBalance The balance of the recipient\n     * @param _totalSupply The total supply of the asset in the lending pool\n     * @param _amount The amount of the transfer\n     */\n    function afterTokenTransfer(\n        address _sender,\n        uint256 _senderBalance,\n        address _recipient,\n        uint256 _recipientBalance,\n        uint256 _totalSupply,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Immediately distributes rewards to the incentives program\n     * Expect an `_amount` to be transferred to the contract before calling this fn\n     * @param _tokenToDistribute The token to distribute\n     * @param _amount The amount of rewards to distribute\n     * @return programId The id of the created or existing program, or bytes32(0) if _amount is 0\n     */\n    function immediateDistribution(address _tokenToDistribute, uint256 _amount) external returns (bytes32 programId);\n\n    /// @dev It will transfer all the reward token balance to the owner.\n    /// @param _rewardToken The reward token to rescue\n    function rescueRewards(address _rewardToken) external;\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param _user The address of the user\n     * @param _claimer The address of the claimer\n     */\n    function setClaimer(address _user, address _claimer) external;\n\n    /**\n     * @dev Creates a new incentives program\n     * @param _incentivesProgramInput The incentives program creation input\n     */\n    function createIncentivesProgram(DistributionTypes.IncentivesProgramCreationInput memory _incentivesProgramInput)\n        external;\n\n    /**\n     * @dev Updates an existing incentives program\n     * @param _incentivesProgram The incentives program name\n     * @param _distributionEnd The distribution end\n     * @param _emissionPerSecond The emission per second\n     */\n    function updateIncentivesProgram(\n        string calldata _incentivesProgram,\n        uint40 _distributionEnd,\n        uint256 _emissionPerSecond\n    ) external;\n\n    /**\n     * @dev Claims reward for an user to the desired address, on all the assets of the lending pool,\n     * accumulating the pending rewards\n     * @param _to Address that will be receiving the rewards\n     * @return accruedRewards\n     */\n    function claimRewards(address _to) external returns (AccruedRewards[] memory accruedRewards);\n\n    /**\n     * @dev Claims reward for an user to the desired address, on all the assets of the lending pool,\n     * accumulating the pending rewards\n     * @param _to Address that will be receiving the rewards\n     * @param _programNames The incentives program names\n     * @return accruedRewards\n     */\n    function claimRewards(address _to, string[] calldata _programNames)\n        external\n        returns (AccruedRewards[] memory accruedRewards);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending\n     * rewards. The caller must be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param _user Address to check and claim rewards\n     * @param _to Address that will be receiving the rewards\n     * @param _programNames The incentives program names\n     * @return accruedRewards\n     */\n    function claimRewardsOnBehalf(address _user, address _to, string[] calldata _programNames)\n        external\n        returns (AccruedRewards[] memory accruedRewards);\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param _user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address _user) external view returns (address);\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param _user The address of the user\n     * @param _programName The incentives program name\n     * @return unclaimedRewards\n     */\n    function getRewardsBalance(address _user, string calldata _programName)\n        external\n        view\n        returns (uint256 unclaimedRewards);\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param _user The address of the user\n     * @param _programNames The incentives program names (should have the same rewards token)\n     * @return unclaimedRewards\n     */\n    function getRewardsBalance(address _user, string[] calldata _programNames)\n        external\n        view\n        returns (uint256 unclaimedRewards);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param _user the address of the user\n     * @param _programName The incentives program name\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address _user, string calldata _programName) external view returns (uint256);\n\n    /// @notice SHARE_TOKEN is contract with IERC20 interface with users balances, based based on which\n    /// rewards distribution is calculated. In Silo it is ususally collateral share token or debt share token.\n    function SHARE_TOKEN() external view returns (address); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "silo-core/contracts/interfaces/IGaugeHookReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IShareToken} from \"./IShareToken.sol\";\nimport {IHookReceiver} from \"./IHookReceiver.sol\";\nimport {ISiloIncentivesController} from \"silo-core/contracts/incentives/interfaces/ISiloIncentivesController.sol\";\n\n/// @notice Silo share token hook receiver for the gauge\ninterface IGaugeHookReceiver is IHookReceiver {\n    /// @dev Emit when the new gauge is configured\n    /// @param gauge Gauge for which hook receiver will send notification about the share token balance updates.\n    /// @param shareToken Share token.\n    event GaugeConfigured(address gauge, address shareToken);\n    /// @dev Emit when the gauge is removed\n    /// @param shareToken Share token for which the gauge was removed\n    event GaugeRemoved(address shareToken);\n\n    /// @dev Revert on an attempt to initialize with a zero `_owner` address\n    error OwnerIsZeroAddress();\n    /// @dev Revert on an attempt to initialize with an invalid `_shareToken` address\n    error InvalidShareToken();\n    /// @dev Revert on an attempt to setup a `_gauge` with a different `_shareToken`\n    /// than hook receiver were initialized\n    error WrongGaugeShareToken();\n    /// @dev Revert on an attempt to remove a `gauge` that still can mint SILO tokens\n    error CantRemoveActiveGauge();\n    /// @dev Revert on an attempt to set a gauge with a zero address\n    error EmptyGaugeAddress();\n    /// @dev Revert if the hook received `beforeAction` notification\n    error RequestNotSupported();\n    /// @dev Revert on an attempt to remove not configured gauge\n    error GaugeIsNotConfigured();\n    /// @dev Revert on an attempt to configure already configured gauge\n    error GaugeAlreadyConfigured();\n\n    /// @notice Configuration of the gauge\n    /// for which the hook receiver should send notifications about the share token balance updates.\n    /// The `_gauge` can be updated by an owner (DAO)\n    /// @dev Overrides existing configuration\n    /// @param _shareToken Share token for which the gauge is configured\n    /// @param _gauge Array of gauges for which hook receiver will send notification.\n    function setGauge(ISiloIncentivesController _gauge, IShareToken _shareToken) external;\n\n    /// @notice Remove the gauge from the hook receiver for the share token\n    /// @dev While removing the gauge,\n    /// we do not remove the action because we don't know if any other hook is using it.\n    /// @param _shareToken Share token for which the gauge needs to be removed\n    function removeGauge(IShareToken _shareToken) external;\n\n    /// @notice Get the gauge for the share token\n    /// @param _shareToken Share token\n    function configuredGauges(IShareToken _shareToken) external view returns (ISiloIncentivesController);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return a == 0 ? 0 : (a - 1) / b + 1;\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.UNDER_OVERFLOW);\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, expect 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Ferma's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return x < 0 ? (n - uint256(-x)) : uint256(x); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked has failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/IPartialLiquidationByDefaulting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {ISilo} from \"./ISilo.sol\";\nimport {ISiloIncentivesController} from \"../incentives/interfaces/ISiloIncentivesController.sol\";\n\n/// @notice Partial liquidation by defaulting will cancel borrower debt and distribute collateral shares \n/// to lenders via incentive contract. Lenders have to claim their shares to get them. \n/// Executor will get liquidation fee directly on his wallet.\n/// Partial liquidation by defaulting can reset total assets completely while leaving shares behind. \n/// In that case, all shares will be worth 0 and next deposit will lose the value of that left shares.\n/// Partial liquidation by defaulting can deduct collateral by 1 wei more than debt. This can happen \n/// when we doing full liquidation and conversion assets -> shares -> assets loses 1 wei.\ninterface IPartialLiquidationByDefaulting {\n    struct CallParams {\n        uint256 collateralSharesTotal;\n        uint256 protectedSharesTotal;\n        uint256 withdrawAssetsFromCollateral;\n        uint256 withdrawAssetsFromProtected;\n        uint256 collateralSharesForKeeper;\n        uint256 collateralSharesForLenders;\n        uint256 protectedSharesForKeeper;\n        uint256 protectedSharesForLenders;\n        bytes4 customError;\n    }\n    \n    /// @param canceledDebt amount of debt that was canceled by liquidation\n    /// @param deductedFromCollateral amount of collateral that was deducted from collateral, \n    /// it might be lower then debt eg in case of bad debt\n    event DefaultingLiquidation(uint256 canceledDebt, uint256 deductedFromCollateral);\n\n    error NoControllerForCollateral();\n    error CollateralNotSupportedForDefaulting();\n    error TwoWayMarketNotAllowed();\n    error UnnecessaryLiquidationFee();\n    error EmptyCollateralShareToken();\n    error DeductDefaultedDebtFromCollateralFailed();\n    error RepayDebtByDefaultingFailed();\n    error InvalidLTConfig0();\n    error InvalidLTConfig1();\n\n    /// @notice Function to liquidate insolvent position by distributing user's collateral to lenders\n    /// The caller (liquidator) does not cover any debt. `debtToCover` is amount of debt being liquidated\n    ///   based on which amount of `collateralAsset` is calculated to distribute to lenders plus a liquidation fee.\n    ///   Liquidation fee is split 80/20 between lenders and liquidator.\n    /// Defaulting liquidation can leave dust shares behind, because math uses assets, \n    /// and dust shares are worth less than 1 asset.\n    /// @dev this method reverts when:\n    /// - `_maxDebtToCover` is zero\n    /// - `_user` is solvent and there is no debt to cover\n    /// - oracle is throwing (might be also because of tiny position eg 1wei)\n    /// - `_borrower` is solvent in terms of defaulting (might be insolvent for standard liquidation)\n    /// - on ReturnZeroShares error\n    /// - when asset:share ratio is such that 1 asset does not equal at least 1 share eg: \n    ///    totalAssets = 100, totalShares = 10, assetsToLiquidate = 1\n    /// @param _user The address of the borrower getting liquidated\n    /// @return withdrawCollateral collateral that was send to `msg.sender`, in case of `_receiveSToken` is TRUE,\n    /// `withdrawCollateral` will be estimated, on redeem one can expect this value to be rounded down\n    /// @return repayDebtAssets actual debt value that was repaid by `msg.sender`\n    function liquidationCallByDefaulting(address _user)\n        external\n        returns (uint256 withdrawCollateral, uint256 repayDebtAssets);\n\n    /// @dev it can revert in case of assets or shares values close to max uint256\n    function getKeeperAndLenderSharesSplit(\n        uint256 _assetsToLiquidate,\n        ISilo.CollateralType _collateralType\n    ) external view returns (uint256 totalSharesToLiquidate, uint256 keeperShares, uint256 lendersShares);\n\n    /// @notice Validate if market is supported by defaulting, reverts if not\n    function validateDefaultingCollateral() external view;\n\n    /// @notice Validate if gauge controller (silo incentives controller) is set for debt silo, reverts if not\n    /// @param _silo The address of the silo from which debt is borrowed\n    /// @return controllerCollateral The address of the gauge for debt silo\n    function validateControllerForCollateral(address _silo)\n        external\n        view\n        returns (ISiloIncentivesController controllerCollateral);\n\n    /// @dev Additional liquidation threshold (LT) margin applied during defaulting liquidations\n    /// to give priority to traditional liquidations over defaulting ones. Expressed in 18 decimals.\n    // solhint-disable-next-line func-name-mixedcase\n    function LT_MARGIN_FOR_DEFAULTING() external view returns (uint256);\n\n    /// @dev Address of the DefaultingSiloLogic contract used by Silo for delegate calls\n    // solhint-disable-next-line func-name-mixedcase\n    function LIQUIDATION_LOGIC() external view returns (address);\n\n    /// @dev The portion of total liquidation fee proceeds allocated to the keeper. Expressed in 18 decimals.\n    /// For example, liquidation fee is 10% (0.1e18), and keeper fee is 20% (0.2e18),\n    /// then 2% liquidation fee goes to the keeper and 8% goes to the protocol.\n    // solhint-disable-next-line func-name-mixedcase\n    function KEEPER_FEE() external view returns (uint256);   \n}\n"
    },
    "silo-core/contracts/lib/SiloStorageLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\n\nlibrary SiloStorageLib {\n    // keccak256(abi.encode(uint256(keccak256(\"silo.storage.SiloVault\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant _STORAGE_LOCATION = 0xd7513ffe3a01a9f6606089d1b67011bca35bec018ac0faa914e1c529408f8300;\n\n    function getSiloStorage() internal pure returns (ISilo.SiloStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n}\n"
    },
    "silo-core/contracts/hooks/liquidation/lib/PartialLiquidationLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {IPartialLiquidation} from \"silo-core/contracts/interfaces/IPartialLiquidation.sol\";\nimport {Rounding} from \"silo-core/contracts/lib/Rounding.sol\";\n\nlibrary PartialLiquidationLib {\n    using Math for uint256;\n\n    struct LiquidationPreviewParams {\n        uint256 collateralLt;\n        address collateralConfigAsset;\n        address debtConfigAsset;\n        uint256 maxDebtToCover;\n        uint256 liquidationFee;\n        uint256 liquidationTargetLtv;\n    }\n\n    /// @dev this is basically LTV == 100%\n    uint256 internal constant _BAD_DEBT = 1e18;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    /// @dev underestimation for collateral that user gets on liquidation\n    /// liquidation is executed based on sTokens, additional flow is: assets -> shares -> assets\n    /// this two conversions are rounding down and can create 2 wai difference\n    uint256 internal constant _UNDERESTIMATION = 2;\n\n    /// @dev If the ratio of the repay value to the total debt value during liquidation exceeds the \n    /// _FULL_LIQUIDATION_THRESHOLD threshold, a full liquidation is triggered.\n    /// For example, if the total debt value is 51 and the dust level is set at 98%, \n    /// then we are unable to liquidate 50, we must proceed to liquidate the entire 51.\n    uint256 internal constant _FULL_LIQUIDATION_THRESHOLD = 0.9e18; // 90%\n\n    /// @dev debt keeps growing over time, so when dApp use this view to calculate max, tx should never revert\n    /// because actual max can be only higher\n    /// @notice This method does not check, if user is solvent and it can return non zero result when user solvent\n    function maxLiquidation(\n        uint256 _sumOfCollateralAssets,\n        uint256 _sumOfCollateralValue,\n        uint256 _borrowerDebtAssets,\n        uint256 _borrowerDebtValue,\n        uint256 _liquidationTargetLTV,\n        uint256 _liquidationFee\n    )\n        internal\n        pure\n        returns (uint256 collateralToLiquidate, uint256 debtToRepay)\n    {\n        (\n            uint256 collateralValueToLiquidate, uint256 repayValue\n        ) = maxLiquidationPreview(\n            _sumOfCollateralValue,\n            _borrowerDebtValue,\n            _liquidationTargetLTV,\n            _liquidationFee\n        );\n\n        collateralToLiquidate = valueToAssetsByRatio(\n            collateralValueToLiquidate,\n            _sumOfCollateralAssets,\n            _sumOfCollateralValue\n        );\n\n        if (collateralToLiquidate > _UNDERESTIMATION) {\n            // -_UNDERESTIMATION here is to underestimate collateral that user gets on liquidation\n            // liquidation is executed based on sTokens, additional flow is: assets -> shares -> assets\n            // this two conversions are rounding down and can create 2 wei difference\n\n            // we will not underflow on -_UNDERESTIMATION because collateralToLiquidate is >= _UNDERESTIMATION\n            unchecked { collateralToLiquidate -= _UNDERESTIMATION; }\n        } else {\n            collateralToLiquidate = 0;\n        }\n\n        debtToRepay = valueToAssetsByRatio(repayValue, _borrowerDebtAssets, _borrowerDebtValue);\n    }\n\n    /// @dev in case of bad debt, we do not apply any restrictions.\n    /// @notice might revert when one of this values will be zero:\n    /// `_sumOfCollateralValue`, `_borrowerDebtAssets`, `_borrowerDebtValue`\n    function liquidationPreview( // solhint-disable-line function-max-lines\n        uint256 _ltvBefore,\n        uint256 _sumOfCollateralAssets,\n        uint256 _sumOfCollateralValue,\n        uint256 _borrowerDebtAssets,\n        uint256 _borrowerDebtValue,\n        LiquidationPreviewParams memory _params\n    )\n        internal\n        pure\n        returns (uint256 collateralToLiquidate, uint256 debtToRepay, uint256 ltvAfter)\n    {\n        uint256 collateralValueToLiquidate;\n        uint256 debtValueToRepay;\n\n        if (_ltvBefore >= _BAD_DEBT) {\n            // in case of bad debt, we allow for any amount\n            debtToRepay = _params.maxDebtToCover > _borrowerDebtAssets ? _borrowerDebtAssets : _params.maxDebtToCover;\n            debtValueToRepay = valueToAssetsByRatio(debtToRepay, _borrowerDebtValue, _borrowerDebtAssets);\n        } else {\n            uint256 maxRepayValue = estimateMaxRepayValue(\n                _borrowerDebtValue,\n                _sumOfCollateralValue,\n                _params.liquidationTargetLtv,\n                _params.liquidationFee\n            );\n\n            if (maxRepayValue == _borrowerDebtValue) {\n                // forced full liquidation\n                debtToRepay = _borrowerDebtAssets;\n                debtValueToRepay = _borrowerDebtValue;\n            } else {\n                // partial liquidation\n                uint256 maxDebtToRepay = valueToAssetsByRatio(maxRepayValue, _borrowerDebtAssets, _borrowerDebtValue);\n                debtToRepay = _params.maxDebtToCover > maxDebtToRepay ? maxDebtToRepay : _params.maxDebtToCover;\n                debtValueToRepay = valueToAssetsByRatio(debtToRepay, _borrowerDebtValue, _borrowerDebtAssets);\n            }\n        }\n\n        collateralValueToLiquidate = calculateCollateralToLiquidate(\n            debtValueToRepay, _sumOfCollateralValue, _params.liquidationFee\n        );\n\n        collateralToLiquidate = valueToAssetsByRatio(\n            collateralValueToLiquidate,\n            _sumOfCollateralAssets,\n            _sumOfCollateralValue\n        );\n\n        ltvAfter = _calculateLtvAfter(\n            _sumOfCollateralValue, _borrowerDebtValue, collateralValueToLiquidate, debtValueToRepay\n        );\n    }\n\n    /// @notice reverts on `_totalValue` == 0\n    /// @dev calculate assets based on ratio: assets = (value, totalAssets, totalValue)\n    /// to calculate assets => value, use it like: value = (assets, totalValue, totalAssets)\n    /// this method is used for collateral assets and for debt assets\n    function valueToAssetsByRatio(uint256 _value, uint256 _totalAssets, uint256 _totalValue)\n        internal\n        pure\n        returns (uint256 assets)\n    {\n        require(_totalValue != 0, IPartialLiquidation.UnknownRatio());\n\n        assets = Math.mulDiv(_value, _totalAssets, _totalValue, Rounding.DOWN);\n    }\n\n    /// @notice this function never reverts\n    /// @dev in case there is not enough collateral to liquidate, whole collateral is returned, no revert\n    /// @param  _totalBorrowerCollateralValue can not be 0, otherwise revert\n    function calculateCollateralsToLiquidate(\n        uint256 _debtValueToCover,\n        uint256 _totalBorrowerCollateralValue,\n        uint256 _totalBorrowerCollateralAssets,\n        uint256 _liquidationFee\n    ) internal pure returns (uint256 collateralAssetsToLiquidate, uint256 collateralValueToLiquidate) {\n        collateralValueToLiquidate = calculateCollateralToLiquidate(\n            _debtValueToCover, _totalBorrowerCollateralValue, _liquidationFee\n        );\n\n        // this is also true if _totalBorrowerCollateralValue == 0, so div below will not revert\n        if (collateralValueToLiquidate == _totalBorrowerCollateralValue) {\n            return (_totalBorrowerCollateralAssets, _totalBorrowerCollateralValue);\n        }\n\n        // this will never revert, because of `if collateralValueToLiquidate == _totalBorrowerCollateralValue`\n        collateralAssetsToLiquidate = valueToAssetsByRatio(\n            collateralValueToLiquidate, _totalBorrowerCollateralAssets, _totalBorrowerCollateralValue\n        );\n    }\n\n    /// @dev the math is based on: (Dv - x)/(Cv - (x + xf)) = LT\n    /// where Dv: debt value, Cv: collateral value, LT: expected LT, f: liquidation fee, x: is value we looking for\n    /// @notice in case math fail to calculate repay value, eg when collateral is not enough to cover repay and fee\n    /// function will return full debt value and full collateral value, it will not revert. It is up to liquidator\n    /// to make decision if it will be profitable\n    /// @param _totalBorrowerCollateralValue regular and protected\n    /// @param _ltvAfterLiquidation % of `repayValue` that liquidator will use as profit from liquidating\n    function maxLiquidationPreview(\n        uint256 _totalBorrowerCollateralValue,\n        uint256 _totalBorrowerDebtValue,\n        uint256 _ltvAfterLiquidation,\n        uint256 _liquidationFee\n    ) internal pure returns (uint256 collateralValueToLiquidate, uint256 repayValue) {\n        repayValue = estimateMaxRepayValue(\n            _totalBorrowerDebtValue, _totalBorrowerCollateralValue, _ltvAfterLiquidation, _liquidationFee\n        );\n\n        collateralValueToLiquidate = calculateCollateralToLiquidate(\n            repayValue, _totalBorrowerCollateralValue, _liquidationFee\n        );\n    }\n\n    /// @param _maxDebtToCover assets or value, but must be in sync with `_totalCollateral`\n    /// @param _sumOfCollateral assets or value, but must be in sync with `_maxDebtToCover`\n    /// @return toLiquidate depends on inputs, it might be collateral value or collateral assets\n    function calculateCollateralToLiquidate(uint256 _maxDebtToCover, uint256 _sumOfCollateral, uint256 _liquidationFee)\n        internal\n        pure\n        returns (uint256 toLiquidate)\n    {\n        uint256 fee = _maxDebtToCover * _liquidationFee / _PRECISION_DECIMALS;\n\n        toLiquidate = _maxDebtToCover + fee;\n\n        if (toLiquidate > _sumOfCollateral) {\n            toLiquidate = _sumOfCollateral;\n        }\n    }\n\n    /// @dev the math is based on: (Dv - x)/(Cv - (x + xf)) = LTV\n    /// where \n    ///    Dv: debt value,\n    ///    Cv: collateral value,\n    ///    LTV: expected LTV after liquidation,\n    ///    f: liquidation fee,\n    ///    x: is value we looking for\n    /// x = (Dv - LTV * Cv) / (DP - LTV - LTV * f)\n    /// result also take into consideration the dust\n    /// @notice protocol does not uses this method, because in protocol our input is debt to cover in assets\n    /// however this is useful to figure out what is max debt to cover.\n    /// @param _totalBorrowerCollateralValue regular and protected\n    /// @param _ltvAfterLiquidation % of `repayValue` that liquidator will use as profit from liquidating\n    /// @return repayValue max repay value that is allowed for partial liquidation. if this value equals\n    /// `_totalBorrowerDebtValue`, that means dust threshold was triggered and result force to do full liquidation\n    function estimateMaxRepayValue( // solhint-disable-line code-complexity\n        uint256 _totalBorrowerDebtValue,\n        uint256 _totalBorrowerCollateralValue,\n        uint256 _ltvAfterLiquidation,\n        uint256 _liquidationFee\n    ) internal pure returns (uint256 repayValue) {\n        if (_totalBorrowerDebtValue == 0) return 0;\n        if (_liquidationFee >= _PRECISION_DECIMALS) return 0;\n\n        // this will cover case, when _totalBorrowerCollateralValue == 0\n        if (_totalBorrowerDebtValue >= _totalBorrowerCollateralValue) return _totalBorrowerDebtValue;\n        if (_ltvAfterLiquidation == 0) return _totalBorrowerDebtValue; // full liquidation\n\n        // x = (Dv - LTV * Cv) / (DP - LTV - LTV * f) ==> (Dv - LTV * Cv) / (DP - (LTV + LTV * f))\n        uint256 ltCv = _ltvAfterLiquidation * _totalBorrowerCollateralValue;\n        // to lose as low precision as possible, instead of `ltCv/1e18`, we increase precision of DebtValue\n        _totalBorrowerDebtValue *= _PRECISION_DECIMALS;\n\n        // negative value means our current LTV is lower than _ltvAfterLiquidation\n        if (ltCv >= _totalBorrowerDebtValue) return 0;\n\n        uint256 dividerR; // LTV + LTV * f\n\n        unchecked {\n            // safe because of above `LTCv >= _totalBorrowerDebtValue`\n            repayValue = _totalBorrowerDebtValue - ltCv;\n            // we checked at begin `_liquidationFee >= _PRECISION_DECIMALS`\n            // mul on DP will not overflow on uint256, div is safe\n            dividerR = _ltvAfterLiquidation + _ltvAfterLiquidation * _liquidationFee / _PRECISION_DECIMALS;\n        }\n\n        // now we can go back to proper precision\n        unchecked { _totalBorrowerDebtValue /= _PRECISION_DECIMALS; }\n\n        // if dividerR is more than 100%, means it is impossible to go down to _ltvAfterLiquidation, return all\n        if (dividerR >= _PRECISION_DECIMALS) {\n             return _totalBorrowerDebtValue;\n        }\n\n        unchecked { repayValue /= (_PRECISION_DECIMALS - dividerR); }\n\n        // early return so we do not have to check for dust\n        if (repayValue > _totalBorrowerDebtValue) return _totalBorrowerDebtValue;\n\n        // here is weird case, sometimes it is impossible to go down to target LTV, however math can calculate it\n        // eg with negative numerator and denominator and result will be positive, that's why we simply return all\n        // we also cover dust case here\n        return repayValue * _PRECISION_DECIMALS / _totalBorrowerDebtValue > _FULL_LIQUIDATION_THRESHOLD\n            ? _totalBorrowerDebtValue\n            : repayValue;\n    }\n\n    /// @dev protected collateral is prioritized\n    /// @param _borrowerProtectedAssets available users protected collateral\n    function splitReceiveCollateralToLiquidate(uint256 _collateralToLiquidate, uint256 _borrowerProtectedAssets)\n        internal\n        pure\n        returns (uint256 withdrawAssetsFromCollateral, uint256 withdrawAssetsFromProtected)\n    {\n        if (_collateralToLiquidate == 0) return (0, 0);\n\n        unchecked {\n            (\n                withdrawAssetsFromCollateral, withdrawAssetsFromProtected\n            ) = _collateralToLiquidate > _borrowerProtectedAssets\n                // safe to uncheck because of above condition\n                ? (_collateralToLiquidate - _borrowerProtectedAssets, _borrowerProtectedAssets)\n                : (0, _collateralToLiquidate);\n        }\n    }\n\n    /// @notice must stay private because this is not for general LTV, only for ltv after internally\n    function _calculateLtvAfter(\n        uint256 _sumOfCollateralValue,\n        uint256 _totalDebtValue,\n        uint256 _collateralValueToLiquidate,\n        uint256 _debtValueToCover\n    )\n        private\n        pure\n        returns (uint256 ltvAfterLiquidation)\n    {\n        if (_sumOfCollateralValue <= _collateralValueToLiquidate || _totalDebtValue <= _debtValueToCover) {\n            return 0;\n        }\n\n        unchecked { // all subs are safe because these values are chunks of total, so we will not underflow\n            ltvAfterLiquidation = _ltvAfter(\n                _sumOfCollateralValue - _collateralValueToLiquidate,\n                _totalDebtValue - _debtValueToCover\n            );\n        }\n    }\n\n    /// @notice must stay private because this is not for general LTV, only for ltv after\n    function _ltvAfter(uint256 _collateral, uint256 _debt) private pure returns (uint256 ltv) {\n        // previous calculation of LTV\n        ltv = _debt * _PRECISION_DECIMALS;\n        ltv = Math.ceilDiv(ltv, _collateral); // Rounding.LTV is up/ceil\n    }\n}\n"
    },
    "silo-core/contracts/hooks/liquidation/PartialLiquidation.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"openzeppelin5/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\nimport {IShareToken} from \"silo-core/contracts/interfaces/IShareToken.sol\";\nimport {IPartialLiquidation} from \"silo-core/contracts/interfaces/IPartialLiquidation.sol\";\nimport {ISiloConfig} from \"silo-core/contracts/interfaces/ISiloConfig.sol\";\nimport {IHookReceiver} from \"silo-core/contracts/interfaces/IHookReceiver.sol\";\n\nimport {SiloMathLib} from \"silo-core/contracts/lib/SiloMathLib.sol\";\nimport {Hook} from \"silo-core/contracts/lib/Hook.sol\";\nimport {Rounding} from \"silo-core/contracts/lib/Rounding.sol\";\nimport {RevertLib} from \"silo-core/contracts/lib/RevertLib.sol\";\nimport {CallBeforeQuoteLib} from \"silo-core/contracts/lib/CallBeforeQuoteLib.sol\";\n\nimport {PartialLiquidationExecLib} from \"silo-core/contracts/hooks/liquidation/lib/PartialLiquidationExecLib.sol\";\nimport {TransientReentrancy} from \"silo-core/contracts/hooks/_common/TransientReentrancy.sol\";\nimport {BaseHookReceiver} from \"silo-core/contracts/hooks/_common/BaseHookReceiver.sol\";\n\n/// @title PartialLiquidation module for executing liquidations\n/// @dev if we need additional hook functionality, this contract should be included as parent\nabstract contract PartialLiquidation is TransientReentrancy, BaseHookReceiver, IPartialLiquidation {\n    using SafeERC20 for IERC20;\n    using Hook for uint24;\n    using CallBeforeQuoteLib for ISiloConfig.ConfigData;\n\n    struct LiquidationCallParams {\n        uint256 collateralShares;\n        uint256 protectedShares;\n        uint256 withdrawAssetsFromCollateral;\n        uint256 withdrawAssetsFromProtected;\n        bytes4 customError;\n    }\n\n    /// @inheritdoc IPartialLiquidation\n    function liquidationCall( // solhint-disable-line function-max-lines, code-complexity\n        address _collateralAsset,\n        address _debtAsset,\n        address _borrower,\n        uint256 _maxDebtToCover,\n        bool _receiveSToken\n    )\n        external\n        virtual\n        nonReentrant\n        returns (uint256 withdrawCollateral, uint256 repayDebtAssets)\n    {\n        ISiloConfig siloConfigCached = siloConfig;\n\n        require(address(siloConfigCached) != address(0), EmptySiloConfig());\n        require(_maxDebtToCover != 0, NoDebtToCover());\n\n        siloConfigCached.turnOnReentrancyProtection();\n\n        (\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        ) = _fetchConfigs(siloConfigCached, _collateralAsset, _debtAsset, _borrower);\n\n        LiquidationCallParams memory params;\n\n        (\n            params.withdrawAssetsFromCollateral, params.withdrawAssetsFromProtected, repayDebtAssets, params.customError\n        ) = PartialLiquidationExecLib.getExactLiquidationAmounts(\n            collateralConfig,\n            debtConfig,\n            _borrower,\n            _maxDebtToCover,\n            collateralConfig.liquidationFee\n        );\n\n        RevertLib.revertIfError(params.customError);\n\n        // we do not allow dust so full liquidation is required\n        require(repayDebtAssets <= _maxDebtToCover, FullLiquidationRequired());\n\n        IERC20(debtConfig.token).safeTransferFrom(msg.sender, address(this), repayDebtAssets);\n        IERC20(debtConfig.token).safeIncreaseAllowance(debtConfig.silo, repayDebtAssets);\n\n        address shareTokenReceiver = _receiveSToken ? msg.sender : address(this);\n\n        params.collateralShares = _callShareTokenForwardTransferNoChecks(\n            collateralConfig.silo,\n            _borrower,\n            shareTokenReceiver,\n            params.withdrawAssetsFromCollateral,\n            collateralConfig.collateralShareToken,\n            ISilo.AssetType.Collateral\n        );\n\n        params.protectedShares = _callShareTokenForwardTransferNoChecks(\n            collateralConfig.silo,\n            _borrower,\n            shareTokenReceiver,\n            params.withdrawAssetsFromProtected,\n            collateralConfig.protectedShareToken,\n            ISilo.AssetType.Protected\n        );\n\n        siloConfigCached.turnOffReentrancyProtection();\n\n        ISilo(debtConfig.silo).repay(repayDebtAssets, _borrower);\n\n        // without collateral this is not longer liquidation, it's repay\n        require(params.collateralShares != 0 || params.protectedShares != 0, NoCollateralToLiquidate());\n\n        if (_receiveSToken) {\n            if (params.collateralShares != 0) {\n                withdrawCollateral = ISilo(collateralConfig.silo).previewRedeem(\n                    params.collateralShares,\n                    ISilo.CollateralType.Collateral\n                );\n            }\n\n            if (params.protectedShares != 0) {\n                unchecked {\n                    // protected and collateral values were split from total collateral to withdraw,\n                    // so we will not overflow when we sum them back, especially that on redeem, we rounding down\n                    withdrawCollateral += ISilo(collateralConfig.silo).previewRedeem(\n                        params.protectedShares,\n                        ISilo.CollateralType.Protected\n                    );\n                }\n            }\n        } else {\n            // in case of liquidation redeem, hook transfers sTokens to itself and it has no debt\n            // so solvency will not be checked in silo on redeem action\n\n            // if share token offset is more than 0, positive number of shares can generate 0 assets\n            // so there is a need to check assets before we withdraw collateral/protected\n\n            withdrawCollateral = _tryRedeem({\n                _silo: collateralConfig.silo,\n                _shareToken: collateralConfig.collateralShareToken,\n                _shares: params.collateralShares,\n                _collateralType: ISilo.CollateralType.Collateral\n            });\n\n            unchecked {\n                // protected and collateral values were split from total collateral to withdraw,\n                // so we will not overflow when we sum them back, especially that on redeem, we rounding down\n                withdrawCollateral += _tryRedeem({\n                    _silo: collateralConfig.silo,\n                    _shareToken: collateralConfig.protectedShareToken,\n                    _shares: params.protectedShares,\n                    _collateralType: ISilo.CollateralType.Protected\n                });\n            }\n        }\n\n        emit LiquidationCall(\n            msg.sender, debtConfig.silo, _borrower, repayDebtAssets, withdrawCollateral, _receiveSToken\n        );\n    }\n\n    /// @inheritdoc IPartialLiquidation\n    function maxLiquidation(address _borrower)\n        external\n        view\n        virtual\n        returns (uint256 collateralToLiquidate, uint256 debtToRepay, bool sTokenRequired)\n    {\n        return PartialLiquidationExecLib.maxLiquidation(siloConfig, _borrower);\n    }\n\n    function _fetchConfigs(\n        ISiloConfig _siloConfigCached,\n        address _collateralAsset,\n        address _debtAsset,\n        address _borrower\n    )\n        internal\n        virtual\n        returns (\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        )\n    {\n        (collateralConfig, debtConfig) = _siloConfigCached.getConfigsForSolvency(_borrower);\n\n        require(debtConfig.silo != address(0), UserIsSolvent());\n        require(_collateralAsset == collateralConfig.token, UnexpectedCollateralToken());\n        require(_debtAsset == debtConfig.token, UnexpectedDebtToken());\n\n        ISilo(debtConfig.silo).accrueInterest();\n\n        if (collateralConfig.silo != debtConfig.silo) {\n            ISilo(collateralConfig.silo).accrueInterest();\n            collateralConfig.callSolvencyOracleBeforeQuote();\n            debtConfig.callSolvencyOracleBeforeQuote();\n        }\n    }\n\n    function _callShareTokenForwardTransferNoChecks(\n        address _silo,\n        address _borrower,\n        address _receiver,\n        uint256 _withdrawAssets,\n        address _shareToken,\n        ISilo.AssetType _assetType\n    ) internal virtual returns (uint256 shares) {\n        if (_withdrawAssets == 0) return 0;\n\n        shares = SiloMathLib.convertToShares(\n            _withdrawAssets,\n            ISilo(_silo).getTotalAssetsStorage(_assetType),\n            IShareToken(_shareToken).totalSupply(),\n            Rounding.LIQUIDATE_TO_SHARES,\n            ISilo.AssetType(_assetType)\n        );\n\n        if (shares == 0) return 0;\n\n        IShareToken(_shareToken).forwardTransferFromNoChecks(_borrower, _receiver, shares);\n    }\n\n    function _tryRedeem(\n        address _silo,\n        address _shareToken,\n        uint256 _shares,\n        ISilo.CollateralType _collateralType\n    ) internal returns (uint256 withdrawCollateral) {\n        if (_shares == 0) return 0;\n\n        try ISilo(_silo).redeem({\n            _shares: _shares,\n            _receiver: msg.sender,\n            _owner: address(this),\n            _collateralType: _collateralType\n        }) returns (uint256 assets) {\n            withdrawCollateral = assets;\n        } catch (bytes memory e) {\n            if (_isToAssetsConvertionError(e)) {\n                IERC20(_shareToken).transfer(msg.sender, _shares);\n            } else {\n                RevertLib.revertBytes(e, string(\"\"));\n            }\n        }\n    }\n\n    /// @dev this method detect if error is caused by unable to convert shares to assets eg 999 shares => 0 assets\n    function _isToAssetsConvertionError(bytes memory _error) internal pure returns (bool) {\n        return _error.length == 4 && bytes4(_error) == ISilo.ReturnZeroAssets.selector;\n    }\n}\n"
    },
    "silo-core/contracts/hooks/defaulting/DefaultingSiloLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.28;\n\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\n\nimport {SiloStorageLib} from \"silo-core/contracts/lib/SiloStorageLib.sol\";\nimport {DefaultingRepayLib} from \"silo-core/contracts/hooks/defaulting/DefaultingRepayLib.sol\";\nimport {IPartialLiquidationByDefaulting} from \"silo-core/contracts/interfaces/IPartialLiquidationByDefaulting.sol\";\n\n\n\n/// @title DefaultingSiloLogic\n/// @dev implements custom logic for Silo to do delegate calls\ncontract DefaultingSiloLogic {\n    using Math for uint256;\n    using Math for uint192;\n    using SafeCast for uint256;\n\n    /// @dev This is a copy of Silo.sol repay() function with this changes:\n    /// - DefaultingRepayLib.actionsRepay() is used instead of Actions.repay()\n    /// - returns shares and assets instead only shares\n    function repayDebtByDefaulting(uint256 _assets, address _borrower) \n        external\n        virtual\n        returns (uint256 shares, uint256 assets) \n    {\n        (assets, shares) = DefaultingRepayLib.actionsRepay({\n            _assets: _assets,\n            _shares: 0,\n            _borrower: _borrower,\n            _repayer: msg.sender\n        });\n\n        emit ISilo.Repay(msg.sender, _borrower, assets, shares);\n    }\n\n    function deductDefaultedDebtFromCollateral(uint256 _assetsToRepay) external virtual {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        bool success;\n        uint256 totalCollateralAssets = $.totalAssets[ISilo.AssetType.Collateral];\n\n        // if underflow happens, $.totalAssets[ISilo.AssetType.Collateral] is set to 0 and success is false\n        (success, $.totalAssets[ISilo.AssetType.Collateral]) = totalCollateralAssets.trySub(_assetsToRepay);\n        uint256 deductedFromCollateral = _assetsToRepay;\n        \n        if (!success) {\n            uint256 excessDebt = _assetsToRepay - totalCollateralAssets;\n            deductedFromCollateral = totalCollateralAssets;\n            (, uint256 revenue) = uint256($.daoAndDeployerRevenue).trySub(excessDebt);\n            $.daoAndDeployerRevenue = revenue.toUint192();\n        }\n\n        emit IPartialLiquidationByDefaulting.DefaultingLiquidation(_assetsToRepay, deductedFromCollateral);\n    }\n}\n"
    },
    "silo-core/contracts/hooks/_common/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.28;\n\nimport {AccessControlEnumerable} from \"openzeppelin5/access/extensions/AccessControlEnumerable.sol\";\n\nabstract contract Whitelist is AccessControlEnumerable {\n    bytes32 public constant ALLOWED_ROLE = keccak256(\"ALLOWED_ROLE\");\n\n    error OnlyAllowedRole();\n\n    modifier onlyAllowedOrPublic() {\n        // If no allowed role is set, allow anyone to liquidate\n        require(getRoleMemberCount(ALLOWED_ROLE) == 0 || hasRole(ALLOWED_ROLE, msg.sender), OnlyAllowedRole());\n\n        _;\n    }\n\n    modifier onlyAllowed() {\n        require(hasRole(ALLOWED_ROLE, msg.sender), OnlyAllowedRole());\n\n        _;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __Whitelist_init(address _owner) internal virtual {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "silo-core/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IERC3156FlashBorrower {\n    /// @notice During the execution of the flashloan, Silo methods are not taking into consideration the fact,\n    /// that some (or all) tokens were transferred as flashloan, therefore some methods can return invalid state\n    /// eg. maxWithdraw can return amount that are not available to withdraw during flashlon.\n    /// @dev Receive a flash loan.\n    /// @param _initiator The initiator of the loan.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _fee The additional amount of tokens to repay.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    /// @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n    function onFlashLoan(address _initiator, address _token, uint256 _amount, uint256 _fee, bytes calldata _data)\n        external\n        returns (bytes32);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "silo-core/contracts/incentives/interfaces/IDistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.28;\n\nimport {DistributionTypes} from \"../lib/DistributionTypes.sol\";\n\ninterface IDistributionManager {\n    struct IncentivesProgram {\n        uint256 index;\n        address rewardToken; // can't be updated after creation\n        uint256 emissionPerSecond; // configured by owner\n        uint40 lastUpdateTimestamp;\n        uint40 distributionEnd; // configured by owner\n        mapping(address user => uint256 userIndex) users;\n    }\n\n    struct IncentiveProgramDetails {\n        uint256 index;\n        address rewardToken;\n        uint256 emissionPerSecond;\n        uint40 lastUpdateTimestamp;\n        uint40 distributionEnd;\n    }\n\n    struct AccruedRewards {\n        uint256 amount;\n        bytes32 programId;\n        address rewardToken;\n    }\n\n    event AssetConfigUpdated(address indexed asset, uint256 emission);\n    event AssetIndexUpdated(address indexed asset, uint256 index);\n    event DistributionEndUpdated(string incentivesProgram, uint256 newDistributionEnd);\n    event IncentivesProgramIndexUpdated(string incentivesProgram, uint256 newIndex);\n    event UserIndexUpdated(address indexed user, string incentivesProgram, uint256 newIndex);\n\n    error OnlyNotifier();\n    error TooLongProgramName();\n    error InvalidIncentivesProgramName();\n    error OnlyNotifierOrOwner();\n    error ZeroAddress();\n\n    error EmissionForTimeDeltaOverflow();\n    error IndexOverflow();\n    error NewIndexOverflow();\n\n    /**\n     * @dev Sets the end date for the distribution\n     * @param _incentivesProgram The incentives program name\n     * @param _distributionEnd The end date timestamp\n     */\n    function setDistributionEnd(string calldata _incentivesProgram, uint40 _distributionEnd) external;\n\n    /**\n     * @dev Gets the end date for the distribution  \n     * @param _incentivesProgram The incentives program name\n     * @return The end of the distribution\n     */\n    function getDistributionEnd(string calldata _incentivesProgram) external view returns (uint256);\n\n    /**\n     * @dev Returns the data of an user on a distribution\n     * @param _user Address of the user\n     * @param _incentivesProgram The incentives program name\n     * @return The new index\n     */\n    function getUserData(address _user, string calldata _incentivesProgram) external view returns (uint256);\n\n    /**\n     * @dev Returns the configuration of the distribution for a certain incentives program\n     * @param _incentivesProgram The incentives program name\n     * @return details The configuration of the incentives program\n     */\n    function incentivesProgram(string calldata _incentivesProgram)\n        external\n        view\n        returns (IncentiveProgramDetails memory details);\n    \n    /**\n     * @dev returns the names of all the incentives programs\n     * @return programsNames the names of all the incentives programs\n     */\n    function getAllProgramsNames() external view returns (string[] memory programsNames);\n\n    /**\n     * @dev Returns the name of an incentives program (converts bytes32 to string)\n     * @notice This function has a bug and can't do it in proper way when _programId is for \n     * immediate distribution (token address) that was not created yet. \n     * It works for programs that already exists.\n     *\n     * @param _programId the id (bytes32) of the incentives program\n     * @return programName the name (string) of the incentives program\n     */\n    function getProgramName(bytes32 _programId) external view returns (string memory programName);\n\n\n    /// @dev NOTIFIER is contract that is allowed to notify controller about token transfers.\n    /// In original Aave implementation it was share token, but in Silo implementation it is usually hook contract.\n    function NOTIFIER() external view returns (address); // solhint-disable-line func-name-mixedcase\n    \n    /**\n     * @dev Returns the program id for the given program name.\n     * This method TRUNCATES the program name to 32 bytes.\n     * If provided strings only differ after the 32nd byte they would result in the same ProgramId.\n     * Ensure to use inputs that will result in 32 bytes or less.\n     * @param _programName The incentives program name\n     * @return programId\n     */\n    function getProgramId(string calldata _programName) external pure returns (bytes32 programId);\n}\n"
    },
    "silo-core/contracts/incentives/lib/DistributionTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity 0.8.28;\n\nlibrary DistributionTypes {\n    struct IncentivesProgramCreationInput {\n        string name;\n        address rewardToken;\n        uint256 emissionPerSecond;\n        uint40 distributionEnd;\n    }\n\n    struct AssetConfigInput {\n        uint256 emissionPerSecond;\n        uint256 totalStaked;\n        address underlyingAsset;\n    }\n\n    struct UserStakeInput {\n        address underlyingAsset;\n        uint256 stakedByUser;\n        uint256 totalStaked;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/Rounding.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\n// solhint-disable private-vars-leading-underscore\nlibrary Rounding {\n    Math.Rounding internal constant UP = Math.Rounding.Ceil;\n    Math.Rounding internal constant DOWN = Math.Rounding.Floor;\n    Math.Rounding internal constant DEBT_TO_ASSETS = Math.Rounding.Ceil;\n    // COLLATERAL_TO_ASSETS is used to calculate borrower collateral (so we want to round down)\n    Math.Rounding internal constant COLLATERAL_TO_ASSETS = Math.Rounding.Floor;\n    // why DEPOSIT_TO_ASSETS is Up if COLLATERAL_TO_ASSETS is Down?\n    // DEPOSIT_TO_ASSETS is used for preview deposit and deposit, based on provided shares we want to pull \"more\" tokens\n    // so we rounding up, \"token flow\" is in different direction than for COLLATERAL_TO_ASSETS, that's why\n    // different rounding policy\n    Math.Rounding internal constant DEPOSIT_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant DEPOSIT_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant BORROW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant BORROW_TO_SHARES = Math.Rounding.Ceil;\n    Math.Rounding internal constant MAX_BORROW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_BORROW_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_BORROW_VALUE = Math.Rounding.Floor;\n    Math.Rounding internal constant REPAY_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant REPAY_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_REPAY_TO_ASSETS = Math.Rounding.Ceil;\n    Math.Rounding internal constant WITHDRAW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant WITHDRAW_TO_SHARES = Math.Rounding.Ceil;\n    Math.Rounding internal constant MAX_WITHDRAW_TO_ASSETS = Math.Rounding.Floor;\n    Math.Rounding internal constant MAX_WITHDRAW_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant LIQUIDATE_TO_SHARES = Math.Rounding.Floor;\n    Math.Rounding internal constant LTV = Math.Rounding.Ceil;\n    Math.Rounding internal constant ACCRUED_INTEREST = Math.Rounding.Floor;\n    Math.Rounding internal constant DAO_REVENUE = Math.Rounding.Ceil;\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "silo-core/contracts/lib/SiloMathLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n// solhint-disable ordering\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\nimport {Rounding} from \"../lib/Rounding.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\n\nlibrary SiloMathLib {\n    using Math for uint256;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    uint256 internal constant _DECIMALS_OFFSET = 3;\n\n    /// @dev this is constant version of openzeppelin5/contracts/token/ERC20/extensions/ERC4626._decimalsOffset\n    uint256 internal constant _DECIMALS_OFFSET_POW = 10 ** _DECIMALS_OFFSET;\n\n    /// @notice Returns available liquidity to be borrowed\n    /// @dev Accrued interest is entirely added to `debtAssets` but only part of it is added to `collateralAssets`. The\n    ///      difference is DAO's and deployer's cut. That means DAO's and deployer's cut is not considered a borrowable\n    ///      liquidity.\n    function liquidity(uint256 _collateralAssets, uint256 _debtAssets) internal pure returns (uint256 liquidAssets) {\n        unchecked {\n            // we checked the underflow\n            liquidAssets = _debtAssets > _collateralAssets ? 0 : _collateralAssets - _debtAssets;\n        }\n    }\n\n    /// @notice Calculate collateral assets with accrued interest and associated fees\n    /// @param _collateralAssets The total amount of collateral assets\n    /// @param _debtAssets The total amount of debt assets\n    /// @param _rcomp Compound interest rate for debt\n    /// @param _daoFee The fee (in 18 decimals points) to be taken for the DAO\n    /// @param _deployerFee The fee (in 18 decimals points) to be taken for the deployer\n    /// @return collateralAssetsWithInterest The total collateral assets including the accrued interest\n    /// @return debtAssetsWithInterest The debt assets with accrued interest\n    /// @return daoAndDeployerRevenue Total fees amount to be split between DAO and deployer\n    /// @return accruedInterest The total accrued interest\n    function getCollateralAmountsWithInterest(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _rcomp,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    )\n        internal\n        pure\n        returns (\n            uint256 collateralAssetsWithInterest,\n            uint256 debtAssetsWithInterest,\n            uint256 daoAndDeployerRevenue,\n            uint256 accruedInterest\n        )\n    {\n        (debtAssetsWithInterest, accruedInterest) = getDebtAmountsWithInterest(_debtAssets, _rcomp);\n\n        uint256 fees;\n\n        // _daoFee and _deployerFee are expected to be less than 1e18, so we will not overflow\n        unchecked { fees = _daoFee + _deployerFee; }\n\n        daoAndDeployerRevenue = mulDivOverflow(accruedInterest, fees, _PRECISION_DECIMALS);\n\n        // we will not underflow because daoAndDeployerRevenue is chunk of accruedInterest\n        uint256 collateralInterest = accruedInterest - daoAndDeployerRevenue;\n\n        uint256 cap;\n        // save to uncheck because variable can not be more than max\n        unchecked { cap = type(uint256).max - _collateralAssets; }\n\n        if (cap < collateralInterest) {\n            // avoid overflow on interest\n            collateralInterest = cap;\n        }\n\n        // safe to uncheck because of cap\n        unchecked {  collateralAssetsWithInterest = _collateralAssets + collateralInterest; }\n    }\n\n    /// @notice Calculate the debt assets with accrued interest, it should never revert with over/under flow\n    /// @param _totalDebtAssets The total amount of debt assets before accrued interest\n    /// @param _rcomp Compound interest rate for the debt in 18 decimal precision\n    /// @return debtAssetsWithInterest The debt assets including the accrued interest\n    /// @return accruedInterest The total amount of interest accrued on the debt assets\n    function getDebtAmountsWithInterest(uint256 _totalDebtAssets, uint256 _rcomp)\n        internal\n        pure\n        returns (uint256 debtAssetsWithInterest, uint256 accruedInterest)\n    {\n        if (_totalDebtAssets == 0 || _rcomp == 0) {\n            return (_totalDebtAssets, 0);\n        }\n\n        accruedInterest = mulDivOverflow(_totalDebtAssets, _rcomp, _PRECISION_DECIMALS);\n\n        unchecked {\n            // We intentionally allow overflow here, to prevent transaction revert due to interest calculation.\n            debtAssetsWithInterest = _totalDebtAssets + accruedInterest;\n\n            // If overflow occurs, we skip accruing interest.\n            if (debtAssetsWithInterest < _totalDebtAssets) {\n                debtAssetsWithInterest = _totalDebtAssets;\n                accruedInterest = 0;\n            }\n        }\n    }\n\n    /// @notice Calculates fraction between borrowed and deposited amount of tokens denominated in percentage\n    /// @dev It assumes `_dp` = 100%.\n    /// @param _dp decimal points used by model\n    /// @param _collateralAssets current total deposits for assets\n    /// @param _debtAssets current total borrows for assets\n    /// @return utilization value, capped to 100%\n    /// Limiting utilization ratio by 100% max will allows us to perform better interest rate computations\n    /// and should not affect any other part of protocol. It is possible to go over 100% only when bad debt.\n    function calculateUtilization(uint256 _dp, uint256 _collateralAssets, uint256 _debtAssets)\n        internal\n        pure\n        returns (uint256 utilization)\n    {\n        if (_collateralAssets == 0 || _debtAssets == 0 || _dp == 0) return 0;\n\n        /*\n            how to prevent overflow on: _debtAssets.mulDiv(_dp, _collateralAssets, Rounding.ACCRUED_INTEREST):\n            1. max > _debtAssets * _dp / _collateralAssets\n            2. max / _dp > _debtAssets / _collateralAssets\n        */\n        if (type(uint256).max / _dp > _debtAssets / _collateralAssets) {\n            utilization = _debtAssets.mulDiv(_dp, _collateralAssets, Rounding.ACCRUED_INTEREST);\n            // cap at 100%\n            if (utilization > _dp) utilization = _dp;\n        } else {\n            // we have overflow\n            utilization = _dp;\n        }\n    }\n\n    function convertToAssetsOrToShares(\n        uint256 _assets,\n        uint256 _shares,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _roundingToAssets,\n        Math.Rounding _roundingToShares,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 assets, uint256 shares) {\n        if (_assets == 0) {\n            require(_shares != 0, ISilo.InputZeroShares());\n            shares = _shares;\n            assets = convertToAssets(_shares, _totalAssets, _totalShares, _roundingToAssets, _assetType);\n            require(assets != 0, ISilo.ReturnZeroAssets());\n        } else if (_shares == 0) {\n            shares = convertToShares(_assets, _totalAssets, _totalShares, _roundingToShares, _assetType);\n            assets = _assets;\n            require(shares != 0, ISilo.ReturnZeroShares());\n        } else {\n            revert ISilo.InputCanBeAssetsOrShares();\n        }\n    }\n\n    /// @dev Math for collateral is exact copy of\n    ///      openzeppelin5/contracts/token/ERC20/extensions/ERC4626._convertToShares\n    function convertToShares(\n        uint256 _assets,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _rounding,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 shares) {\n        (uint256 totalShares, uint256 totalAssets) = _commonConvertTo(_totalAssets, _totalShares, _assetType);\n\n        // initially, in case of debt, if silo is empty we return shares==assets\n        // for collateral, this will never be the case, because we are adding `+1` and offset in `_commonConvertTo`\n        if (totalShares == 0) return _assets;\n\n        shares = _assets.mulDiv(totalShares, totalAssets, _rounding);\n    }\n\n    /// @dev Math for collateral is exact copy of\n    ///      openzeppelin5/contracts/token/ERC20/extensions/ERC4626._convertToAssets\n    function convertToAssets(\n        uint256 _shares,\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        Math.Rounding _rounding,\n        ISilo.AssetType _assetType\n    ) internal pure returns (uint256 assets) {\n        (uint256 totalShares, uint256 totalAssets) = _commonConvertTo(_totalAssets, _totalShares, _assetType);\n\n        // initially, in case of debt, if silo is empty we return shares==assets\n        // for collateral, this will never be the case, because of `+1` in line above\n        if (totalShares == 0) return _shares;\n\n        assets = _shares.mulDiv(totalAssets, totalShares, _rounding);\n    }\n\n    /// @param _collateralMaxLtv maxLTV in 18 decimals that is set for debt asset\n    /// @param _sumOfBorrowerCollateralValue borrower total collateral value (including protected)\n    /// @param _borrowerDebtValue total value of borrower debt\n    /// @return maxBorrowValue max borrow value yet available for borrower\n    function calculateMaxBorrowValue(\n        uint256 _collateralMaxLtv,\n        uint256 _sumOfBorrowerCollateralValue,\n        uint256 _borrowerDebtValue\n    ) internal pure returns (uint256 maxBorrowValue) {\n        if (_sumOfBorrowerCollateralValue == 0) {\n            return 0;\n        }\n\n        uint256 maxDebtValue = _sumOfBorrowerCollateralValue.mulDiv(\n            _collateralMaxLtv, _PRECISION_DECIMALS, Rounding.MAX_BORROW_VALUE\n        );\n\n        unchecked {\n            // we will not underflow because we checking `maxDebtValue > _borrowerDebtValue`\n            maxBorrowValue = maxDebtValue > _borrowerDebtValue ? maxDebtValue - _borrowerDebtValue : 0;\n        }\n    }\n\n    /// @notice Calculate the maximum assets a borrower can withdraw without breaching the liquidation threshold\n    /// @param _sumOfCollateralsValue The combined value of collateral and protected assets of the borrower\n    /// @param _debtValue The total debt value of the borrower\n    /// @param _lt The liquidation threshold in 18 decimal points\n    /// @param _borrowerCollateralAssets The borrower's collateral assets before the withdrawal\n    /// @param _borrowerProtectedAssets The borrower's protected assets before the withdrawal\n    /// @return maxAssets The maximum assets the borrower can safely withdraw\n    function calculateMaxAssetsToWithdraw(\n        uint256 _sumOfCollateralsValue,\n        uint256 _debtValue,\n        uint256 _lt,\n        uint256 _borrowerCollateralAssets,\n        uint256 _borrowerProtectedAssets\n    ) internal pure returns (uint256 maxAssets) {\n        if (_sumOfCollateralsValue == 0) return 0;\n        if (_debtValue == 0) return _sumOfCollateralsValue;\n        if (_lt == 0) return 0;\n\n        // using Rounding.LT (up) to have highest collateralValue that we have to leave for user to stay solvent\n        uint256 minimumCollateralValue = _debtValue.mulDiv(_PRECISION_DECIMALS, _lt, Rounding.LTV);\n\n        // if we over LT, we can not withdraw\n        if (_sumOfCollateralsValue <= minimumCollateralValue) {\n            return 0;\n        }\n\n        uint256 spareCollateralValue;\n        // safe because we checked `if (_sumOfCollateralsValue <= minimumCollateralValue)`\n        unchecked { spareCollateralValue = _sumOfCollateralsValue - minimumCollateralValue; }\n\n        maxAssets = (_borrowerProtectedAssets + _borrowerCollateralAssets)\n                .mulDiv(spareCollateralValue, _sumOfCollateralsValue, Rounding.MAX_WITHDRAW_TO_ASSETS);\n    }\n\n    /// @notice Determines the maximum number of assets and corresponding shares a borrower can safely withdraw\n    /// @param _maxAssets The calculated limit on how many assets can be withdrawn without breaching the liquidation\n    /// threshold\n    /// @param _borrowerCollateralAssets Amount of collateral assets currently held by the borrower\n    /// @param _borrowerProtectedAssets Amount of protected assets currently held by the borrower\n    /// @param _collateralType Specifies whether the asset is of type Collateral or Protected\n    /// @param _totalAssets The entire quantity of assets available in the system for withdrawal\n    /// @param _assetTypeShareTokenTotalSupply Total supply of share tokens for the specified asset type\n    /// @param _liquidity Current liquidity in the system for the asset type\n    /// @return assets Maximum assets the borrower can withdraw\n    /// @return shares Corresponding number of shares for the derived `assets` amount\n    function maxWithdrawToAssetsAndShares(\n        uint256 _maxAssets,\n        uint256 _borrowerCollateralAssets,\n        uint256 _borrowerProtectedAssets,\n        ISilo.CollateralType _collateralType,\n        uint256 _totalAssets,\n        uint256 _assetTypeShareTokenTotalSupply,\n        uint256 _liquidity\n    ) internal pure returns (uint256 assets, uint256 shares) {\n        if (_maxAssets == 0) return (0, 0);\n        if (_assetTypeShareTokenTotalSupply == 0) return (0, 0);\n\n        if (_collateralType == ISilo.CollateralType.Collateral) {\n            assets = _maxAssets > _borrowerCollateralAssets ? _borrowerCollateralAssets : _maxAssets;\n\n            if (assets > _liquidity) {\n                assets = _liquidity;\n            }\n        } else {\n            assets = _maxAssets > _borrowerProtectedAssets ? _borrowerProtectedAssets : _maxAssets;\n        }\n\n        shares = SiloMathLib.convertToShares(\n            assets,\n            _totalAssets,\n            _assetTypeShareTokenTotalSupply,\n            Rounding.MAX_WITHDRAW_TO_SHARES,\n            ISilo.AssetType(uint256(_collateralType))\n        );\n    }\n\n    /// @dev executed `_a * _b / _c`, reverts on _c == 0\n    /// @return mulDivResult on overflow returns 0\n    function mulDivOverflow(uint256 _a, uint256 _b, uint256 _c)\n        internal\n        pure\n        returns (uint256 mulDivResult)\n    {\n        if (_a == 0) return (0);\n\n        unchecked {\n            // we have to uncheck to detect overflow\n            mulDivResult = _a * _b;\n            if (mulDivResult / _a != _b) return 0;\n\n            mulDivResult /= _c;\n        }\n    }\n\n    /// @dev Debt calculations should not lower the result. Debt is a liability so protocol should not take any for\n    /// itself. It should return actual result and round it up.\n    function _commonConvertTo(\n        uint256 _totalAssets,\n        uint256 _totalShares,\n        ISilo.AssetType _assetType\n    ) private pure returns (uint256 totalShares, uint256 totalAssets) {\n        if (_totalShares == 0) {\n            // silo is empty and we have dust to redistribute: this can only happen when everyone exits silo\n            // this case can happen only for collateral, because for collateral we rounding in favorite of protocol\n            // by resetting totalAssets, the dust that we have will go to first depositor and we starts from clean state\n            _totalAssets = 0;\n        }\n\n            (totalShares, totalAssets) = _assetType == ISilo.AssetType.Debt\n                ? (_totalShares, _totalAssets)\n                : (_totalShares + _DECIMALS_OFFSET_POW, _totalAssets + 1);\n    }\n\n    /// @dev Calculates the fraction of a given total and percentage\n    /// @param _total The total value to calculate the fraction from\n    /// @param _percent The percentage to calculate the fraction from\n    /// @param _currentFraction The current fraction to add to the result\n    /// @return integral The integral part of the fraction\n    /// @return fraction The fractional part of the fraction\n    function calculateFraction(\n        uint256 _total,\n        uint256 _percent,\n        uint64 _currentFraction\n    ) internal pure returns (uint256 integral, uint64 fraction) {\n        if (_total == 0) {\n            return (0, _currentFraction);\n        }\n\n        unchecked {\n            // safe to unchecked because: _currentFraction if never more than max uint256, div is safe\n            if (type(uint256).max / _total < _percent) {\n                // when overflow, reset `_currentFraction ` to zero as part of circuit breaker\n                return (0, 0);\n            }\n\n            // `_total * _percent` safe to unchecked because we checked for overflow in above `if`\n            // `% _PRECISION_DECIMALS` safe, because max value after modulo will be 1e18 - 1  (_PRECISION_DECIMALS - 1)\n            // and this is less than 2 ** 64\n            // calculate remainder for current interest\n            uint256 remainder = (_total * _percent) % _PRECISION_DECIMALS;\n            // integral is amount above 1e18 after adding _currentFraction and remainder\n            integral = (_currentFraction + remainder) / _PRECISION_DECIMALS;\n            // fraction is what we get below 1e18\n            fraction = uint64((_currentFraction + remainder) % _PRECISION_DECIMALS);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/RevertLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nlibrary RevertLib {\n    function revertBytes(bytes memory _errMsg, string memory _customErr) internal pure {\n        if (_errMsg.length > 0) {\n            assembly { // solhint-disable-line no-inline-assembly\n                revert(add(32, _errMsg), mload(_errMsg))\n            }\n        }\n\n        revert(_customErr);\n    }\n\n    function revertBytes(bytes memory _errMsg, bytes4 _customErrSelector) internal pure {\n        if (_errMsg.length > 0) {\n            assembly { // solhint-disable-line no-inline-assembly\n                revert(add(32, _errMsg), mload(_errMsg))\n            }\n        }\n\n        revertWithCustomError(_customErrSelector);\n    }\n\n    function revertIfError(bytes4 _errorSelector) internal pure {\n        if (_errorSelector == 0) return;\n\n        revertWithCustomError(_errorSelector);\n    }\n\n    function revertWithCustomError(bytes4 _errorSelector) internal pure {\n        bytes memory customError = abi.encodeWithSelector(_errorSelector);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            revert(add(32, customError), mload(customError))\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/CallBeforeQuoteLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\n\nlibrary CallBeforeQuoteLib {\n    /// @dev Call `beforeQuote` on the `solvencyOracle` oracle\n    /// @param _config Silo config data\n    function callSolvencyOracleBeforeQuote(ISiloConfig.ConfigData memory _config) internal {\n        if (_config.callBeforeQuote && _config.solvencyOracle != address(0)) {\n            ISiloOracle(_config.solvencyOracle).beforeQuote(_config.token);\n        }\n    }\n\n    /// @dev Call `beforeQuote` on the `maxLtvOracle` oracle\n    /// @param _config Silo config data\n    function callMaxLtvOracleBeforeQuote(ISiloConfig.ConfigData memory _config) internal {\n        if (_config.callBeforeQuote && _config.maxLtvOracle != address(0)) {\n            ISiloOracle(_config.maxLtvOracle).beforeQuote(_config.token);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/hooks/liquidation/lib/PartialLiquidationExecLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\nimport {ISiloConfig} from \"silo-core/contracts/interfaces/ISiloConfig.sol\";\nimport {IPartialLiquidation} from \"silo-core/contracts/interfaces/IPartialLiquidation.sol\";\nimport {SiloSolvencyLib} from \"silo-core/contracts/lib/SiloSolvencyLib.sol\";\nimport {PartialLiquidationLib} from \"./PartialLiquidationLib.sol\";\n\nlibrary PartialLiquidationExecLib {\n    /// @dev it will be user responsibility to check profit, this method expect interest to be already accrued\n    function getExactLiquidationAmounts(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _user,\n        uint256 _maxDebtToCover,\n        uint256 _liquidationFee\n    )\n        external\n        view\n        returns (\n            uint256 withdrawAssetsFromCollateral,\n            uint256 withdrawAssetsFromProtected,\n            uint256 repayDebtAssets,\n            bytes4 customError\n        )\n    {\n        SiloSolvencyLib.LtvData memory ltvData = SiloSolvencyLib.getAssetsDataForLtvCalculations({\n            _collateralConfig: _collateralConfig,\n            _debtConfig: _debtConfig,\n            _borrower: _user,\n            _oracleType: ISilo.OracleType.Solvency,\n            _accrueInMemory: ISilo.AccrueInterestInMemory.No,\n            _debtShareBalanceCached:0 /* no cached balance */\n        });\n\n        uint256 borrowerCollateralToLiquidate;\n\n        (\n            borrowerCollateralToLiquidate, repayDebtAssets, customError\n        ) = liquidationPreview(\n            ltvData,\n            PartialLiquidationLib.LiquidationPreviewParams({\n                collateralLt: _collateralConfig.lt,\n                collateralConfigAsset: _collateralConfig.token,\n                debtConfigAsset: _debtConfig.token,\n                maxDebtToCover: _maxDebtToCover,\n                liquidationTargetLtv: _collateralConfig.liquidationTargetLtv,\n                liquidationFee: _liquidationFee\n            })\n        );\n\n        (\n            withdrawAssetsFromCollateral, withdrawAssetsFromProtected\n        ) = PartialLiquidationLib.splitReceiveCollateralToLiquidate(\n            borrowerCollateralToLiquidate, ltvData.borrowerProtectedAssets\n        );\n    }\n\n    /// @dev debt keeps growing over time, so when dApp use this view to calculate max, tx should never revert\n    /// because actual max can be only higher\n    // solhint-disable-next-line function-max-lines\n    function maxLiquidation(ISiloConfig _siloConfig, address _borrower)\n        external\n        view\n        returns (uint256 collateralToLiquidate, uint256 debtToRepay, bool sTokenRequired)\n    {\n        (\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        ) = _siloConfig.getConfigsForSolvency(_borrower);\n\n        if (debtConfig.silo == address(0)) {\n            return (0, 0, false);\n        }\n\n        SiloSolvencyLib.LtvData memory ltvData = SiloSolvencyLib.getAssetsDataForLtvCalculations(\n            collateralConfig,\n            debtConfig,\n            _borrower,\n            ISilo.OracleType.Solvency,\n            ISilo.AccrueInterestInMemory.Yes,\n            0 /* no cached balance */\n        );\n\n        if (ltvData.borrowerDebtAssets == 0) return (0, 0, false);\n\n        (\n            uint256 sumOfCollateralValue, uint256 debtValue\n        ) = SiloSolvencyLib.getPositionValues(ltvData, collateralConfig.token, debtConfig.token);\n\n        uint256 sumOfCollateralAssets = ltvData.borrowerProtectedAssets + ltvData.borrowerCollateralAssets;\n\n        if (sumOfCollateralValue == 0) return (sumOfCollateralAssets, ltvData.borrowerDebtAssets, false);\n\n        uint256 ltvInDp = SiloSolvencyLib.ltvMath(debtValue, sumOfCollateralValue);\n        if (ltvInDp <= collateralConfig.lt) return (0, 0, false); // user solvent\n\n        (collateralToLiquidate, debtToRepay) = PartialLiquidationLib.maxLiquidation(\n            sumOfCollateralAssets,\n            sumOfCollateralValue,\n            ltvData.borrowerDebtAssets,\n            debtValue,\n            collateralConfig.liquidationTargetLtv,\n            collateralConfig.liquidationFee\n        );\n\n        // maxLiquidation() can underestimate collateral by `PartialLiquidationLib._UNDERESTIMATION`,\n        // when we do that, actual collateral that we will transfer will match exactly liquidity,\n        // but we will liquidate higher value by 1 or 2, then sTokenRequired will return false,\n        // but we can not withdraw (because we will be short by 2) solution is to include this 2wei here\n        unchecked {\n            // safe to uncheck, because we underestimated this value in a first place by _UNDERESTIMATION\n            uint256 overestimatedCollateral = collateralToLiquidate + PartialLiquidationLib._UNDERESTIMATION;\n            sTokenRequired = overestimatedCollateral > ISilo(collateralConfig.silo).getLiquidity();\n        }\n    }\n\n    /// @return receiveCollateralAssets collateral + protected to liquidate, on self liquidation when borrower repay\n    /// all debt, he will receive all collateral back\n    /// @return repayDebtAssets\n    function liquidationPreview( // solhint-disable-line function-max-lines, code-complexity\n        SiloSolvencyLib.LtvData memory _ltvData,\n        PartialLiquidationLib.LiquidationPreviewParams memory _params\n    )\n        internal\n        view\n        returns (uint256 receiveCollateralAssets, uint256 repayDebtAssets, bytes4 customError)\n    {\n        uint256 sumOfCollateralAssets = _ltvData.borrowerCollateralAssets + _ltvData.borrowerProtectedAssets;\n\n        if (_ltvData.borrowerDebtAssets == 0 || _params.maxDebtToCover == 0) {\n            return (0, 0, IPartialLiquidation.NoDebtToCover.selector);\n        }\n\n        if (sumOfCollateralAssets == 0) {\n            return (\n                0,\n                _params.maxDebtToCover > _ltvData.borrowerDebtAssets\n                    ? _ltvData.borrowerDebtAssets\n                    : _params.maxDebtToCover,\n                bytes4(0) // no error\n            );\n        }\n\n        (\n            uint256 sumOfBorrowerCollateralValue, uint256 totalBorrowerDebtValue, uint256 ltvBefore\n        ) = SiloSolvencyLib.calculateLtv(_ltvData, _params.collateralConfigAsset, _params.debtConfigAsset);\n\n        if (_params.collateralLt >= ltvBefore) return (0, 0, IPartialLiquidation.UserIsSolvent.selector);\n\n        uint256 ltvAfter;\n\n        (receiveCollateralAssets, repayDebtAssets, ltvAfter) = PartialLiquidationLib.liquidationPreview(\n            ltvBefore,\n            sumOfCollateralAssets,\n            sumOfBorrowerCollateralValue,\n            _ltvData.borrowerDebtAssets,\n            totalBorrowerDebtValue,\n            _params\n        );\n\n        if (receiveCollateralAssets == 0 || repayDebtAssets == 0) {\n            return (0, 0, IPartialLiquidation.NoRepayAssets.selector);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/hooks/_common/TransientReentrancy.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nabstract contract TransientReentrancy {\n    error ReentrancyGuardReentrantCall();\n\n    bool private transient _lock;\n\n    modifier nonReentrant() {\n        require(!_lock, ReentrancyGuardReentrantCall());\n\n        _lock = true;\n        _;\n        _lock = false;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"ON\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function reentrancyGuardEntered() internal view returns (bool) {\n        return _lock;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return a == 0 ? 0 : (a - 1) / b + 1;\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2 and mod 2 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.UNDER_OVERFLOW);\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such\n            // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv  1 mod 2.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is\n            // less than 2, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, expect 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Ferma's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax  1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return x < 0 ? (n - uint256(-x)) : uint256(x); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked has failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).\n            // This is going to be our x_0 (and _0)\n            xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1} - a = ((x_n + a / x_n) / 2) - a\n            //              = ((x_n + a) / (2 * x_n)) - a\n            //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a\n            //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)\n            //              = (x_n - 2 * a * x_n + a) / (4 * x_n)\n            //              = (x_n - a) / (2 * x_n)\n            //              = ((x_n - a) / (2 * x_n))\n            //               0\n            // Which proves that for all n  1, sqrt(a)  x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // _{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a)) / (2 * x_n) |\n            //         = | _n / (2 * x_n) |\n            //         = _n / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // _1 = _0 / | (2 * x_0) |\n            //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))\n            //      2**(2*e-4) / (3 * 2**(e-1))\n            //      2**(e-3) / 3\n            //      2**(e-3-log2(3))\n            //      2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:\n            // _{n+1} = _n / | (2 * x_n) |\n            //          (2**(e-k)) / (2 * 2**(e-1))\n            //          2**(2*e-2*k) / 2**e\n            //          2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72\n\n            // Because e  128 (as discussed during the first estimation phase), we know have reached a precision\n            // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "silo-core/contracts/hooks/defaulting/DefaultingRepayLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.28;\n\nimport {ISilo} from \"silo-core/contracts/interfaces/ISilo.sol\";\n\nimport {SiloStorageLib} from \"silo-core/contracts/lib/SiloStorageLib.sol\";\nimport {IShareToken} from \"silo-core/contracts/interfaces/IShareToken.sol\";\nimport {ISiloConfig} from \"silo-core/contracts/interfaces/ISiloConfig.sol\";\nimport {Rounding} from \"silo-core/contracts/lib/Rounding.sol\";\nimport {SiloMathLib} from \"silo-core/contracts/lib/SiloMathLib.sol\";\nimport {ShareTokenLib} from \"silo-core/contracts/lib/ShareTokenLib.sol\";\nimport {Hook} from \"silo-core/contracts/lib/Hook.sol\";\nimport {IHookReceiver} from \"silo-core/contracts/interfaces/IHookReceiver.sol\";\n\n/// @title PartialLiquidationByDefaultingLogic\n/// @dev implements custom delegate call logic for Silo\nlibrary DefaultingRepayLib {\n    using Hook for uint256;\n    using Hook for uint24;\n\n    /// @notice Repays a given asset amount and returns the equivalent number of shares\n    /// @dev This is a copy of lib/Actions.sol repay() function with a single line changed.\n    /// siloLendingLibRepay(), line 48, is used instead of SiloLendingLib.repay().\n    /// @param _assets Amount of assets to be repaid\n    /// @param _borrower Address of the borrower whose debt is being repaid\n    /// @param _repayer Address of the repayer who repay debt\n    /// @return assets number of assets that had been repay\n    /// @return shares number of shares that had been repay\n    // solhint-disable-next-line function-max-lines\n    function actionsRepay(uint256 _assets, uint256 _shares, address _borrower, address _repayer)\n        external\n        returns (uint256 assets, uint256 shares)\n    {\n        IShareToken.ShareTokenStorage storage _shareStorage = ShareTokenLib.getShareTokenStorage();\n\n        if (_shareStorage.hookSetup.hooksBefore.matchAction(Hook.REPAY)) {\n            bytes memory data = abi.encodePacked(_assets, _shares, _borrower, _repayer);\n            IHookReceiver(_shareStorage.hookSetup.hookReceiver).beforeAction(address(this), Hook.REPAY, data);\n        }\n\n        ISiloConfig siloConfig = _shareStorage.siloConfig;\n\n        siloConfig.turnOnReentrancyProtection();\n        siloConfig.accrueInterestForSilo(address(this));\n\n        (address debtShareToken, address debtAsset) = siloConfig.getDebtShareTokenAndAsset(address(this));\n\n        (assets, shares) = siloLendingLibRepay(\n            IShareToken(debtShareToken), debtAsset, _assets, _shares, _borrower, _repayer\n        );\n\n        siloConfig.turnOffReentrancyProtection();\n\n        if (_shareStorage.hookSetup.hooksAfter.matchAction(Hook.REPAY)) {\n            bytes memory data = abi.encodePacked(_assets, _shares, _borrower, _repayer, assets, shares);\n            IHookReceiver(_shareStorage.hookSetup.hookReceiver).afterAction(address(this), Hook.REPAY, data);\n        }\n    }\n\n    /// @dev This is a copy of lib/SiloLendingLib.sol repay() function with a single line changed.\n    /// In the last line _debtAsset transfer from repayer is removed.\n    function siloLendingLibRepay(\n        IShareToken _debtShareToken,\n        address, /* _debtAsset */\n        uint256 _assets,\n        uint256 _shares,\n        address _borrower,\n        address _repayer\n    ) internal returns (uint256 assets, uint256 shares) {\n        ISilo.SiloStorage storage $ = SiloStorageLib.getSiloStorage();\n\n        uint256 totalDebtAssets = $.totalAssets[ISilo.AssetType.Debt];\n        (uint256 debtSharesBalance, uint256 totalDebtShares) = _debtShareToken.balanceOfAndTotalSupply(_borrower);\n\n        (assets, shares) = SiloMathLib.convertToAssetsOrToShares({\n            _assets: _assets,\n            _shares: _shares,\n            _totalAssets: totalDebtAssets,\n            _totalShares: totalDebtShares,\n            _roundingToAssets: Rounding.REPAY_TO_ASSETS,\n            _roundingToShares: Rounding.REPAY_TO_SHARES,\n            _assetType: ISilo.AssetType.Debt\n        });\n\n        if (shares > debtSharesBalance) {\n            shares = debtSharesBalance;\n\n            (assets, shares) = SiloMathLib.convertToAssetsOrToShares({\n                _assets: 0,\n                _shares: shares,\n                _totalAssets: totalDebtAssets,\n                _totalShares: totalDebtShares,\n                _roundingToAssets: Rounding.REPAY_TO_ASSETS,\n                _roundingToShares: Rounding.REPAY_TO_SHARES,\n                _assetType: ISilo.AssetType.Debt\n            });\n        }\n\n        require(totalDebtAssets >= assets, ISilo.RepayTooHigh());\n\n        // subtract repayment from debt, save to unchecked because of above `totalDebtAssets < assets`\n        unchecked { $.totalAssets[ISilo.AssetType.Debt] = totalDebtAssets - assets; }\n\n        // Anyone can repay anyone's debt so no approval check is needed.\n        _debtShareToken.burn(_borrower, _repayer, shares);\n\n        // _debtAsset transfer from repayer removed.\n        // This is the only change in the function in comparison to lib/SiloLendingLib.sol repay() function.\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/extensions/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControlEnumerable} from \"./IAccessControlEnumerable.sol\";\nimport {AccessControl} from \"../AccessControl.sol\";\nimport {EnumerableSet} from \"../../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 role => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Return all accounts that have `role`\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function getRoleMembers(bytes32 role) public view virtual returns (address[] memory) {\n        return _roleMembers[role].values();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            _roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            _roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ISiloOracle {\n    /// @notice Hook function to call before `quote` function reads price\n    /// @dev This hook function can be used to change state right before the price is read. For example it can be used\n    ///      for curve read only reentrancy protection. In majority of implementations this will be an empty function.\n    ///      WARNING: reverts are propagated to Silo so if `beforeQuote` reverts, Silo reverts as well.\n    /// @param _baseToken Address of priced token\n    function beforeQuote(address _baseToken) external;\n\n    /// @return quoteAmount Returns quote price for _baseAmount of _baseToken\n    /// @param _baseAmount Amount of priced token\n    /// @param _baseToken Address of priced token\n    function quote(uint256 _baseAmount, address _baseToken) external view returns (uint256 quoteAmount);\n\n    /// @return address of token in which quote (price) is denominated\n    function quoteToken() external view returns (address);\n}\n"
    },
    "silo-core/contracts/lib/SiloSolvencyLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Math} from \"openzeppelin5/utils/math/Math.sol\";\n\nimport {ISiloOracle} from \"../interfaces/ISiloOracle.sol\";\nimport {SiloStdLib, ISiloConfig, IShareToken, ISilo} from \"./SiloStdLib.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\nimport {Rounding} from \"./Rounding.sol\";\n\nlibrary SiloSolvencyLib {\n    using Math for uint256;\n\n    struct LtvData {\n        ISiloOracle collateralOracle;\n        ISiloOracle debtOracle;\n        uint256 borrowerProtectedAssets;\n        uint256 borrowerCollateralAssets;\n        uint256 borrowerDebtAssets;\n    }\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n    uint256 internal constant _INFINITY = type(uint256).max;\n\n    /// @notice Determines if a borrower is solvent based on the Loan-to-Value (LTV) ratio\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower to check solvency for\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return True if the borrower is solvent, false otherwise\n    function isSolvent(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.AccrueInterestInMemory _accrueInMemory\n    ) internal view returns (bool) {\n        if (_debtConfig.silo == address(0)) return true; // no debt, so solvent\n\n        uint256 ltv = getLtv(\n            _collateralConfig,\n            _debtConfig,\n            _borrower,\n            ISilo.OracleType.Solvency,\n            _accrueInMemory,\n            IShareToken(_debtConfig.debtShareToken).balanceOf(_borrower)\n        );\n\n        return ltv <= _collateralConfig.lt;\n    }\n\n    /// @notice Determines if a borrower's Loan-to-Value (LTV) ratio is below the maximum allowed LTV\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower to check against max LTV\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return True if the borrower's LTV is below the maximum, false otherwise\n    function isBelowMaxLtv(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.AccrueInterestInMemory _accrueInMemory\n    ) internal view returns (bool) {\n        uint256 debtShareBalance = IShareToken(_debtConfig.debtShareToken).balanceOf(_borrower);\n        if (debtShareBalance == 0) return true;\n\n        uint256 ltv = getLtv(\n            _collateralConfig,\n            _debtConfig,\n            _borrower,\n            ISilo.OracleType.MaxLtv,\n            _accrueInMemory,\n            debtShareBalance\n        );\n\n        return ltv <= _collateralConfig.maxLtv;\n    }\n\n    /// @notice Retrieves assets data required for LTV calculations\n    /// @param _collateralConfig Configuration data for the collateral\n    /// @param _debtConfig Configuration data for the debt\n    /// @param _borrower Address of the borrower whose LTV data is to be calculated\n    /// @param _oracleType Specifies whether to use the MaxLTV or Solvency oracle type for calculations\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @param _debtShareBalanceCached Cached value of debt share balance for the borrower. If debt shares of\n    /// `_borrower` is unknown, simply pass `0`.\n    /// @return ltvData Data structure containing necessary data to compute LTV\n    function getAssetsDataForLtvCalculations( // solhint-disable-line function-max-lines\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.OracleType _oracleType,\n        ISilo.AccrueInterestInMemory _accrueInMemory,\n        uint256 _debtShareBalanceCached\n    ) internal view returns (LtvData memory ltvData) {\n        if (_collateralConfig.token != _debtConfig.token) {\n            // When calculating maxLtv, use maxLtv oracle.\n            (ltvData.collateralOracle, ltvData.debtOracle) = _oracleType == ISilo.OracleType.MaxLtv\n                ? (ISiloOracle(_collateralConfig.maxLtvOracle), ISiloOracle(_debtConfig.maxLtvOracle))\n                : (ISiloOracle(_collateralConfig.solvencyOracle), ISiloOracle(_debtConfig.solvencyOracle));\n        }\n\n        uint256 totalShares;\n        uint256 shares;\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _collateralConfig.protectedShareToken, _borrower, 0 /* no cache */\n        );\n\n        (\n            uint256 totalCollateralAssets, uint256 totalProtectedAssets\n        ) = ISilo(_collateralConfig.silo).getCollateralAndProtectedTotalsStorage();\n\n        ltvData.borrowerProtectedAssets = SiloMathLib.convertToAssets(\n            shares, totalProtectedAssets, totalShares, Rounding.COLLATERAL_TO_ASSETS, ISilo.AssetType.Protected\n        );\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _collateralConfig.collateralShareToken, _borrower, 0 /* no cache */\n        );\n\n        totalCollateralAssets = _accrueInMemory == ISilo.AccrueInterestInMemory.Yes\n            ? SiloStdLib.getTotalCollateralAssetsWithInterest(\n                _collateralConfig.silo,\n                _collateralConfig.interestRateModel,\n                _collateralConfig.daoFee,\n                _collateralConfig.deployerFee\n            )\n            : totalCollateralAssets;\n\n        ltvData.borrowerCollateralAssets = SiloMathLib.convertToAssets(\n            shares, totalCollateralAssets, totalShares, Rounding.COLLATERAL_TO_ASSETS, ISilo.AssetType.Collateral\n        );\n\n        (shares, totalShares) = SiloStdLib.getSharesAndTotalSupply(\n            _debtConfig.debtShareToken, _borrower, _debtShareBalanceCached\n        );\n\n        uint256 totalDebtAssets = _accrueInMemory == ISilo.AccrueInterestInMemory.Yes\n            ? SiloStdLib.getTotalDebtAssetsWithInterest(_debtConfig.silo, _debtConfig.interestRateModel)\n            : ISilo(_debtConfig.silo).getTotalAssetsStorage(ISilo.AssetType.Debt);\n\n        // BORROW value -> to assets -> UP\n        ltvData.borrowerDebtAssets = SiloMathLib.convertToAssets(\n            shares, totalDebtAssets, totalShares, Rounding.DEBT_TO_ASSETS, ISilo.AssetType.Debt\n        );\n    }\n\n    /// @notice Calculates the Loan-To-Value (LTV) ratio for a given borrower\n    /// @param _collateralConfig Configuration data related to the collateral asset\n    /// @param _debtConfig Configuration data related to the debt asset\n    /// @param _borrower Address of the borrower whose LTV is to be computed\n    /// @param _oracleType Oracle type to use for fetching the asset prices\n    /// @param _accrueInMemory Determines whether or not to consider un-accrued interest in calculations\n    /// @return ltvInDp The computed LTV ratio in 18 decimals precision\n    function getLtv(\n        ISiloConfig.ConfigData memory _collateralConfig,\n        ISiloConfig.ConfigData memory _debtConfig,\n        address _borrower,\n        ISilo.OracleType _oracleType,\n        ISilo.AccrueInterestInMemory _accrueInMemory,\n        uint256 _debtShareBalance\n    ) internal view returns (uint256 ltvInDp) {\n        if (_debtShareBalance == 0) return 0;\n\n        LtvData memory ltvData = getAssetsDataForLtvCalculations(\n            _collateralConfig, _debtConfig, _borrower, _oracleType, _accrueInMemory, _debtShareBalance\n        );\n\n        if (ltvData.borrowerDebtAssets == 0) return 0;\n\n        (,, ltvInDp) = calculateLtv(ltvData, _collateralConfig.token, _debtConfig.token);\n    }\n\n    /// @notice Calculates the Loan-to-Value (LTV) ratio based on provided collateral and debt data\n    /// @dev calculation never reverts, if there is revert, then it is because of oracle\n    /// @param _ltvData Data structure containing relevant information to calculate LTV\n    /// @param _collateralToken Address of the collateral token\n    /// @param _debtAsset Address of the debt token\n    /// @return sumOfBorrowerCollateralValue Total value of borrower's collateral\n    /// @return totalBorrowerDebtValue Total debt value for the borrower\n    /// @return ltvInDp Calculated LTV in 18 decimal precision\n    function calculateLtv(\n        SiloSolvencyLib.LtvData memory _ltvData, address _collateralToken, address _debtAsset)\n        internal\n        view\n        returns (uint256 sumOfBorrowerCollateralValue, uint256 totalBorrowerDebtValue, uint256 ltvInDp)\n    {\n        (\n            sumOfBorrowerCollateralValue, totalBorrowerDebtValue\n        ) = getPositionValues(_ltvData, _collateralToken, _debtAsset);\n\n        if (sumOfBorrowerCollateralValue == 0 && totalBorrowerDebtValue == 0) {\n            return (0, 0, 0);\n        } else if (sumOfBorrowerCollateralValue == 0) {\n            ltvInDp = _INFINITY;\n        } else {\n            ltvInDp = ltvMath(totalBorrowerDebtValue, sumOfBorrowerCollateralValue);\n        }\n    }\n\n    /// @notice Computes the value of collateral and debt based on given LTV data and asset addresses\n    /// @param _ltvData Data structure containing the assets data required for LTV calculations\n    /// @param _collateralAsset Address of the collateral asset\n    /// @param _debtAsset Address of the debt asset\n    /// @return sumOfCollateralValue Total value of collateral assets considering both protected and regular collateral\n    /// assets\n    /// @return debtValue Total value of debt assets\n    function getPositionValues(LtvData memory _ltvData, address _collateralAsset, address _debtAsset)\n        internal\n        view\n        returns (uint256 sumOfCollateralValue, uint256 debtValue)\n    {\n        uint256 sumOfCollateralAssets;\n        \n        sumOfCollateralAssets = _ltvData.borrowerProtectedAssets + _ltvData.borrowerCollateralAssets;\n\n        if (sumOfCollateralAssets != 0) {\n            // if no oracle is set, assume price 1, we should also not set oracle for quote token\n            sumOfCollateralValue = address(_ltvData.collateralOracle) != address(0)\n                ? _ltvData.collateralOracle.quote(sumOfCollateralAssets, _collateralAsset)\n                : sumOfCollateralAssets;\n        }\n\n        if (_ltvData.borrowerDebtAssets != 0) {\n            // if no oracle is set, assume price 1, we should also not set oracle for quote token\n            debtValue = address(_ltvData.debtOracle) != address(0)\n                ? _ltvData.debtOracle.quote(_ltvData.borrowerDebtAssets, _debtAsset)\n                : _ltvData.borrowerDebtAssets;\n        }\n    }\n\n    function ltvMath(uint256 _totalBorrowerDebtValue, uint256 _sumOfBorrowerCollateralValue)\n        internal\n        pure\n        returns (uint256 ltvInDp)\n    {\n        ltvInDp = _totalBorrowerDebtValue.mulDiv(_PRECISION_DECIMALS, _sumOfBorrowerCollateralValue, Rounding.LTV);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/ShareTokenLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Strings} from \"openzeppelin5/utils/Strings.sol\";\n\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\n\nimport {TokenHelper} from \"../lib/TokenHelper.sol\";\nimport {CallBeforeQuoteLib} from \"../lib/CallBeforeQuoteLib.sol\";\nimport {Hook} from \"../lib/Hook.sol\";\n\n// solhint-disable ordering\n\nlibrary ShareTokenLib {\n    using Hook for uint24;\n    using CallBeforeQuoteLib for ISiloConfig.ConfigData;\n\n    // keccak256(abi.encode(uint256(keccak256(\"silo.storage.ShareToken\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant _STORAGE_LOCATION = 0x01b0b3f9d6e360167e522fa2b18ba597ad7b2b35841fec7e1ca4dbb0adea1200;\n\n    function getShareTokenStorage() internal pure returns (IShareToken.ShareTokenStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, private-vars-leading-underscore\n    function __ShareToken_init(ISilo _silo, address _hookReceiver, uint24 _tokenType) external {\n        IShareToken.ShareTokenStorage storage $ = ShareTokenLib.getShareTokenStorage();\n\n        $.silo = _silo;\n        $.siloConfig = _silo.config();\n\n        $.hookSetup.hookReceiver = _hookReceiver;\n        $.hookSetup.tokenType = _tokenType;\n        $.transferWithChecks = true;\n    }\n\n    /// @dev decimals of share token\n    function decimals() external view returns (uint8) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        return uint8(TokenHelper.assertAndGetDecimals(configData.token));\n    }\n\n    /// @dev Name convention:\n    ///      NAME - asset name\n    ///      SILO_ID - unique silo id\n    ///\n    ///      Protected deposit: \"Silo Finance Non-borrowable NAME Deposit, SiloId: SILO_ID\"\n    ///      Borrowable deposit: \"Silo Finance Borrowable NAME Deposit, SiloId: SILO_ID\"\n    ///      Debt: \"Silo Finance NAME Debt, SiloId: SILO_ID\"\n    function name() external view returns (string memory) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        string memory siloIdAscii = Strings.toString($.siloConfig.SILO_ID());\n\n        string memory pre = \"\";\n        string memory post = \" Deposit\";\n\n        if (address(this) == configData.protectedShareToken) {\n            pre = \"Non-borrowable \";\n        } else if (address(this) == configData.collateralShareToken) {\n            pre = \"Borrowable \";\n        } else if (address(this) == configData.debtShareToken) {\n            post = \" Debt\";\n        }\n\n        string memory tokenSymbol = TokenHelper.symbol(configData.token);\n        return string.concat(\"Silo Finance \", pre, tokenSymbol, post, \", SiloId: \", siloIdAscii);\n    }\n\n    /// @dev Symbol convention:\n    ///      SYMBOL - asset symbol\n    ///      SILO_ID - unique silo id\n    ///\n    ///      Protected deposit: \"nbSYMBOL-SILO_ID\"\n    ///      Borrowable deposit: \"bSYMBOL-SILO_ID\"\n    ///      Debt: \"dSYMBOL-SILO_ID\"\n    function symbol() external view returns (string memory) {\n        IShareToken.ShareTokenStorage storage $ = getShareTokenStorage();\n\n        ISiloConfig.ConfigData memory configData = $.siloConfig.getConfig(address($.silo));\n        string memory siloIdAscii = Strings.toString($.siloConfig.SILO_ID());\n\n        string memory pre;\n\n        if (address(this) == configData.protectedShareToken) {\n            pre = \"nb\";\n        } else if (address(this) == configData.collateralShareToken) {\n            pre = \"b\";\n        } else if (address(this) == configData.debtShareToken) {\n            pre = \"d\";\n        }\n\n        string memory tokenSymbol = TokenHelper.symbol(configData.token);\n        return string.concat(pre, tokenSymbol, \"-\", siloIdAscii);\n    }\n\n    /// @notice Call beforeQuote on solvency oracles\n    /// @param _user user address for which the solvent check is performed\n    function callOracleBeforeQuote(ISiloConfig _siloConfig, address _user) internal {\n        (\n            ISiloConfig.ConfigData memory collateralConfig,\n            ISiloConfig.ConfigData memory debtConfig\n        ) = _siloConfig.getConfigsForSolvency(_user);\n\n        collateralConfig.callSolvencyOracleBeforeQuote();\n        debtConfig.callSolvencyOracleBeforeQuote();\n    }\n\n    /// @dev Call on behalf of share token\n    /// @param _target target address to call\n    /// @param _value value to send\n    /// @param _callType call type\n    /// @param _input input data\n    /// @return success true if the call was successful, false otherwise\n    /// @return result bytes returned by the call\n    function callOnBehalfOfShareToken(address _target, uint256 _value, ISilo.CallType _callType, bytes calldata _input)\n        internal\n        returns (bool success, bytes memory result)\n    {\n        // Share token will not send back any ether leftovers after the call.\n        // The hook receiver should request the ether if needed in a separate call.\n        if (_callType == ISilo.CallType.Delegatecall) {\n            (success, result) = _target.delegatecall(_input); // solhint-disable-line avoid-low-level-calls\n        } else {\n            (success, result) = _target.call{value: _value}(_input); // solhint-disable-line avoid-low-level-calls\n        }\n    }\n\n    /// @dev checks if operation is \"real\" transfer\n    /// @param _sender sender address\n    /// @param _recipient recipient address\n    /// @return bool true if operation is real transfer, false if it is mint or burn\n    function isTransfer(address _sender, address _recipient) internal pure returns (bool) {\n        // in order this check to be true, it is required to have:\n        // require(sender != address(0), \"ERC20: transfer from the zero address\");\n        // require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        // on transfer. ERC20 has them, so we good.\n        return _sender != address(0) && _recipient != address(0);\n    }\n\n    function siloConfig() internal view returns (ISiloConfig thisSiloConfig) {\n        return ShareTokenLib.getShareTokenStorage().siloConfig;\n    }\n\n    function getConfig() internal view returns (ISiloConfig.ConfigData memory thisSiloConfigData) {\n        thisSiloConfigData = ShareTokenLib.getShareTokenStorage().siloConfig.getConfig(address(this));\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/extensions/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"../IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC-165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
    },
    "silo-core/contracts/lib/SiloStdLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {SafeERC20} from \"openzeppelin5/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin5/token/ERC20/IERC20.sol\";\n\nimport {ISiloConfig} from \"../interfaces/ISiloConfig.sol\";\nimport {ISilo} from \"../interfaces/ISilo.sol\";\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\nimport {IShareToken} from \"../interfaces/IShareToken.sol\";\nimport {SiloMathLib} from \"./SiloMathLib.sol\";\n\nlibrary SiloStdLib {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant _PRECISION_DECIMALS = 1e18;\n\n    /// @notice Returns flash fee amount\n    /// @param _config address of config contract for Silo\n    /// @param _token for which fee is calculated\n    /// @param _amount for which fee is calculated\n    /// @return fee flash fee amount\n    function flashFee(ISiloConfig _config, address _token, uint256 _amount) internal view returns (uint256 fee) {\n        if (_amount == 0) return 0;\n\n        // all user set fees are in 18 decimals points\n        (,, uint256 flashloanFee, address asset) = _config.getFeesWithAsset(address(this));\n        require(_token == asset, ISilo.UnsupportedFlashloanToken());\n        if (flashloanFee == 0) return 0;\n\n        require(type(uint256).max / _amount >= flashloanFee, ISilo.FlashloanAmountTooBig());\n        fee = _amount * flashloanFee / _PRECISION_DECIMALS;\n\n        // round up\n        if (fee == 0) return 1;\n    }\n\n    /// @notice Returns totalAssets and totalShares for conversion math (convertToAssets and convertToShares)\n    /// @dev This is useful for view functions that do not accrue interest before doing calculations. To work on\n    ///      updated numbers, interest should be added on the fly.\n    /// @param _configData for a single token for which to do calculations\n    /// @param _assetType used to read proper storage data\n    /// @return totalAssets total assets in Silo with interest for given asset type\n    /// @return totalShares total shares in Silo for given asset type\n    function getTotalAssetsAndTotalSharesWithInterest(\n        ISiloConfig.ConfigData memory _configData,\n        ISilo.AssetType _assetType\n    )\n        internal\n        view\n        returns (uint256 totalAssets, uint256 totalShares)\n    {\n        if (_assetType == ISilo.AssetType.Protected) {\n            totalAssets = ISilo(_configData.silo).getTotalAssetsStorage(ISilo.AssetType.Protected);\n            totalShares = IShareToken(_configData.protectedShareToken).totalSupply();\n        } else if (_assetType == ISilo.AssetType.Collateral) {\n            totalAssets = getTotalCollateralAssetsWithInterest(\n                _configData.silo,\n                _configData.interestRateModel,\n                _configData.daoFee,\n                _configData.deployerFee\n            );\n\n            totalShares = IShareToken(_configData.collateralShareToken).totalSupply();\n        } else { // ISilo.AssetType.Debt\n            totalAssets = getTotalDebtAssetsWithInterest(_configData.silo, _configData.interestRateModel);\n            totalShares = IShareToken(_configData.debtShareToken).totalSupply();\n        }\n    }\n\n    /// @notice Retrieves fee amounts in 18 decimals points and their respective receivers along with the asset\n    /// @param _silo Silo address\n    /// @return daoFeeReceiver Address of the DAO fee receiver\n    /// @return deployerFeeReceiver Address of the deployer fee receiver\n    /// @return daoFee DAO fee amount in 18 decimals points\n    /// @return deployerFee Deployer fee amount in 18 decimals points\n    /// @return asset Address of the associated asset\n    function getFeesAndFeeReceiversWithAsset(ISilo _silo)\n        internal\n        view\n        returns (\n            address daoFeeReceiver,\n            address deployerFeeReceiver,\n            uint256 daoFee,\n            uint256 deployerFee,\n            address asset\n        )\n    {\n        (daoFee, deployerFee,, asset) = _silo.config().getFeesWithAsset(address(_silo));\n        (daoFeeReceiver, deployerFeeReceiver) = _silo.factory().getFeeReceivers(address(_silo));\n    }\n\n    /// @notice Calculates the total collateral assets with accrued interest\n    /// @dev Do not use this method when accrueInterest were executed already, in that case total does not change\n    /// @param _silo Address of the silo contract\n    /// @param _interestRateModel Interest rate model to fetch compound interest rates\n    /// @param _daoFee DAO fee in 18 decimals points\n    /// @param _deployerFee Deployer fee in 18 decimals points\n    /// @return totalCollateralAssetsWithInterest Accumulated collateral amount with interest\n    function getTotalCollateralAssetsWithInterest(\n        address _silo,\n        address _interestRateModel,\n        uint256 _daoFee,\n        uint256 _deployerFee\n    ) internal view returns (uint256 totalCollateralAssetsWithInterest) {\n        uint256 rcomp;\n\n        try IInterestRateModel(_interestRateModel).getCompoundInterestRate(_silo, block.timestamp) returns (uint256 r) {\n            rcomp = r;\n        } catch {\n            // do not lock silo\n        }\n\n        (uint256 collateralAssets, uint256 debtAssets) = ISilo(_silo).getCollateralAndDebtTotalsStorage();\n\n        (totalCollateralAssetsWithInterest,,,) = SiloMathLib.getCollateralAmountsWithInterest({\n            _collateralAssets: collateralAssets,\n            _debtAssets: debtAssets,\n            _rcomp: rcomp,\n            _daoFee: _daoFee,\n            _deployerFee: _deployerFee\n        });\n    }\n\n    /// @param _balanceCached if balance of `_owner` is unknown beforehand, then pass `0`\n    function getSharesAndTotalSupply(address _shareToken, address _owner, uint256 _balanceCached)\n        internal\n        view\n        returns (uint256 shares, uint256 totalSupply)\n    {\n        if (_balanceCached == 0) {\n            (shares, totalSupply) = IShareToken(_shareToken).balanceOfAndTotalSupply(_owner);\n        } else {\n            shares = _balanceCached;\n            totalSupply = IShareToken(_shareToken).totalSupply();\n        }\n    }\n\n    /// @notice Calculates the total debt assets with accrued interest\n    /// @param _silo Address of the silo contract\n    /// @param _interestRateModel Interest rate model to fetch compound interest rates\n    /// @return totalDebtAssetsWithInterest Accumulated debt amount with interest\n    function getTotalDebtAssetsWithInterest(address _silo, address _interestRateModel)\n        internal\n        view\n        returns (uint256 totalDebtAssetsWithInterest)\n    {\n        uint256 rcomp;\n\n        try IInterestRateModel(_interestRateModel).getCompoundInterestRate(_silo, block.timestamp) returns (uint256 r) {\n            rcomp = r;\n        } catch {\n            // do not lock silo\n        }\n\n        (\n            totalDebtAssetsWithInterest,\n        ) = SiloMathLib.getDebtAmountsWithInterest(ISilo(_silo).getTotalAssetsStorage(ISilo.AssetType.Debt), rcomp);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "silo-core/contracts/lib/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IsContract} from \"./IsContract.sol\";\n\nlibrary TokenHelper {\n    uint256 private constant _BYTES32_SIZE = 32;\n\n    error TokenIsNotAContract();\n\n    function assertAndGetDecimals(address _token) internal view returns (uint256) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.decimals, ()));\n\n        // decimals() is optional in the ERC20 standard, so if metadata is not accessible\n        // we assume there are no decimals and use 0.\n        if (!hasMetadata) {\n            return 0;\n        }\n\n        return abi.decode(data, (uint8));\n    }\n\n    /// @dev Returns the symbol for the provided ERC20 token.\n    /// An empty string is returned if the call to the token didn't succeed.\n    /// @param _token address of the token to get the symbol for\n    /// @return assetSymbol the token symbol\n    function symbol(address _token) internal view returns (string memory assetSymbol) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.symbol, ()));\n\n        if (!hasMetadata || data.length == 0) {\n            return \"?\";\n        } else if (data.length == _BYTES32_SIZE) {\n            return string(removeZeros(data));\n        } else {\n            return abi.decode(data, (string));\n        }\n    }\n\n    /// @dev Removes bytes with value equal to 0 from the provided byte array.\n    /// @param _data byte array from which to remove zeroes\n    /// @return result byte array with zeroes removed\n    function removeZeros(bytes memory _data) internal pure returns (bytes memory result) {\n        uint256 n = _data.length;\n\n        for (uint256 i; i < n; i++) {\n            if (_data[i] == 0) continue;\n\n            result = abi.encodePacked(result, _data[i]);\n        }\n    }\n\n    /// @dev Performs a staticcall to the token to get its metadata (symbol, decimals, name)\n    function _tokenMetadataCall(address _token, bytes memory _data) private view returns (bool, bytes memory) {\n        // We need to do this before the call, otherwise the call will succeed even for EOAs\n        require(IsContract.isContract(_token), TokenIsNotAContract());\n\n        (bool success, bytes memory result) = _token.staticcall(_data);\n\n        // If the call reverted we assume the token doesn't follow the metadata extension\n        if (!success) {\n            return (false, \"\");\n        }\n\n        return (true, result);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IInterestRateModel {\n    event InterestRateModelError();\n\n    /// @dev Sets config address for all Silos that will use this model\n    /// @param _irmConfig address of IRM config contract\n    function initialize(address _irmConfig) external;\n\n    /// @dev get compound interest rate and update model storage for current block.timestamp\n    /// @param _collateralAssets total silo collateral assets\n    /// @param _debtAssets total silo debt assets\n    /// @param _interestRateTimestamp last IRM timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRateAndUpdate(\n        uint256 _collateralAssets,\n        uint256 _debtAssets,\n        uint256 _interestRateTimestamp\n    )\n        external\n        returns (uint256 rcomp);\n\n    /// @dev get compound interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\n    function getCompoundInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcomp);\n\n    /// @dev get current annual interest rate\n    /// @param _silo address of Silo for which interest rate should be calculated\n    /// @param _blockTimestamp current block timestamp\n    /// @return rcur current annual interest rate (1e18 == 100%)\n    function getCurrentInterestRate(address _silo, uint256 _blockTimestamp)\n        external\n        view\n        returns (uint256 rcur);\n\n    /// @dev returns decimal points used by model\n    function decimals() external view returns (uint256);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/lib/IsContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nlibrary IsContract {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address _account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return _account.code.length > 0;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=gitmodules/forge-std/src/",
      "silo-foundry-utils/=gitmodules/silo-foundry-utils/contracts/",
      "properties/=gitmodules/crytic/properties/contracts/",
      "silo-core/=silo-core/",
      "silo-oracles/=silo-oracles/",
      "silo-vaults/=silo-vaults/",
      "@openzeppelin/=gitmodules/openzeppelin-contracts-5/",
      "morpho-blue/=gitmodules/morpho-blue/src/",
      "openzeppelin5/=gitmodules/openzeppelin-contracts-5/contracts/",
      "openzeppelin5-upgradeable/=gitmodules/openzeppelin-contracts-upgradeable-5/contracts/",
      "chainlink/=gitmodules/chainlink/contracts/src/",
      "chainlink-ccip/=gitmodules/chainlink-ccip/contracts/src/",
      "uniswap/=gitmodules/uniswap/",
      "@uniswap/v3-core/=gitmodules/uniswap/v3-core/",
      "pyth-sdk-solidity/=gitmodules/pyth-sdk-solidity/target_chains/ethereum/sdk/solidity/",
      "a16z-erc4626-tests/=gitmodules/a16z-erc4626-tests/",
      "@ensdomains/=node_modules/@ensdomains/",
      "@solidity-parser/=node_modules/prettier-plugin-solidity/node_modules/@solidity-parser/",
      "ERC4626/=gitmodules/crytic/properties/lib/ERC4626/contracts/",
      "createx/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/src/",
      "crytic/=gitmodules/crytic/",
      "ds-test/=gitmodules/openzeppelin-contracts-5/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=gitmodules/openzeppelin-contracts-5/lib/erc4626-tests/",
      "halmos-cheatcodes/=gitmodules/morpho-blue/lib/halmos-cheatcodes/src/",
      "hardhat/=node_modules/hardhat/",
      "openzeppelin-contracts-5/=gitmodules/openzeppelin-contracts-5/",
      "openzeppelin-contracts-upgradeable-5/=gitmodules/openzeppelin-contracts-upgradeable-5/",
      "openzeppelin-contracts-upgradeable/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/",
      "prettier-plugin-solidity/=node_modules/prettier-plugin-solidity/",
      "solady/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/lib/solady/",
      "solmate/=gitmodules/crytic/properties/lib/solmate/src/",
      "x-silo/=node_modules/x-silo/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {
      "silo-core/contracts/hooks/SiloHookV2.sol": {
        "DefaultingRepayLib": "0x195d012e879322adb9feb9f1d6dc82009b542897",
        "PartialLiquidationExecLib": "0xb221f1f4a60c32e532b0d3feea9d5cfe47cf3c0e"
      }
    }
  }
}