{
  "language": "Solidity",
  "sources": {
    "silo-oracles/contracts/pendle/linear/PTLinearOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {Clones} from \"openzeppelin5/proxy/Clones.sol\";\n\nimport {Create2Factory} from \"common/utils/Create2Factory.sol\";\nimport {OracleFactory} from \"../../_common/OracleFactory.sol\";\n\nimport {PTLinearOracle} from \"./PTLinearOracle.sol\";\nimport {PTLinearOracleConfig} from \"./PTLinearOracleConfig.sol\";\nimport {IPTLinearOracleFactory} from \"../../interfaces/IPTLinearOracleFactory.sol\";\nimport {IPTLinearOracle} from \"../../interfaces/IPTLinearOracle.sol\";\nimport {IPTLinearOracleConfig} from \"../../interfaces/IPTLinearOracleConfig.sol\";\n\nimport {IPendlePTLike} from \"../interfaces/IPendlePTLike.sol\";\nimport {ISparkLinearDiscountOracleFactory} from \"../interfaces/ISparkLinearDiscountOracleFactory.sol\";\n\nimport {TokenHelper} from \"silo-core/contracts/lib/TokenHelper.sol\";\n\ncontract PTLinearOracleFactory is Create2Factory, OracleFactory, IPTLinearOracleFactory {\n    ISparkLinearDiscountOracleFactory public immutable PENDLE_SPARK_LINEAR_DISCOUNT_FACTORY;\n\n    constructor(address _pendleLinearOracleFactory) OracleFactory(address(new PTLinearOracle())) {\n        require(_pendleLinearOracleFactory != address(0), AddressZero());\n\n        PENDLE_SPARK_LINEAR_DISCOUNT_FACTORY = ISparkLinearDiscountOracleFactory(_pendleLinearOracleFactory);\n    }\n\n    /// @inheritdoc IPTLinearOracleFactory\n    function create(DeploymentConfig memory _deploymentConfig, bytes32 _externalSalt)\n        external\n        virtual\n        returns (IPTLinearOracle oracle)\n    {\n        bytes32 id = hashConfig(_deploymentConfig);\n\n        address existingOracle = resolveExistingOracle(id);\n\n        if (existingOracle != address(0)) return IPTLinearOracle(existingOracle);\n\n        IPTLinearOracleConfig.OracleConfig memory oracleConfig = createAndVerifyOracleConfig(_deploymentConfig);\n\n        IPTLinearOracleConfig oracleConfigAddress = new PTLinearOracleConfig(oracleConfig);\n        oracle = IPTLinearOracle(Clones.cloneDeterministic(ORACLE_IMPLEMENTATION, _salt(_externalSalt)));\n\n        _saveOracle(address(oracle), address(oracleConfigAddress), id);\n\n        oracle.initialize(oracleConfigAddress);\n    }\n\n    /// @inheritdoc IPTLinearOracleFactory\n    function predictAddress(DeploymentConfig memory _deploymentConfig, address _deployer, bytes32 _externalSalt)\n        external\n        view\n        returns (address predictedAddress)\n    {\n        bytes32 id = hashConfig(_deploymentConfig);\n        address existingOracle = resolveExistingOracle(id);\n        if (existingOracle != address(0)) return existingOracle;\n\n        require(_deployer != address(0), DeployerCannotBeZero());\n\n        predictedAddress =\n            Clones.predictDeterministicAddress(ORACLE_IMPLEMENTATION, _createSalt(_deployer, _externalSalt));\n    }\n\n    function createAndVerifyOracleConfig(DeploymentConfig memory _deploymentConfig)\n        public\n        virtual\n        returns (IPTLinearOracleConfig.OracleConfig memory oracleConfig)\n    {\n        require(_deploymentConfig.maxYield < 1e18, InvalidMaxYield());\n        require(_deploymentConfig.ptToken != address(0), AddressZero());\n\n        uint256 tokenDecimals = TokenHelper.assertAndGetDecimals(_deploymentConfig.ptToken);\n\n        oracleConfig = IPTLinearOracleConfig.OracleConfig({\n            ptToken: _deploymentConfig.ptToken,\n            hardcodedQuoteToken: _deploymentConfig.hardcodedQuoteToken,\n            normalizationDivider: 10 ** tokenDecimals,\n            linearOracle: PENDLE_SPARK_LINEAR_DISCOUNT_FACTORY.createWithPt({\n                ptToken: _deploymentConfig.ptToken,\n                baseDiscountPerYear: _deploymentConfig.maxYield\n            })\n        });\n\n        _verifyOracleConfig(oracleConfig);\n    }\n\n    function hashConfig(DeploymentConfig memory _deploymentConfig) public view virtual returns (bytes32 configId) {\n        configId = keccak256(abi.encode(_deploymentConfig));\n    }\n\n    function resolveExistingOracle(bytes32 _configId) public view virtual returns (address oracle) {\n        address oracleConfig = getConfigAddress[_configId];\n        return oracleConfig == address(0) ? address(0) : getOracleAddress[oracleConfig];\n    }\n\n    function _verifyOracleConfig(IPTLinearOracleConfig.OracleConfig memory _oracleConfig) internal view virtual {\n        uint256 maturityDate = IPendlePTLike(_oracleConfig.ptToken).expiry();\n        require(maturityDate != 0 && maturityDate < type(uint64).max, MaturityDateInvalid());\n        require(maturityDate > block.timestamp, MaturityDateIsInThePast());\n\n        require(_oracleConfig.hardcodedQuoteToken != address(0), AddressZero());\n        require(_oracleConfig.linearOracle != address(0), LinearOracleCannotBeZero());\n\n        require(_oracleConfig.normalizationDivider <= 1e18, NormalizationDividerTooLarge());\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Stores the bytecode after address\n            mstore(0x20, 0x5af43d82803e903d91602b57fd5bf3)\n            // implementation address\n            mstore(0x11, implementation)\n            // Packs the first 3 bytes of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0x88, implementation), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "common/utils/Create2Factory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Nonces} from \"openzeppelin5/utils/Nonces.sol\";\n\ncontract Create2Factory is Nonces {\n    function _salt() internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender)\n        ));\n    }\n\n    function _salt(bytes32 _externalSalt) internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender),\n            _externalSalt\n        ));\n    }\n\n    function _createSalt(address _deployer, bytes32 _externalSalt) internal view returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            _deployer,\n            nonces(_deployer),\n            _externalSalt\n        ));\n    }\n}\n"
    },
    "silo-oracles/contracts/_common/OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.7.6 <0.9.0;\n\n\nabstract contract OracleFactory {\n    /// @dev implementation that will be cloned\n    address public immutable ORACLE_IMPLEMENTATION; // solhint-disable-line var-name-mixedcase\n\n    /// @dev hash(config) => oracle config contract\n    /// oracle ID is determine by initial configuration, the logic is the same, so config is the only difference\n    /// that's why we can use it as ID, at the same time we can detect duplicates and save gas by reusing same config\n    /// multiple times\n    mapping(bytes32 => address) public getConfigAddress;\n\n    /// @dev config address => oracle address\n    mapping(address => address) public getOracleAddress;\n\n    /// @dev config ID and config address should be easily accessible directly from oracle contract\n    event NewOracle(address indexed oracle);\n\n    constructor(address _oracleImplementation) {\n        if (_oracleImplementation == address(0)) revert(\"ZeroAddress\");\n\n        ORACLE_IMPLEMENTATION = _oracleImplementation;\n    }\n\n    /// @dev execute this method from target factory, to save ID and update mappings\n    /// @param _newOracle new oracle address\n    /// @param _newConfig oracle config address\n    /// @param _configId oracle config ID, hash(config)\n    function _saveOracle(address _newOracle, address _newConfig, bytes32 _configId) internal virtual {\n        if (getConfigAddress[_configId] != address(0)) revert(\"ConfigAlreadyExist\");\n\n        getConfigAddress[_configId] = _newConfig;\n        // config and oracle is 1:1 so no need to check if oracle exists\n        getOracleAddress[_newConfig] = _newOracle;\n\n        emit NewOracle(_newOracle);\n    }\n}\n"
    },
    "silo-oracles/contracts/pendle/linear/PTLinearOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {Initializable} from \"openzeppelin5-upgradeable/proxy/utils/Initializable.sol\";\nimport {AggregatorV3Interface} from \"chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {SafeCast} from \"openzeppelin5/utils/math/SafeCast.sol\";\n\nimport {TokenHelper} from \"silo-core/contracts/lib/TokenHelper.sol\";\n\nimport {ISiloOracle} from \"silo-core/contracts/interfaces/ISiloOracle.sol\";\nimport {IVersioned} from \"silo-core/contracts/interfaces/IVersioned.sol\";\nimport {IPTLinearOracleConfig} from \"../../interfaces/IPTLinearOracleConfig.sol\";\nimport {IPTLinearOracle} from \"../../interfaces/IPTLinearOracle.sol\";\nimport {Aggregator} from \"../../_common/Aggregator.sol\";\n\nimport {ISparkLinearDiscountOracle} from \"../../pendle/interfaces/ISparkLinearDiscountOracle.sol\";\n\ncontract PTLinearOracle is IPTLinearOracle, Initializable, Aggregator, IVersioned {\n    IPTLinearOracleConfig public oracleConfig;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @inheritdoc IPTLinearOracle\n    function initialize(IPTLinearOracleConfig _configAddress) external virtual initializer {\n        require(address(_configAddress) != address(0), EmptyConfigAddress());\n\n        oracleConfig = _configAddress;\n\n        emit PTLinearOracleInitialized(_configAddress);\n    }\n\n    /// @inheritdoc AggregatorV3Interface\n    /// @notice because this is just a proxy to interface, then only `answer` field will have non zero value\n    /// return value is in 18 decimals, not 8 like in chainlink\n    function latestRoundData()\n        external\n        view\n        virtual\n        override(Aggregator, AggregatorV3Interface)\n        returns (uint80, int256 answer, uint256, uint256, uint80)\n    {\n        IPTLinearOracleConfig.OracleConfig memory cfg = oracleConfig.getConfig();\n        // pull price for one token, normalizationDivider is one token in token decimals\n        answer = SafeCast.toInt256(quote(cfg.normalizationDivider, cfg.ptToken));\n        return (0, answer, 0, 0, 0);\n    }\n\n    /// @inheritdoc ISiloOracle\n    function quoteToken() external view virtual returns (address) {\n        return oracleConfig.getConfig().hardcodedQuoteToken;\n    }\n\n    /// @inheritdoc AggregatorV3Interface\n    function description() external view override(Aggregator, AggregatorV3Interface) virtual returns (string memory) {\n        string memory baseSymbol = TokenHelper.symbol(oracleConfig.getConfig().ptToken);\n        string memory quoteSymbol = TokenHelper.symbol(oracleConfig.getConfig().hardcodedQuoteToken);\n        return string.concat(\"PTLinearOracle for \", baseSymbol, \" / \", quoteSymbol);\n    }\n\n    /// @inheritdoc IPTLinearOracle\n    function baseDiscountPerYear() external view returns (uint256 discount) {\n        discount = ISparkLinearDiscountOracle(oracleConfig.getConfig().linearOracle).baseDiscountPerYear();\n    }\n\n    /// @inheritdoc ISiloOracle\n    function beforeQuote(address) external pure virtual override {\n        // nothing to execute\n    }\n\n    /// @inheritdoc IVersioned\n    // solhint-disable-next-line func-name-mixedcase\n    function VERSION() external pure override returns (string memory version) {\n        version = \"PTLinearOracle 4.0.0\";\n    }\n\n    /// @inheritdoc Aggregator\n    function baseToken() public view virtual override returns (address token) {\n        IPTLinearOracleConfig.OracleConfig memory cfg = oracleConfig.getConfig();\n        return cfg.ptToken;\n    }\n\n    /// @inheritdoc ISiloOracle\n    function quote(uint256 _baseAmount, address _baseToken)\n        public\n        view\n        virtual\n        override(Aggregator, ISiloOracle)\n        returns (uint256 quoteAmount)\n    {\n        IPTLinearOracleConfig oracleCfg = oracleConfig;\n        require(address(oracleCfg) != address(0), NotInitialized());\n\n        IPTLinearOracleConfig.OracleConfig memory cfg = oracleCfg.getConfig();\n\n        require(_baseToken == cfg.ptToken, AssetNotSupported());\n        require(_baseAmount <= type(uint128).max, BaseAmountOverflow());\n\n        /*\n        ptLinearPrice is a simple, deterministic feed that returns a discount factor for a given PT. \n        The factor increases linearly as time passes and converges to 1.0 at maturity, \n        so integrators can price PT conservatively without relying on external market data.\n        */\n        (, int256 ptLinearPrice,,,) = AggregatorV3Interface(cfg.linearOracle).latestRoundData();\n\n        // Safe: linear discount oracle returns non-negative discount factors.\n        // forge-lint: disable-next-line(unsafe-typecast)\n        quoteAmount = _baseAmount * uint256(ptLinearPrice) / cfg.normalizationDivider;\n\n        require(quoteAmount != 0, ZeroQuote());\n    }\n}\n"
    },
    "silo-oracles/contracts/pendle/linear/PTLinearOracleConfig.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {IPTLinearOracleConfig} from \"../../interfaces/IPTLinearOracleConfig.sol\";\n\ncontract PTLinearOracleConfig is IPTLinearOracleConfig {\n    /// @dev Linear oracle address deploybed by ISparkLinearDiscountOracleFactory\n    address internal immutable _LINEAR_ORACLE;\n    /// @dev PT token address\n    address internal immutable _PT_TOKEN;\n    /// @dev Hardcoded quote token address that will be used for quoteToken() function in oracle\n    address internal immutable _HARDCODED_QUOTE_TOKEN;\n    /// @dev Normalization divider, must be 10 ** tokenDecimals of ptToken\n    uint256 internal immutable _NORMALIZATION_DIVIDER;\n\n    /// @dev all verification should be done by factory\n    constructor(OracleConfig memory _cfg) {\n        _LINEAR_ORACLE = _cfg.linearOracle;\n        _PT_TOKEN = _cfg.ptToken;\n        _HARDCODED_QUOTE_TOKEN = _cfg.hardcodedQuoteToken;\n        _NORMALIZATION_DIVIDER = _cfg.normalizationDivider;\n    }\n\n    function getConfig() external view virtual returns (OracleConfig memory cfg) {\n        cfg.linearOracle = _LINEAR_ORACLE;\n        cfg.ptToken = _PT_TOKEN;\n        cfg.hardcodedQuoteToken = _HARDCODED_QUOTE_TOKEN;\n        cfg.normalizationDivider = _NORMALIZATION_DIVIDER;\n    }\n}\n"
    },
    "silo-oracles/contracts/interfaces/IPTLinearOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {IPTLinearOracleConfig} from \"./IPTLinearOracleConfig.sol\";\nimport {IPTLinearOracle} from \"./IPTLinearOracle.sol\";\n\n/// @dev This interface is used to create and verify PTLinearOracle.\n/// @notice PT markets are not deterministic, so there is no guarantee that this code will work for all markets.\ninterface IPTLinearOracleFactory {\n    /// @param ptToken Pendle PT token address, for which oracle will be created\n    /// @param maxYield Maximum liquidity yeald, this should be manually read from market specyfication,\n    /// Yield range is provided in pendle UI eg for 4% - 25% range we should use 0.25e18, 1e18 is 100%.\n    /// @param hardcodedQuoteToken This address will be used as quote token in oracle\n    struct DeploymentConfig {\n        address ptToken;\n        uint256 maxYield;\n        address hardcodedQuoteToken;\n    }\n\n    error DeployerCannotBeZero();\n    error AddressZero();\n    error InvalidMaxYield();\n    error MaturityDateIsInThePast();\n    error MaturityDateInvalid();\n    error LinearOracleCannotBeZero();\n    error NormalizationDividerTooLarge();\n\n    /// @dev Use this method to create oracle for PT token\n    function create(DeploymentConfig memory _config, bytes32 _externalSalt)\n        external\n        returns (IPTLinearOracle oracle);\n\n    /// @notice this is only helper method, should not be used directly\n    function createAndVerifyOracleConfig(DeploymentConfig memory _deploymentConfig)\n        external\n        returns (IPTLinearOracleConfig.OracleConfig memory oracleConfig);\n\n    function resolveExistingOracle(bytes32 _configId) external view returns (address oracle);\n\n    function hashConfig(DeploymentConfig memory _deploymentConfig) external view returns (bytes32 configId);\n\n    function predictAddress(DeploymentConfig memory _deploymentConfig, address _deployer, bytes32 _externalSalt)\n        external\n        view\n        returns (address predictedAddress);\n}\n"
    },
    "silo-oracles/contracts/interfaces/IPTLinearOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport {AggregatorV3Interface} from \"chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport {ISiloOracle} from \"silo-core/contracts/interfaces/ISiloOracle.sol\";\nimport {IPTLinearOracleConfig} from \"./IPTLinearOracleConfig.sol\";\n\ninterface IPTLinearOracle is ISiloOracle, AggregatorV3Interface {\n    event PTLinearOracleInitialized(IPTLinearOracleConfig indexed configAddress);\n\n    error NotInitialized();\n    error EmptyConfigAddress();\n    error AssetNotSupported();\n    error ZeroQuote();\n    error BaseAmountOverflow();\n\n    /// @notice validation of config is checked in factory, therefore you should not deploy and initialize directly\n    /// use factory always.\n    function initialize(IPTLinearOracleConfig _configAddress) external;\n\n    function oracleConfig() external view returns (IPTLinearOracleConfig);\n\n    /// @dev returns the max discount per year that oracle was created with\n    function baseDiscountPerYear() external view returns (uint256);\n}\n"
    },
    "silo-oracles/contracts/interfaces/IPTLinearOracleConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IPTLinearOracleConfig {\n    /// @param linearOracle Linear oracle address deploybed by ISparkLinearDiscountOracleFactory\n    /// @param ptToken PT token address\n    /// @param hardcodedQuoteToken Hardcoded quote token address that will be used for quoteToken() function in oracle\n    /// @param normalizationDivider Normalization divider, must be 10 ** tokenDecimals of ptToken\n    struct OracleConfig {\n        address linearOracle;\n        address ptToken;\n        address hardcodedQuoteToken;\n        uint256 normalizationDivider;\n    }\n\n    function getConfig() external view returns (OracleConfig memory cfg);\n}\n"
    },
    "silo-oracles/contracts/pendle/interfaces/IPendlePTLike.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ninterface IPendlePTLike {\n    function expiry() external view returns (uint256);\n}\n"
    },
    "silo-oracles/contracts/pendle/interfaces/ISparkLinearDiscountOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ninterface ISparkLinearDiscountOracleFactory {\n    function createWithPt(address ptToken, uint256 baseDiscountPerYear) external returns (address res);\n}\n"
    },
    "silo-core/contracts/lib/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC20Metadata} from \"openzeppelin5/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IsContract} from \"./IsContract.sol\";\n\nlibrary TokenHelper {\n    uint256 private constant _BYTES32_SIZE = 32;\n\n    error TokenIsNotAContract();\n\n    function assertAndGetDecimals(address _token) internal view returns (uint256) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.decimals, ()));\n\n        // decimals() is optional in the ERC20 standard, so if metadata is not accessible\n        // we assume there are no decimals and use 0.\n        if (!hasMetadata) {\n            return 0;\n        }\n\n        return abi.decode(data, (uint8));\n    }\n\n    /// @dev Returns the symbol for the provided ERC20 token.\n    /// An empty string is returned if the call to the token didn't succeed.\n    /// @param _token address of the token to get the symbol for\n    /// @return assetSymbol the token symbol\n    function symbol(address _token) internal view returns (string memory assetSymbol) {\n        (bool hasMetadata, bytes memory data) =\n            _tokenMetadataCall(_token, abi.encodeCall(IERC20Metadata.symbol, ()));\n\n        if (!hasMetadata || data.length == 0) {\n            return \"?\";\n        } else if (data.length == _BYTES32_SIZE) {\n            return string(removeZeros(data));\n        } else {\n            return abi.decode(data, (string));\n        }\n    }\n\n    /// @dev Removes bytes with value equal to 0 from the provided byte array.\n    /// @param _data byte array from which to remove zeroes\n    /// @return result byte array with zeroes removed\n    function removeZeros(bytes memory _data) internal pure returns (bytes memory result) {\n        uint256 n = _data.length;\n\n        for (uint256 i; i < n; i++) {\n            if (_data[i] == 0) continue;\n\n            result = abi.encodePacked(result, _data[i]);\n        }\n    }\n\n    /// @dev Performs a staticcall to the token to get its metadata (symbol, decimals, name)\n    function _tokenMetadataCall(address _token, bytes memory _data) private view returns (bool, bytes memory) {\n        // We need to do this before the call, otherwise the call will succeed even for EOAs\n        require(IsContract.isContract(_token), TokenIsNotAContract());\n\n        (bool success, bytes memory result) = _token.staticcall(_data);\n\n        // If the call reverted we assume the token doesn't follow the metadata extension\n        if (!success) {\n            return (false, \"\");\n        }\n\n        return (true, result);\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-upgradeable-5/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "gitmodules/chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "silo-core/contracts/interfaces/ISiloOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ISiloOracle {\n    /// @notice Hook function to call before `quote` function reads price\n    /// @dev This hook function can be used to change state right before the price is read. For example it can be used\n    ///      for curve read only reentrancy protection. In majority of implementations this will be an empty function.\n    ///      WARNING: reverts are propagated to Silo so if `beforeQuote` reverts, Silo reverts as well.\n    /// @param _baseToken Address of priced token\n    function beforeQuote(address _baseToken) external;\n\n    /// @return quoteAmount Returns quote price for _baseAmount of _baseToken\n    /// @param _baseAmount Amount of priced token\n    /// @param _baseToken Address of priced token\n    function quote(uint256 _baseAmount, address _baseToken) external view returns (uint256 quoteAmount);\n\n    /// @return address of token in which quote (price) is denominated\n    function quoteToken() external view returns (address);\n}\n"
    },
    "silo-core/contracts/interfaces/IVersioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IVersioned {\n    /// @notice Returns the version of the contract\n    /// @return version The version of the contract in format \"SiloLens v3.17.0\"\n    function VERSION() external pure returns (string memory version); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "silo-oracles/contracts/_common/Aggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {AggregatorV3Interface} from \"chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {TokenHelper} from \"silo-core/contracts/lib/TokenHelper.sol\";\nimport {SafeCast} from \"openzeppelin5/utils/math/SafeCast.sol\";\n\n/// @dev Aggregator is a common aggregator interface for Silo oracles. \n/// It allows to join multiple oracles to caltulate any asset price.\nabstract contract Aggregator is AggregatorV3Interface {\n    /// @notice all Silo oracles should return price in 18 decimals\n    function decimals() external view virtual returns (uint8) {\n        return 18;\n    }\n\n    function description() external view virtual returns (string memory) {\n        return \"Silo Oracle\";\n    }\n\n    /// @notice this function follows the Chainlink V3 interface but only answer is used,\n    /// all other return values are zero\n    function latestRoundData()\n        external\n        view\n        virtual\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = 0;\n        address token = baseToken();\n        uint256 tokenDecimals = TokenHelper.assertAndGetDecimals(token);\n        answer = SafeCast.toInt256(quote(10 ** tokenDecimals, token));\n\n        startedAt = block.timestamp;\n        updatedAt = block.timestamp;\n        answeredInRound = 0;\n    }\n\n    function version() external pure returns (uint256) {\n        return 1;\n    }\n\n    /// @notice not in use, always returns 0s, use latestRoundData instead\n    function getRoundData(uint80)\n        external\n        pure\n        returns (uint80, int256, uint256, uint256, uint80)\n    {\n        return (0, 0, 0, 0, 0);\n    }\n    \n    /// @notice token that is getting priced by oracle\n    function baseToken() public view virtual returns (address token);\n\n    function quote(uint256 _baseAmount, address _baseToken) public view virtual returns (uint256 quoteAmount);\n}\n"
    },
    "silo-oracles/contracts/pendle/interfaces/ISparkLinearDiscountOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ninterface ISparkLinearDiscountOracle {\n    function baseDiscountPerYear() external view returns (uint256);\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "silo-core/contracts/lib/IsContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.24;\n\nlibrary IsContract {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address _account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return _account.code.length > 0;\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=gitmodules/forge-std/src/",
      "silo-foundry-utils/=gitmodules/silo-foundry-utils/contracts/",
      "properties/=gitmodules/crytic/properties/contracts/",
      "silo-core/=silo-core/",
      "silo-oracles/=silo-oracles/",
      "silo-vaults/=silo-vaults/",
      "@openzeppelin/=gitmodules/openzeppelin-contracts-5/",
      "morpho-blue/=gitmodules/morpho-blue/src/",
      "openzeppelin5/=gitmodules/openzeppelin-contracts-5/contracts/",
      "openzeppelin5-upgradeable/=gitmodules/openzeppelin-contracts-upgradeable-5/contracts/",
      "chainlink/=gitmodules/chainlink/contracts/src/",
      "chainlink-ccip/=gitmodules/chainlink-ccip/contracts/src/",
      "uniswap/=gitmodules/uniswap/",
      "@uniswap/v3-core/=gitmodules/uniswap/v3-core/",
      "pyth-sdk-solidity/=gitmodules/pyth-sdk-solidity/target_chains/ethereum/sdk/solidity/",
      "a16z-erc4626-tests/=gitmodules/a16z-erc4626-tests/",
      "@ensdomains/=node_modules/@ensdomains/",
      "@solidity-parser/=node_modules/prettier-plugin-solidity/node_modules/@solidity-parser/",
      "ERC4626/=gitmodules/crytic/properties/lib/ERC4626/contracts/",
      "createx/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/src/",
      "crytic/=gitmodules/crytic/",
      "ds-test/=gitmodules/openzeppelin-contracts-5/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=gitmodules/openzeppelin-contracts-5/lib/erc4626-tests/",
      "halmos-cheatcodes/=gitmodules/morpho-blue/lib/halmos-cheatcodes/src/",
      "hardhat/=node_modules/hardhat/",
      "openzeppelin-contracts-5/=gitmodules/openzeppelin-contracts-5/",
      "openzeppelin-contracts-upgradeable-5/=gitmodules/openzeppelin-contracts-upgradeable-5/",
      "openzeppelin-contracts-upgradeable/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/",
      "prettier-plugin-solidity/=node_modules/prettier-plugin-solidity/",
      "solady/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/lib/solady/",
      "solmate/=gitmodules/crytic/properties/lib/solmate/src/",
      "x-silo/=node_modules/x-silo/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false
  }
}