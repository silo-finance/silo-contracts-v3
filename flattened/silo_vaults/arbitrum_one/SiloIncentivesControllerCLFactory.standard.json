{
  "language": "Solidity",
  "sources": {
    "silo-vaults/contracts/incentives/claiming-logics/SiloIncentivesControllerCLFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Create2Factory} from \"common/utils/Create2Factory.sol\";\nimport {ISiloIncentivesControllerCLFactory} from \"../../interfaces/ISiloIncentivesControllerCLFactory.sol\";\nimport {SiloIncentivesControllerCL} from \"./SiloIncentivesControllerCL.sol\";\n\n/// @dev Factory for creating SiloIncentivesControllerCL instances\ncontract SiloIncentivesControllerCLFactory is Create2Factory, ISiloIncentivesControllerCLFactory {\n    mapping(address => bool) public createdInFactory;\n\n    /// @inheritdoc ISiloIncentivesControllerCLFactory\n    function createIncentivesControllerCL(\n        address _vaultIncentivesController,\n        address _siloIncentivesController,\n        bytes32 _externalSalt\n    ) external returns (SiloIncentivesControllerCL logic) {\n        logic = new SiloIncentivesControllerCL{salt: _salt(_externalSalt)}(\n            _vaultIncentivesController,\n            _siloIncentivesController\n        );\n\n        createdInFactory[address(logic)] = true;\n\n        emit IncentivesControllerCLCreated(address(logic));\n    }\n}\n"
    },
    "common/utils/Create2Factory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {Nonces} from \"openzeppelin5/utils/Nonces.sol\";\n\ncontract Create2Factory is Nonces {\n    function _salt() internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender)\n        ));\n    }\n\n    function _salt(bytes32 _externalSalt) internal returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(\n            msg.sender,\n            _useNonce(msg.sender),\n            _externalSalt\n        ));\n    }\n}\n"
    },
    "silo-vaults/contracts/interfaces/ISiloIncentivesControllerCLFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.28;\n\nimport {SiloIncentivesControllerCL} from \"../incentives/claiming-logics/SiloIncentivesControllerCL.sol\";\n\n/// @title ISiloIncentivesControllerCLFactory\ninterface ISiloIncentivesControllerCLFactory {\n    /// @notice Emitted when a new SiloIncentivesControllerCL instance is created\n    event IncentivesControllerCLCreated(address logic);\n\n    /// @notice Creates a new SiloIncentivesControllerCL instance\n    /// @param _vaultIncentivesController The address of the vault incentives controller\n    /// @param _siloIncentivesController The address of the silo incentives controller\n    /// @param _externalSalt The external salt to use for the creation of the SiloIncentivesControllerCL instance\n    /// @return logic The address of the created SiloIncentivesControllerCL instance\n    function createIncentivesControllerCL(\n        address _vaultIncentivesController,\n        address _siloIncentivesController,\n        bytes32 _externalSalt\n    ) external returns (SiloIncentivesControllerCL logic);\n\n    /// @notice Checks if a SiloIncentivesControllerCL instance is created in the factory\n    /// @param _logic The address of the SiloIncentivesControllerCL instance\n    /// @return createdInFactory Whether the SiloIncentivesControllerCL instance is created in the factory\n    function createdInFactory(address _logic) external view returns (bool createdInFactory);\n}\n"
    },
    "silo-vaults/contracts/incentives/claiming-logics/SiloIncentivesControllerCL.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.28;\n\nimport {\n    ISiloIncentivesController,\n    IDistributionManager\n} from \"silo-core/contracts/incentives/interfaces/ISiloIncentivesController.sol\";\n\nimport {IIncentivesClaimingLogic} from \"../../interfaces/IIncentivesClaimingLogic.sol\";\n\n/// @title Silo incentives controller claiming logic\ncontract SiloIncentivesControllerCL is IIncentivesClaimingLogic {\n    /// @notice Distributes rewards to vault depositors\n    ISiloIncentivesController public immutable VAULT_INCENTIVES_CONTROLLER;\n    /// @notice Distributes rewards to silo depositors\n    ISiloIncentivesController public immutable SILO_INCENTIVES_CONTROLLER;\n\n    constructor(\n        address _vaultIncentivesController,\n        address _siloIncentivesController\n    ) {\n        require(_vaultIncentivesController != address(0), VaultIncentivesControllerZeroAddress());\n        require(_siloIncentivesController != address(0), SiloIncentivesControllerZeroAddress());\n\n        VAULT_INCENTIVES_CONTROLLER = ISiloIncentivesController(_vaultIncentivesController);\n        SILO_INCENTIVES_CONTROLLER = ISiloIncentivesController(_siloIncentivesController);\n    }\n\n    function claimRewardsAndDistribute() external virtual {\n        IDistributionManager.AccruedRewards[] memory accruedRewards =\n            SILO_INCENTIVES_CONTROLLER.claimRewards(address(VAULT_INCENTIVES_CONTROLLER));\n\n        for (uint256 i = 0; i < accruedRewards.length; i++) {\n            if (accruedRewards[i].amount == 0) continue;\n\n            VAULT_INCENTIVES_CONTROLLER.immediateDistribution(\n                accruedRewards[i].rewardToken,\n                uint104(accruedRewards[i].amount)\n            );\n        }\n    }\n}\n"
    },
    "gitmodules/openzeppelin-contracts-5/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "silo-core/contracts/incentives/interfaces/ISiloIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.28;\n\nimport {IDistributionManager} from \"./IDistributionManager.sol\";\nimport {DistributionTypes} from \"../lib/DistributionTypes.sol\";\n\ninterface ISiloIncentivesController is IDistributionManager {\n    event ClaimerSet(address indexed user, address indexed claimer);\n    event IncentivesProgramCreated(string name);\n    event IncentivesProgramUpdated(string name);\n\n    event RewardsAccrued(\n        address indexed user,\n        address indexed rewardToken,\n        string indexed programName,\n        uint256 amount\n    );\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        address indexed rewardToken,\n        bytes32 programId,\n        address claimer,\n        uint256 amount\n    );\n\n    error InvalidDistributionEnd();\n    error InvalidConfiguration();\n    error IndexOverflowAtEmissionsPerSecond();\n    error InvalidToAddress();\n    error InvalidUserAddress();\n    error ClaimerUnauthorized();\n    error InvalidRewardToken();\n    error IncentivesProgramAlreadyExists();\n    error IncentivesProgramNotFound();\n    error DifferentRewardsTokens();\n    error EmissionPerSecondTooHigh();\n\n    /**\n     * @dev Silo share token event handler\n     * @param _sender The address of the sender\n     * @param _senderBalance The balance of the sender\n     * @param _recipient The address of the recipient\n     * @param _recipientBalance The balance of the recipient\n     * @param _totalSupply The total supply of the asset in the lending pool\n     * @param _amount The amount of the transfer\n     */\n    function afterTokenTransfer(\n        address _sender,\n        uint256 _senderBalance,\n        address _recipient,\n        uint256 _recipientBalance,\n        uint256 _totalSupply,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @dev Immediately distributes rewards to the incentives program\n     * Expect an `_amount` to be transferred to the contract before calling this fn\n     * @param _tokenToDistribute The token to distribute\n     * @param _amount The amount of rewards to distribute\n     */\n    function immediateDistribution(address _tokenToDistribute, uint104 _amount) external;\n\n    /// @dev It will transfer all the reward token balance to the owner.\n    /// @param _rewardToken The reward token to rescue\n    function rescueRewards(address _rewardToken) external;\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param _user The address of the user\n     * @param _claimer The address of the claimer\n     */\n    function setClaimer(address _user, address _claimer) external;\n\n    /**\n     * @dev Creates a new incentives program\n     * @param _incentivesProgramInput The incentives program creation input\n     */\n    function createIncentivesProgram(DistributionTypes.IncentivesProgramCreationInput memory _incentivesProgramInput)\n        external;\n\n    /**\n     * @dev Updates an existing incentives program\n     * @param _incentivesProgram The incentives program name\n     * @param _distributionEnd The distribution end\n     * @param _emissionPerSecond The emission per second\n     */\n    function updateIncentivesProgram(\n        string calldata _incentivesProgram,\n        uint40 _distributionEnd,\n        uint104 _emissionPerSecond\n    ) external;\n\n    /**\n     * @dev Claims reward for an user to the desired address, on all the assets of the lending pool,\n     * accumulating the pending rewards\n     * @param _to Address that will be receiving the rewards\n     * @return accruedRewards\n     */\n    function claimRewards(address _to) external returns (AccruedRewards[] memory accruedRewards);\n\n    /**\n     * @dev Claims reward for an user to the desired address, on all the assets of the lending pool,\n     * accumulating the pending rewards\n     * @param _to Address that will be receiving the rewards\n     * @param _programNames The incentives program names\n     * @return accruedRewards\n     */\n    function claimRewards(address _to, string[] calldata _programNames)\n        external\n        returns (AccruedRewards[] memory accruedRewards);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending\n     * rewards. The caller must be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param _user Address to check and claim rewards\n     * @param _to Address that will be receiving the rewards\n     * @param _programNames The incentives program names\n     * @return accruedRewards\n     */\n    function claimRewardsOnBehalf(address _user, address _to, string[] calldata _programNames)\n        external\n        returns (AccruedRewards[] memory accruedRewards);\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param _user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address _user) external view returns (address);\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param _user The address of the user\n     * @param _programName The incentives program name\n     * @return unclaimedRewards\n     */\n    function getRewardsBalance(address _user, string calldata _programName)\n        external\n        view\n        returns (uint256 unclaimedRewards);\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param _user The address of the user\n     * @param _programNames The incentives program names (should have the same rewards token)\n     * @return unclaimedRewards\n     */\n    function getRewardsBalance(address _user, string[] calldata _programNames)\n        external\n        view\n        returns (uint256 unclaimedRewards);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param _user the address of the user\n     * @param _programName The incentives program name\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address _user, string calldata _programName) external view returns (uint256);\n}\n"
    },
    "silo-vaults/contracts/interfaces/IIncentivesClaimingLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Incentives Claiming Logic interface\ninterface IIncentivesClaimingLogic {\n    error VaultIncentivesControllerZeroAddress();\n    error SiloIncentivesControllerZeroAddress();\n\n    /// @notice Claim and distribute rewards to the vault.\n    /// @dev Can claim rewards from multiple sources and distribute them to the vault users.\n    function claimRewardsAndDistribute() external;\n}\n"
    },
    "silo-core/contracts/incentives/interfaces/IDistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.28;\n\nimport {DistributionTypes} from \"../lib/DistributionTypes.sol\";\n\ninterface IDistributionManager {\n    struct IncentivesProgram {\n        uint256 index;\n        address rewardToken; // can't be updated after creation\n        uint104 emissionPerSecond; // configured by owner\n        uint40 lastUpdateTimestamp;\n        uint40 distributionEnd; // configured by owner\n        mapping(address user => uint256 userIndex) users;\n    }\n\n    struct IncentiveProgramDetails {\n        uint256 index;\n        address rewardToken;\n        uint104 emissionPerSecond;\n        uint40 lastUpdateTimestamp;\n        uint40 distributionEnd;\n    }\n\n    struct AccruedRewards {\n        uint256 amount;\n        bytes32 programId;\n        address rewardToken;\n    }\n\n    event AssetConfigUpdated(address indexed asset, uint256 emission);\n    event AssetIndexUpdated(address indexed asset, uint256 index);\n    event DistributionEndUpdated(string incentivesProgram, uint256 newDistributionEnd);\n    event IncentivesProgramIndexUpdated(string incentivesProgram, uint256 newIndex);\n    event UserIndexUpdated(address indexed user, string incentivesProgram, uint256 newIndex);\n\n    error OnlyNotifier();\n    error TooLongProgramName();\n    error CollisionWithAddress();\n    error InvalidIncentivesProgramName();\n    error OnlyNotifierOrOwner();\n    error ZeroAddress();\n\n    /**\n     * @dev Sets the end date for the distribution\n     * @param _incentivesProgram The incentives program name\n     * @param _distributionEnd The end date timestamp\n     */\n    function setDistributionEnd(string calldata _incentivesProgram, uint40 _distributionEnd) external;\n\n    /**\n     * @dev Gets the end date for the distribution  \n     * @param _incentivesProgram The incentives program name\n     * @return The end of the distribution\n     */\n    function getDistributionEnd(string calldata _incentivesProgram) external view returns (uint256);\n\n    /**\n     * @dev Returns the data of an user on a distribution\n     * @param _user Address of the user\n     * @param _incentivesProgram The incentives program name\n     * @return The new index\n     */\n    function getUserData(address _user, string calldata _incentivesProgram) external view returns (uint256);\n\n    /**\n     * @dev Returns the configuration of the distribution for a certain incentives program\n     * @param _incentivesProgram The incentives program name\n     * @return details The configuration of the incentives program\n     */\n    function incentivesProgram(string calldata _incentivesProgram)\n        external\n        view\n        returns (IncentiveProgramDetails memory details);\n\n    /**\n     * @dev Returns the program id for the given program name.\n     * This method TRUNCATES the program name to 32 bytes.\n     * If provided strings only differ after the 32nd byte they would result in the same ProgramId.\n     * Ensure to use inputs that will result in 32 bytes or less.\n     * @param _programName The incentives program name\n     * @return programId\n     */\n    function getProgramId(string calldata _programName) external pure returns (bytes32 programId);\n\n    /**\n     * @dev returns the names of all the incentives programs\n     * @return programsNames the names of all the incentives programs\n     */\n    function getAllProgramsNames() external view returns (string[] memory programsNames);\n\n    /**\n     * @dev returns the name of an incentives program\n     * @param _programName the name (bytes32) of the incentives program\n     * @return programName the name (string) of the incentives program\n     */\n    function getProgramName(bytes32 _programName) external pure returns (string memory programName);\n}\n"
    },
    "silo-core/contracts/incentives/lib/DistributionTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.28;\n\nlibrary DistributionTypes {\n    struct IncentivesProgramCreationInput {\n        string name;\n        address rewardToken;\n        uint104 emissionPerSecond;\n        uint40 distributionEnd;\n    }\n\n    struct AssetConfigInput {\n        uint104 emissionPerSecond;\n        uint256 totalStaked;\n        address underlyingAsset;\n    }\n\n    struct UserStakeInput {\n        address underlyingAsset;\n        uint256 stakedByUser;\n        uint256 totalStaked;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=gitmodules/forge-std/src/",
      "silo-foundry-utils/=gitmodules/silo-foundry-utils/contracts/",
      "properties/=gitmodules/crytic/properties/contracts/",
      "silo-core/=silo-core/",
      "silo-oracles/=silo-oracles/",
      "silo-vaults/=silo-vaults/",
      "ve-silo/=ve-silo/",
      "@openzeppelin/=gitmodules/openzeppelin-contracts-5/",
      "morpho-blue/=gitmodules/morpho-blue/src/",
      "openzeppelin5/=gitmodules/openzeppelin-contracts-5/contracts/",
      "openzeppelin5-upgradeable/=gitmodules/openzeppelin-contracts-upgradeable-5/contracts/",
      "chainlink/=gitmodules/chainlink/contracts/src/",
      "chainlink-ccip/=gitmodules/chainlink-ccip/contracts/src/",
      "uniswap/=gitmodules/uniswap/",
      "@uniswap/v3-core/=gitmodules/uniswap/v3-core/",
      "balancer-labs/v2-solidity-utils/=external/balancer-v2-monorepo/pkg/solidity-utils/contracts/",
      "balancer-labs/v2-interfaces/=external/balancer-v2-monorepo/pkg/interfaces/contracts/",
      "balancer-labs/v2-liquidity-mining/=external/balancer-v2-monorepo/pkg/liquidity-mining/contracts/",
      "pyth-sdk-solidity/=gitmodules/pyth-sdk-solidity/target_chains/ethereum/sdk/solidity/",
      "a16z-erc4626-tests/=gitmodules/a16z-erc4626-tests/",
      "ERC4626/=gitmodules/crytic/properties/lib/ERC4626/contracts/",
      "createx/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/src/",
      "crytic/=gitmodules/crytic/",
      "ds-test/=gitmodules/openzeppelin-contracts-5/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=gitmodules/openzeppelin-contracts-5/lib/erc4626-tests/",
      "halmos-cheatcodes/=gitmodules/morpho-blue/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts-5/=gitmodules/openzeppelin-contracts-5/",
      "openzeppelin-contracts-upgradeable-5/=gitmodules/openzeppelin-contracts-upgradeable-5/",
      "openzeppelin-contracts-upgradeable/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=gitmodules/openzeppelin-contracts-upgradeable-5/lib/openzeppelin-contracts/",
      "solady/=gitmodules/pyth-sdk-solidity/lazer/contracts/evm/lib/createx/lib/solady/",
      "solmate/=gitmodules/crytic/properties/lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {
      "silo-vaults/contracts/libraries/SiloVaultActionsLib.sol": {
        "SiloVaultActionsLib": "0xa146E55875EA0c1C6c70c867ae085DA9b54Bd9F2"
      },
      "silo-vaults/contracts/libraries/SiloVaultFactoryActionsLib.sol": {
        "SiloVaultFactoryActionsLib": "0x6e74A83e5Ef27846D8C6Ba44DEE50E33cd1Ca593"
      }
    }
  }
}